{"paragraph_scenes_info": [{"x": 1, "text": "In this dissertation, we advance the theory and practice of verifying visualization algori- thms.We present techniques to assess visualization correctness through testing of impor- tant mathematical properties.Where applicable, these techniques allow us to distinguish whether anomalies in visualization features can be attributed to the underlying physical process or to artifacts from the implementation under verification.Such scientific scrutiny is at the heart of verifiable visualization  subjecting visualization algorithms to the same veri- fication process that is used in other components of the scientific pipeline.The contributions of this dissertation are manifold.We derive the mathematical framework for the expected behavior of several visualization algorithms, and compare them to experimentally observed results in the selected codes.In the Computational Science & Engineering community CS&E, this technique is know as the Method of Manufactured Solution (MMS).We apply MMS to the verification of geometrical and topological properties of isosurface extraction algorithms, and direct volume rendering.We derive the convergence of geometrical prop- erties of isosurface extraction techniques, such as function value and normals.For the verification of topological properties, we use stratified Morse theory and digital topology to design algorithms that verify topological invariants.In the case of volume rendering algorithms, we provide the expected discretization errors for three different error sources.The results of applying the MMS is another important contribution of this dissertation.We report unexpected behavior for almost all implementations tested.In some cases, we were able to find and fix bugs that prevented the correctness of the visualization algorithm.In particular, we address an almost 20-year-old bug with the core disambiguation procedure of Marching Cubes 33, one of the first algorithms intended to preserve the topology of the trilinear interpolant.Finally, an important by-product of this work is a range of responses practitioners can expect to encounter with the visualization technique under verification."}, {"x": 6, "text": "New theories are put forward and evaluated through the scientific method: observations; hypothesis formulation; predictions and testing; and analysis of the results.Details on how to perform each of these steps vary according to the phenomena being studied.A particularly important step in the process of deriving a valid scientific theory is the process of falsification: the process by which the theory predictions are tested.As Karl Popper argued in The Logic of Scientific Discovery <140, p.9>:"}, {"x": 8, "text": "An example of testing risky prediction is the classic Eddingtons experiment of Einsteins theory of relativity <27>.Eddington conducted an experiment to measure the light deflection caused by the massive size of the Sun.During the eclipse of May 29th 1919, Eddington photographed the Hyades star cluster and measured the light deflected.At the time, Newtons law of gravity was the accepted theory; it predicted some shift in the position of the stars, as observed from Earth, whereas Einsteins theory of gravity predicted twice as much shift.Because Einsteins prediction contradicted current theory, it was a risky prediction.The eclipse was photographed, and the deviations were measured.At that time, two outcomes were possible: either the expected (predicted) deflection would not match the observed one  because no deflection is observed, or Newtons prediction was correct, or some other value is obtained  in which case the theory would be refuted; or, the predicted deflection would match the observations, in which case, nothing could be said about the correctness of the theory, aside from that it has not been proved wrong and has stood up to risky tests.The more a theory is tested, the more trustworthy it becomes."}, {"x": 9, "text": "The same idea of falsification can be applied to test the trustworthiness of an algorithm and its implementation.During the course of a scientific inquiry, scientists carefully perform each step in the scientific method to mitigate and control errors.For each step of the scientific method, there are multiple ways to account for these errors: by using sophis- ticated statistical methods; advanced mathematical models; high-precision equipments; redundancy; etc.The reason behind it is that the reliability of the conclusions depends on how each of the steps are performed.In the example of Eddingtons experiment, a series of precautions had to be made and several error sources were taken into account to show that Einsteins predictions were correct1.Since the scientific methodology is used to increase ones confidence in a particular statement, it can also be applied to the substeps involved in the formulation of a scientific theory, which, in turn, builds up ones confidence in the theory itself.There is a need for reliability of scientific software.The lack of such guarantees led the discipline of Computational Fluid Dynamics (CFD) to once be referred to as Colorful Fluid Dynamics <112>.Of course, the Computational Science & Engineering and Computer Science communities have already developed standard methodology for software verification."}, {"x": 11, "text": "The meaning of the word verification may vary according to the context in which it is used.When applied loosely, it refers to good coding practices (e.g., use of versioning system), software testing (e.g., unit/regression tests), and even the process of debugging a code.These practices are obviously valuable to help build a trustworthy software, but they are often ad hoc and have limited scope.In this dissertation, the word verification is used as in Computer Science (CS) and Computation Simulation (CS&E).In CS according to IEEE standards, verification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase <67>.In this context, the program specification is the condition imposed at the start phase and the verification process ideally should guarantee that the resulting implementation (i.e., final computer software) meets the specification exactly.In"}, {"x": 12, "text": "1They started by sending off two expeditions.The first to Sobral, northern Brazil, and another to the island of Pr ncipe, northern of Sa o Tom e and Pr ncipe.Aside from equipment related to the telescope, backup lenses were packed along with all necessary equipment to account for the rotation of the Earth.The expedition at Pr ncipe, among other problems, had to deal with clouds and rain, thus they were able to retrieve only two usable photos.The expedition at Sobral, on the other hand, encountered better weather but had problems due to the rise of the temperature between the time the telescope was assembled and the time of the eclipse.Parts of the telescope expanded and as a result, the images were blurred.Another problem was related to the very small expected light deflection.Since photograph plates could expand and shrink with the temperature, deflection could be due to other factors other than light deflection, such as shrinkage.Other source of errors are involved.According to Coles <27>, at the time the results were published, they were met with some skepticism.For more details, see Coles <27>.the past few decades, several techniques have been developed to attain software verification, which include theorem provers <12>, model checking <25>, fuzzing <7, 56>, and others.This variety of techniques is due to the difficult task of testing a program (either a model or an implementation) which may contain millions of lines of code and an exponentially large state-space where a bug might be hidden.Because of this large number of paths, verification can be considered a process where one accumulates evidence that a code is correct <143>, rather than deriving a proof that the code is actually correct.These techniques have been successfully applied not only for verification of user-level computer code <5>, but also hardware <157> and operating system kernel <79>."}, {"x": 13, "text": "Verification techniques developed in the CS&E community are focused in general on the numerical solution of partial differential equations (PDEs) that models a physical phenomena of interest.In this context, verification is defined as the process of determining if a computational model, and its corresponding numerical solution, can be used to represent the mathematical model of the event with sufficient accuracy <3>.This definition is closely related to the errors involved during discretization and implementation.They are of great importance to scientists because they can be used to assess which of the models, mathe- matical or computational, should be refined.A successful approach for code verification, known to be sensitive to code mistakes <143>, is the order of accuracy test  an evaluation of the implementation behavior when submitted to successive grid refinements <143>."}, {"x": 14, "text": "The verification tools proposed by the CS and CS&E communities cover only part of the scientific pipeline.Given the importance of visualizations, not only numerical softwares have to be verified, but also visualization algorithms and implementations.Nevertheless, visual- ization has not fallen under the same rigorous scrutiny as other components of the pipeline like mathematical modeling and numerical simulation.Unlike traditional computational science and engineering areas, there is no commonly accepted framework for verifying the accuracy, reliability, and robustness of visualization tools.Furthermore, very few studies have focused on how the error originating from other components of the computational pipeline impacts visualization algorithms."}, {"x": 18, "text": "1.Chapter 2: Verifying Geometry of Isosurface Extraction Algorithms <46>."}, {"x": 23, "text": "2.Chapter 3: Verifying Topology of Isosurface Extraction Algorithms <45>."}, {"x": 25, "text": "(b) We derive a framework based on Digital Topology for the extraction of impor- tant invariants (topological properties) that should be honored by topologically correct implmentations;"}, {"x": 26, "text": "(c) In addition, we derive a framework based on Stratified Morse Theory for the extraction of important invariants;"}, {"x": 28, "text": "3.Chapter 4: Practical Considerations on the Topological Correctness of Marching Cubes 33 <29>."}, {"x": 29, "text": "(a) We show that both the Marching Cubes 33 algorithm and implementation have problems that prevent its topological correctness.Moreover, one of the problems is traced back to its original publication;"}, {"x": 32, "text": "4.Chapter 5: Verifying Direct Volume Rendering Algorithm <43>."}, {"x": 36, "text": "5.Chapter 6: Flow Visualization <44>."}, {"x": 40, "text": "CHAPTER 2 VERIFYING GEOMETRY OF ISOSURFACE EXTRACTION ALGORITHMS"}, {"x": 44, "text": "Previous researchers have examined topological issues <127, 94>, mesh quality <33, 153>, accuracy <131, 195>, and performance <165>.The influence of different reconstruction schemes and filters in scalar visualization has also been examined <16, 139>.In this chapter, we focus on techniques to verify the correctness of algorithms and their corresponding implementa- tions.In particular, we provide mathematical tools that other researchers and developers can use to increase their confidence in the correctness of their own isosurface extraction codes.A traditional way to test implementations in scientific visualization is to perform a visual inspection of the results of the Marschner-Lobb dataset <102>.In the context of isosurface extraction, researchers routinely use tools such as Metro <24> to quantitatively measure the distance between a single pair of surfaces.We argue that the methodology presented here is more effective and more explicit at elucidating a techniques limitations."}, {"x": 46, "text": "Globus and Uselton <55> and more recently, Kirby and Silva <76> have pointed out the need for verifying both visualization techniques and the corresponding software im- plementations.In this chapter, we provide concrete tools for the specific case of isosurface extraction.Although this is only one particular technique in visualization, we expect the general technique to generalize."}, {"x": 48, "text": "2.2 Verifying Isosurface Extraction Algorithms"}, {"x": 49, "text": "In this section, we describe the technique we use for verifying isosurface extraction algorithms, namely the method of manufactured solutions (MMS).We illustrate a possible implementation of MMS in Algorithm 1 and Figure 2.1.This technique requires us to write down the expected behavior of particular features of interest of the object (or model prob- lem) being generated.In our case, we are generating triangular approximations of smooth isosurfaces, and the features of interest are geometric surface convergence, convergence of normals, area, and curvature."}, {"x": 50, "text": "To use MMS, we first accomplish a mathematical analysis of the expected convergence rate of the features (or characteristics) of interest, known in the numerical literature as the formal order of accuracy of the characteristic.This analysis is done for solutions of the problem that can be conveniently described and analyzed (these are the manufactured solutions).Then, the code is executed with progressively refined versions of the data that are used in the generation or sampling of the manufactured solution.Finally, the empirical convergence rate is compared to the one predicted by the analysis.When the convergence rates are comparable, we increase our confidence in the algorithm.If the realizable behavior"}, {"x": 51, "text": "In what follows, we will derive expected orders of accuracy for several features of surfaces produced by isosurface extraction codes.We keep our assumptions about the actual algorithms to a minimum to maximize the applicability of the arguments given.We essentially only assume that the maximum triangle size can be bounded above at any time, and use Taylor series arguments (under assumptions of smoothness) to derive convergence rates.It is important to point out that order of accuracy analysis of polyhedral surfaces has been studied by many researchers <110, 190, 191, 62>.In fact, the results presented below are in agreement with the ones reported in the literature.However, because we are considering isosurface extraction, some of our arguments benefit by being able to be condensed to simpler statements."}, {"x": 52, "text": "2.2.1 Convergence of Vertex Position"}, {"x": 53, "text": "We start our analysis of isosurface extraction by studying the convergence of vertex positions.We analyze this convergence indirectly by relating the values of the scalar field at the vertex points and the distance between the vertices and the correct isosurface.Given a value  such that the exact isosurface S is defined by f(x,y,z) = f(v) = , the algebraic distance of v to S is defined as |f (v)  | <167>.Notice that algebraic distances only makes sense for implicit surfaces: it requires a scalar field.In addition, we restrict ourselves to regular isosurfaces, ones where for every point x in S, |f(x)| exists and is nonzero.Then, the geometric distance between v and S is approximated by |f(v)  |/|f(v)| <167>.We illustrate this relation in Figure 2.2.Since, by assumption, |f(x)| > k for some k > 0, and all x in S, convergence in algebraic distance implies convergence in geometric distance.Convergence in algebraic distance, however, is much more tractable mathematically, and this is the item to which we turn our focus."}, {"x": 54, "text": "Many isosurface methods estimate vertex positions through linear interpolation along edgesofagrid.Letf :U R3 Rbetheasmoothrealfunctiondefinedinasubset U = <ax, bx>  <ay, by>  <az, bz>, where <ai, bi>, i  x, y, z are real intervals.We assume the intervals <ai,bi> have the same length and let ax = x0,...,xn = bx, ay = y0,...,yn = by, and az = z0,...,zn = bz be subdivisions for the intervals such that xi = x0 + ih, yi = y0 + ih, zi = z0 +ih, i = 0,...,n, where h is the grid size and cijk = <xi,xi+1><yj,yj+1><zk,zk+1> is a grid cell.Through a Taylor series expansion of f, one can evaluate f at a point p  cijk"}, {"x": 55, "text": "2.2.2 Convergence of Normals"}, {"x": 57, "text": "2.2.3 Convergence of Area"}, {"x": 60, "text": "2.2.4 Convergence of Curvature"}, {"x": 61, "text": "The following formula gives an estimate of the curvature at a vertex p: K(p)= 2 ii+1"}, {"x": 62, "text": "Subsequently, Xu <190> presented a very particular distribution of vertices around p under which the curvature estimated by Equation (2.9) has accuracy O(h2)."}, {"x": 63, "text": "Curvature discretization schemes other than the one given in Equation (2.9) such as the quadratic-fit and spherical-image method (see Meek and Walton <110> for details) also demand particular vertex distributions to ensure convergence.In our context of keeping the analysis applicable for many isosurfacing algorithms, this means we cannot use the lack of observed curvature convergence as an indication of problematic behavior.Based on the results mentioned above, one should actually expect curvature not to converge for most isosurface extraction algorithms.More generally, this indicates a weakness of MMS, namely that some features of interest (such as curvature) will not have sufficient theoretical order of accuracy to be used in numerical measurements.Notice, in addition, that if we had not written down the theoretical model for curvature convergence, we might have expected some sort of curvature approximation.Even a negative result such as the one presented in this section can increase the confidence in the results generated by an implementation."}, {"x": 65, "text": "In this section, we present the results of applying the afore-described methodology.We use the framework to verify six different isosurface extraction codes, namely: VTK Marching Cubes <100>, SnapMC <141>, Macet <33>, Dual Contouring <73>, Afront <153>, and DelIso <32>.All these implementations are open source and/or publicly available.Before presenting the actual results of subjecting these implementations to the verification process, we briefly review their salient features."}, {"x": 66, "text": "2.3.1 VTK Marching Cubes"}, {"x": 67, "text": "Marching Cubes <100> (MC) is arguably the most popular isosurface extraction algo- rithm.It reduces the problem of generating an isosurface triangulation to a finite set of cases by considering the signs of how the isosurface intersects each cell of a regular background grid.As there are only 256 different types of intersections between the isosurface and a regular Cartesian 3D cell, a template of triangles is set to each case, making the implementation quite simple through a look-up table.The vertices of the triangles lie on the edges of the cubic cells, and they are computed by linearly interpolating the implicit function values stored at the corners of the grid cell."}, {"x": 69, "text": "SnapMC <141> is a recently proposed algorithm that extends the original Marching Cubes look-up table to cases where the isosurface goes exactly through the corners of the back- ground grid.The new look-up table is automatically built by an adaptation of the convex hull scheme proposed by Bhaniramka et al.<6>.Even though the traditional Marching Cubes algorithm can easily handle these cases by some kind of symbolic perturbation, SnapMC perturbs the scalar field to avoid edge intersections close to grid corners.In particular, it changes the values on the grid so that the surface is snapped to the grid corners."}, {"x": 71, "text": "Macet <33> is another variant of Marching Cubes that tries to improve the shape of the triangles in a mesh.Unlike SnapMC, it perturbs the active edges of Marching Cubes cases by moving the vertices before the triangulation step.The motivation behind Macet is that poorly-shaped triangles tend to be generated when the intersection between the isosurface and a grid cell is approximately parallel to an edge of the grid cell.Therefore, some corners of the background grid are displaced so as to avoid the parallel-like intersections."}, {"x": 73, "text": "Dual Contouring <73> is a feature-preserving isosurfacing method to extract crack-free surfaces from both uniform and adaptive octree grids.This technique can be seen as a combination of Extended Marching Cubes <81> and SurfaceNets <53> as it makes use of Hermite data and quadratic error function minimization to position the vertices of the surface mesh (as Extended Marching Cubes) and the dual topology to connect such vertices (as SurfaceNets).Dual Contouring tends to generate better quality triangles than Marching Cubes while still being very effective in representing sharp features, rendering this implicit polygonalization method a good alternative to the popular Marching Cubes."}, {"x": 77, "text": "DelIso <32> is a Delaunay-based approach for isosurfacing.It computes the restricted Delaunay triangulation from a 3D Voronoi Diagram.We run our tests on a customized version of DelIso 16 bit, and our examples use the default set of parameter."}, {"x": 81, "text": "The order of accuracy for VTK Marching Cubes, SnapMC, Macet, and Dual Contouring depends on the cell size h.We run our tests with grid refinement hi+1 = hi/2 and initial condition h1.For Afront, the order of accuracy depends on parameter , thus the refinement is given by i+1 = i/2 with initial condition 1.Our customized version of DelIso has an additional parameter  that controls the largest edge on the output mesh.In this case, the refinement formula is i+1 = i/2.In the particular case of SnapMC, we set the snap parameter  to its maximum value ( = 1/2).Even though the manufactured solution we selected is about as simple as can be imagined, comparing the formal order of accuracy with the observed one was enough to suggest bugs in two implementations.The observed order of accuracy of the examined properties is presented on Table 2.1."}, {"x": 85, "text": "Section 2.2.2 shows that one expects first-order of accuracy for normal computations.We define the following approximation error using L norm: where j is the angle between the normal of the triangle j and the normal of the point in S closest to the centroid of j. As shown in Figure 2.5(b), VTK Marching Cubes, Afront, SnapMC, and DelIso have good observed order of accuracy above 0.8.However, only VTK Marching Cubes and DelIso present close proximity to linear.Macet and Dual Contouring once again do not present a consistent order.Figure 2.6(b) shows the results after fixing both codes."}, {"x": 87, "text": "Although there is no formal order of accuracy for area, one expects some convergence for it (Section 2.2.3).We define the following approximation error: where A is the area function of a continuous or piecewise-linear surface.The results are shown in Figure 2.5(c).VTK Marching Cubes, Afront, and DelIso present second-order of accuracy, as shown in Figure 2.5(c).SnapMC accuracy is slightly better than quadratic due to poor approximation for large h.The error dropped faster than quadratic when the grid was refined for the first time.Macet and Dual Contouring exhibit once again unexpected behavior.Unlike the previous time, the curves now seem to diverge when h is too small.Once the bug is fixed, the convergence curves changes, and they become quadratic (Figure 2.6(c))."}, {"x": 89, "text": "Section 2.2.4 shows that one expects zero-th order of accuracy for curvature computation.We define the approximation error using L norm: where K(v) is the Gaussian curvature at v  S and K (v) is the Gaussian curvature at v  S .In this particular case where S is a sphere, K(v) = 1 for every v  S.The results are shown in Figure 2.5(d).DelIso, Afront, and SnapMC are close to zeroth-order accuracy.The curvature order of accuracy for VTK Marching Cubes, on the other hand, diverges significantly.This unexpected behavior might deserve further investigation which we leave for future work.Although the curves shown in Figure 2.5(d) for Macet and Dual Contouring diverge, they change after fixing the code (Figure 2.6(d))."}, {"x": 91, "text": "We were able to find and fix bugs in two of the implementations under verification, namely, Macet and Dual Contouring, using as manufactured solution a sphere centered at origin with radius 1.The new result curves are shown in Figure 2.6.The observed order of accuracy for Dual Contouring is quite satisfactory for all manufactured solution.In particular, the normal order of accuracy has the best rate among the methods.Macet improved for its results for area.On the other hand, it still has some issues related to normals, which perhaps indicates a need for more tests and verification.The new order of accuracy for algebraic distance (Figure 2.6(a)) does not tell us much about the correctness of the code because of the zero-th order of accuracy (same for Afront)."}, {"x": 92, "text": "The zero-th order of accuracy might happen if the formal order of accuracy is zero-th order, in which case the observed order matches the formal order.It might also happen due to a poor choice for manufactured solution.If it is not complex enough, the implementation being tested may approximate exactly the solution and therefore there is no error within the approximation although another error source (truncation error, for instance) may show up.The next section presents a detailed discussion concerning MMS."}, {"x": 95, "text": "As we have shown, MMS is an effective means of diagnosing problems within the algorithms and implementations of isosurface extraction algorithms.In this work, we have considered the two  algorithm and implementation  as one unit as one cannot always distinguish between the two if only limited information (source code and algorithmic details) is available.In this section, we present a more thorough discussion of the use of MMS, particularly for isosurface extraction."}, {"x": 97, "text": "One of the primary advantages of verifying simulation codes using MMS is that it is a nonintrusive method.MMS treats the code being verified as a blackbox, and so can be easily integrated into an existing test suite with little to no impact.However, MMS does not see the implementation, and so provides little direct information about where a particular bug might be when there is a discrepancy between the formal and observed orders of accuracy.In our experience, there are three main places where mistakes can happen: (1) in the design and construction of the manufactured solution, (2) in the coding of the algorithm being tested, and (3) in the evaluation and interpretation of the results.Mistakes on the evaluation of results have two flavors: misinterpretation or poor formal order of accuracy.The first heavily depends on testers and experts experience and ability to judge what a good result is.For example, should the normal observed order of accuracy for Afront and Macet on Figure 2.5(b) be considered linear (p = 0.80 and p = 0.75, respectively)?The latter depends on a rigorous formal order of accuracy analysis of the algorithm considering all sorts of errors; even round-off errors may be significant.In fact, we spent more time on writing out rigorously the analysis of the formal order of accuracy and on searching for possible sources of error than on the tests themselves.This again highlights the fact that verification using MMS is a process: it is typical to go back to the white board and refine formal analyses before arriving at conclusive answers.Although the formal order of accuracy analysis might be a painful process, the literature has many results that can be promptly used.As a consequence, if one wishes to writes his own MC technique, for instance, his only concern is to write a test which exploits the results available within the literature."}, {"x": 99, "text": "The complexity of the manufactured solution can have a large influence on the effec- tiveness of verification.Suppose one chooses the manufactured solution to be f(x,y,z) = x+y+k, k constant, instead of a sphere.Since MC-based techniques use linear interpolation, one expects the approximation to be exact regardless of any discretization parameter h, i.e., p = 0 (notice that the evaluated error might be nonzero, implying there is some other error source that does not depend on h).Since such a function f is extremely simple, it might not trigger bugs that would otherwise reduce the observed order of accuracy.In our experiments, the (problematic) implementation of Dual Contouring achieved the formal order of accuracy for this particularly simple function (p = 0)."}, {"x": 100, "text": "Another example on the influence of manufactured solution arose with in our exami- nation of Afront.Because Afront uses Catmull-Rom splines, some simple isosurfaces will converge to within numerical error for very rough volumes, and the numerically observed order of accuracy will be much lower than expected.With an implicit function whose isosurfaces are spheres, we observed zero-th order of accuracy for Afront for algebraic distance.With a modified implicit function that included transcendental functions, MMS reveals that Afront does not have the expected convergence rate on the full interval, as shown in Figure 2.7.Notice that Macet has similar behavior.Additional tests are needed to determine the source of this behavior within both codes."}, {"x": 102, "text": "In this chapter, we have chosen to make our formal analysis as generic as possible to accommodate as many implementations under verification as possible.Although we are able to evaluate many codes using the same manufactured solution, when using MMS for a particular code, it is best to exploit as much detail about the algorithm as necessary.If the goal is to design a manufactured solution for verifying Marching Cubes-based techniques, the manufactured solution should exercise all possible cases.Additionally, particular aspects of the manufactured solutions can be incorporated into the formal analysis.For example, the analysis for Afront becomes much more complicated if curvatures are not constant over the surface (in that case, its additional parameter  comes into play <153>, and accurately bounding the triangle size is not practical)."}, {"x": 103, "text": "The errors in Section 2.3.7 were measured at different locations on the mesh.Vertex convergence and Gaussian curvature were measured on triangle vertices, while normals were measured on the triangle centroid.More importantly, measurements performed at different locations may have different orders of accuracy.For example, Macet has cubic formal order of accuracy on vertices due to the spline approximation but quadratic formal order of accuracy on centroids."}, {"x": 104, "text": "In Section 2.2, we define the error using a pessimistic L norm.This makes MMS a very sensitive technique.In fact, it can detect subtle off-by-one mistakes in grid sizes and interactions between node-centric and cell-centric reconstructions, even for simple manufactured solutions.In these cases, it is important not to infer incorrect conclusions."}, {"x": 105, "text": "The numerical estimates for MMS should be performed on as wide a range of parameter values as possible.In our tests, we used h  (0.001,1.0) and observed that both faulty implementations performed appropriately for large values of h. Just as the implementations might only enter the asymptotic regime and achieve the formal convergences for small values of h, it might be that (as we have experienced) bugs only manifest themselves on sufficiently small values of h."}, {"x": 107, "text": "MMS does not cover every aspect of verification for isosurface extraction.For example, an important aspect we do not know how to test with MMS is the topological correctness of an extracted mesh.This is challenging because there does not seem to be a good measure of convergence for topological properties such as the Euler characteristic or Betti numbers.A proper study of these issues is a natural avenue for future work."}, {"x": 110, "text": "CHAPTER 3 VERIFYING TOPOLOGY OF ISOSURFACE EXTRACTION ALGORITHMS"}, {"x": 113, "text": "In this chapter, we investigate isosurfacing algorithms and implementations and focus on their topological properties.For brevity, we will use the general phrase isosurfacing when we refer to both isosurfacing algorithms and their implementations.As a simple example, the topology of the output of isosurface codes should match that of the level set of the scalar field (as discussed in Section 3.2).Broadly speaking, we use the method of manufactured solutions (MMS) to check these properties.By manufacturing a model whose known behavior should be reproduced by the techniques under analysis, MMS can check whether they meet expectations."}, {"x": 114, "text": "An important contribution of this work is the selection of significant topological char- acteristics that can be verified by software methods.We use results from two fields in computational topology, namely, digital topology and stratified Morse theory."}, {"x": 118, "text": "3.We introduce a simple technique to compute the Euler characteristic of a level set of a trilinearly interpolated scalar field.The technique relies on stratified Morse theory and allows us to verify topological properties of isosurfaces with boundaries."}, {"x": 125, "text": "Arguably the most popular isosurface extraction technique, Marching Cubes <100> (MC) processes one grid cell at a time and uses the signs of each grid node (whether the scalar field at the node is above or below the isovalue) to fit a triangular mesh that approximates the isosurface within the cell.As no information besides the signs is taken into account,"}, {"x": 126, "text": "Marching Cubes cannot guarantee any topological equivalence between the triangulated mesh and the original isosurface.In fact, the original Marching Cubes algorithm would produce surfaces with cracks, caused by alternating vertex signs along a face bound- ary, which lead to contradicting triangulations in neighboring cells <126>.Disambiguation mechanisms can ensure crack-free surfaces, and many schemes have been proposed, such as the one by Montani et al.<117>, domain tetrahedralization <16>, preferred polarity <8>, gradient-based method <180>, and feature-based schemes <64>.The survey of Newman and Yi has a comprehensive account <124>.Although disambiguation prevents cracks in the output, it does not guarantee topological equivalence."}, {"x": 128, "text": "3.1.2 Verifiable Visualization"}, {"x": 129, "text": "Many of the false steps in the route from the original MC algorithm to the recent homeomorphic solutions could have been avoided with a systematic procedure to verify the algorithms and the corresponding implementations.Although the lack of verification of visualization techniques and the corresponding software implementations has been a long-term concern of the visualization community <55, 76>, concrete proposals on verification are relatively recent.Etiene et al.<46> were among the first in scientific visualization to propose a practical verification framework for geometrical properties of isosurfacing.Their work is based on the method of manufactured solutions (MMS), a popular approach for assessing numerical software <3>.We are interested in topological properties of isosurfacing, and we also use MMS as a verification mechanism.As we will show in Section 3.5, our proposed technique discovered problems in popular software, supporting our assertion about the value of a broader culture of verification in scientific visualization."}, {"x": 130, "text": "There have been significant theoretical investigations in computational topology dealing with, for example, isosurface invariants, persistence, and stability <26, 36>.This body of work is concerned with how to define and compute topological properties of computational objects.We instead develop methods that stress topological properties of isosurfacing.These goals are complementary.Computational topology tools for data analysis might offer new properties which can be used for verification purposes, and verification tools can assess the correctness of the computational topology implementations.Although the mechanism we propose to compute topological invariants for piecewise smooth scalar fields is, to the best of our knowledge, novel (see Section 3.3.2), our primary goal is to present a method that developers can adapt to assess their own software."}, {"x": 131, "text": "3.2 Verifying Isosurface Topology"}, {"x": 132, "text": "We now discuss strategies for verifying topological properties of isosurfacing techniques.We start by observing that simply stating the desired properties of the implementation is valuable.Consider a typical implementation of Marching Cubes.How would you debug it?Without a small set of desired properties, we are mostly limited to inspecting the output by explicitly exercising every case in the case table.The fifteen cases might not seem daunting, but what if we suspect a bug in symmetry reduction?We now have 256 cases to check.Even worse, what if the bug is in a combination of separate cases along neighboring cells?The verification would grow to be at least as complicated as the original algorithm, and we would just as likely make a mistake during the verification as we would in the implementation.Therefore, we need properties that are simple to state, easy to check, and good at catching bugs."}, {"x": 134, "text": "Although the previously mentioned problem with Marching Cubes <100> is well-known, it is not immediately clear what topological properties fail to hold.For example, the output of Marching Cubes cannot contain boundary curves is not one such property, for two reasons.First, some valid surfaces generated by Marching Cubes  such as with the simple 23 case  do contain boundaries.Second, many incorrect outputs might not contain any boundaries at all.The following might appear to be a good candidate property: given a positive vertex v0 and a negative vertex v1, any path through the scalar field should intersect the isosurface an odd number of times.This property does capture the fact that the triangle mesh should separate interior vertices from exterior vertices and seems to isolate the problem with the cracks.Checking this property, on the other hand, and even stating it precisely, is problematic.Geometrical algorithms for intersection tests are notoriously brittle; for example, some paths might intersect the isosurface in degenerate ways.A more promising approach comes from noticing that any such separating isosurface has to be a piecewise-linear manifold, whose boundary must be a subset of the boundary of the grid.This directly suggests that the output of Marching Cubes must be a piecewise- linear (PL) manifold whose boundaries are contained in the boundary of the grid.This property is simple to state and easy to test: the link of every interior vertex in a PL manifold is topologically a circle, and the link of every boundary vertex is a line.The term consistency has been used to describe problems with some algorithms <124>.In this work, we say that the output of an algorithm is consistent if it obeys the PL manifold property above.By generating arbitrary grids and extracting isosurfaces with arbitrary isovalues, the inconsistency of the original case table becomes mechanically checkable and instantly apparent.Some modifications to the basic Marching Cubes table, such as using Nielson and Hamanns asymptotic decider <126>, result in consistent implementations, and the outputs pass the PL manifold checks (as we will show in Section 3.5)."}, {"x": 135, "text": "The example we have presented above is a complete instance of the method of manufac- tured solutions.We identify a property that the results should obey, run the implementa- tions on inputs, and test whether the resulting outputs respect the properties.In the next sections, we develop a verification method for algorithms to reproduce the topology of the level sets of trilinear interpolation <21, 98, 125>, thus completely eliminating any ambiguity.In this work, we say the output is correct if it is homeomorphic to the corresponding level set of the scalar field.This correctness property is simple to state, but developing effective verification schemes that are powerful and simple to implement is more involved.We will turn to invariants of topological spaces, in particular to Betti numbers and the Euler characteristic, their relative strengths and weaknesses, and discuss how to robustly check their values.Figure 3.1 shows our pipeline to assess topological correctness and also the chapter organization."}, {"x": 137, "text": "This section describes the mathematical machinery used to derive the topology verifi- cation tools.More specifically, we provide a summary of the results we need from digital topology and stratified Morse theory.A detailed discussion on digital topology can be found in the work by Stelldinger et al.<164>, and Goresky and MacPherson give a comprehensive presentation of stratified Morse theory <57>."}, {"x": 138, "text": "In Section 3.3.1, we describe a method, based on digital topology, that operates on manifold surfaces without boundaries and determines the Euler characteristic and Betti numbers of the level sets.A more general setting of surfaces with boundaries is handled with tools derived from stratified Morse theory, detailed in Section 3.3.2.The latter method can only determine the Euler characteristic of the level set."}, {"x": 139, "text": "Let us start by recalling the definition and some properties of the Euler characteristic, which we denote by .For a compact 2-manifold M, (M) = V  E + F , where V , E, and F are the number of vertices, edges, and faces of any finite cell decomposition of M. If M is a connected orientable 2-manifold without boundary, (M) = 2  2g(M), where g(M) is the genus of M. The Euler characteristic may also be written as (M) =  ni=0(1)ii, where i are the Betti numbers: the rank of the i-th homology group of M. Intuitively, for 2-manifolds, 0, 1, and 2 correspond to the number of connected components, holes, and voids (regions of the space enclosed by the surface), respectively.If M has many distinct connected components, that is, M =  ni=1 Mi and Mi   Mj =  for i = j, then (M) =  ni (Mi).More details about Betti numbers, the Euler characteristic, and homology groups can be found in Edelsbrunner and Harers text <36>.The Euler characteristic and the Betti numbers are topological invariants: two homeomorphic topological spaces will have the same Euler characteristic and Betti numbers whenever these are well-defined."}, {"x": 141, "text": "Let G be an n  n  n cubic regular grid with a scalar e(s) assigned to each vertex s of G and t : R3  R be the piecewise trilinear interpolation function in G, that is, t(x) = ti(x), where ti is the trilinear interpolant in the cubic cell ci containing x.Given a scalar value , the set of points satisfying t(x) =  is called the isosurface  of t. In what follows, t(x) =  will be considered a compact, orientable 2-manifold without boundary.We say that a cubic cell ci of G is unambiguous if the following two conditions hold simultaneously:"}, {"x": 146, "text": "The geometric dual of G is called the voxel grid associated with G, denoted by VG.More specifically, each vertex s of G has a corresponding voxel vs in VG , each edge of G corresponds to a face in VG (and vice versa), and each cubic cell in G corresponds to a vertex in VG, as illustrated in Figure 3.3.Each voxel vs can also be seen as the Voronoi cell associated with s. Scalars defined in the vertices of G can naturally be extended to voxels, thus ensuring a single scalar value e(vs) to each voxel vs in VG defined as e(s) = e(vs).As we shall show, the voxel grid structure plays an important role when using digital topology to compute topological invariants of a given isosurface.Before showing that relation, though, we need a few more definitions."}, {"x": 147, "text": "Denote by G the (2n  1)  (2n  1)  (2n  1) regular grid obtained from a refinement of G. Vertices of G can be grouped in four distinct sets, denoted by O, F, E, C.The set O contains the vertices of G that are also vertices of G.The sets F and E contain the vertices of G lying on the center of faces and edges of the voxel grid VG, respectively.Finally, C"}, {"x": 148, "text": "Since t is trilinear, no level-set of t can intersect an edge more than once.Hence, if ci is not ambiguous, ti is exactly one of the cases 1 to 7 in the top row of Figure 3.2 <98>, either a topological disk or the empty set.Each case in the top row of Figure 3.2 is the unambiguous input for the MI algorithm to produce the voxel reconstruction shown in the middle row, where the boundaries of each of these voxel reconstructions are shown in the bottom row.By inspection, we can verify that the boundary of the digital reconstruction Oi (bottom row of Figure 3.2) is also a disk for all possible unambiguous cases and complement cases.Hence, for each i, the 2-manifolds Oi and ti are homeomorphic.Then, for each i, both Oi and ti cut the same set of edges and faces of ci.Again, we can verify this for all possible i by inspecting the top and bottom rows in Figure 3.2, respectively.Finally, we apply the Pasting Lemma <120> across neighboring surfaces Oi and Oj in order to establish the homeomorphism between O and t. 2"}, {"x": 150, "text": "3.3.2 Stratified Morse Theory"}, {"x": 151, "text": "The mathematical developments presented above allow us to compute the Betti numbers of any isosurface of the piecewise trilinear interpolant.However, they require isosurfaces without boundaries.In this section, we provide a mechanism to compute the Euler charac- teristic of any regular isosurface of the piecewise trilinear interpolant through an analysis based on critical points, which can be used to verify properties of isosurfaces with boundary components.We will use some basic machinery from stratified Morse theory (SMT), following the presentation of Goresky and MacPhersons monograph <57>."}, {"x": 152, "text": "Let f for now be a smooth function with isolated critical points p, where f(p) = 0.From classical Morse theory, the topology of two isosurfaces f(x) =  and f(x) = + differs only if the interval <,  + > contains a critical value (f (p) is a critical value iff p is a critical point).Moreover, if p is a small neighborhood around p and L(p) and L+(p) are the subset of points on the boundary of p satisfying f(x) < f(p) and f(x) > f(p), respectively, then the topological change from the isosurface f(x) = f(p) to f(x) = f(p)+ is characterized by removing L(p) and attaching L+(p).Thus, changes in the Euler characteristic, denoted by (p), are given by:"}, {"x": 153, "text": "For a smooth function f, the number of negative eigenvalues of the Hessian matrix de- termines the index of a critical point p, and the four cases give the following values for"}, {"x": 154, "text": "The above formulation is straightforward but unfortunately cannot be directly applied to functions appearing in either piecewise trilinear interpolations or isosurfaces with boundary, both of which appear in some of the isosurfacing algorithms with guaranteed topology.Trilinear interpolants are not smooth across the faces of grid cells, so the gradient is not well- defined there.Identifying the critical points using smooth Morse theory is then problematic.Although arguments based on smooth Morse theory have appeared in the literature <183>, there are complications.For example, the scalar field in a node of the regular grid might not have any partial derivatives.Although one can still argue about the intuitive concepts of minima and maxima around a nondifferentiable point, configurations such as saddles are more problematic, since their topological behavior is different depending on whether they are on the boundary of the domain.It is important, then, to have a mathematical tool which makes predictions regardless of the types of configurations, and SMT is one such theory."}, {"x": 155, "text": "Intuitively, a stratification is a partition of a piecewise-smooth manifold such that each subset, called a stratum, is either a set of discrete points or has a smooth structure.In a regular grid with cubic cells, the stratification we propose will be formed by four sets (the strata), each one a (possibly disconnected) manifold.The vertex set contains all vertices of the grid.The edge set contains all edge interiors, the face set contains all face interiors, and the cell set contains all cube interiors.We illustrate the concept for the 2D case in Figure 3.4.The important property of the strata is that the level sets of f restricted to each stratum are smooth (or lack any differential structure, as in the vertex-set).In SMT, one applies standard Morse theory on each stratum, and then combines the partial results appropriately."}, {"x": 156, "text": "The set of points with zero gradient (computed on each stratum), which SMT assumes to be isolated, are called the critical points of the stratified Morse function.In addition, every point in the vertex set is considered critical as well.One major difference between SMT and the smooth theory is that some critical points do not actually change the topology of the level sets.This is why considering all grid vertices as critical does not introduce any practical problems: most grid vertices of typical scalar fields will be virtual critical points, i.e., points which do not change the Euler characteristic of the surface.Carr and Snoeyink use a related concept (which they call potential critical points) in their state-machine description of the topology of interpolants <17>."}, {"x": 157, "text": "Let M be the stratified grid described above.It can be shown that if p is a point in a d-dimensional stratum of M, it is always possible to find a (3d)-dimensional submanifold of M (which might straddle many strata) that meets transversely the stratum containing p, and whose intersection consists of only p (one way to think of this (3  d)-manifold is as a topological orthogonal complement).In this context, we can define a small neighborhood T(p) in the strata containing p and the lower tangential link TL(p) as the set of points in the boundary of T(p) with scalar values less than that in p (see Figure 3.5).Similarly, we can define the upper tangential link TL+(p) as the set of points in the boundary of T(p) with scalar value higher than that at p.Lower normal NL(p) and upper normal NL+(p) links are analogous notions, but the lower and upper links are taken to be subsets of N(p), itself a subset of the (3  d)-dimensional submanifold transverse to the stratum of p going through p.The definitions above are needed in order to define the lower stratified link and upper stratified link, as follows: given T(p), TL(p), N(p) and NL(p), the lower stratified Morse link (and similarly for upper stratified link) is given by"}, {"x": 158, "text": "L(p) = (T(p)  NL(p))  (N(p)  TL(p)).(3.2)"}, {"x": 159, "text": "These definitions allow us to classify critical points even in the nonsmooth scenario.They let us compute topological changes with the same methodology used in the smooth case.In other words, when a scalar value  crosses a critical value p in a critical point p, the topological change in the isosurface is characterized by removing L(p) and attaching L+(p), affecting the Euler characteristic as defined in Equation (3.1)."}, {"x": 162, "text": "In some cases, the Euler characteristic of the lower and upper link might be equal.Then, (L(p)) = (L+(p)), and (p) = 0.These cases correspond to the virtual critical points mentioned above.Critical points in the interior of cubic cells are handled by the smooth theory, since in that case the normal Morse data are 0-dimensional.This implies that the link will be an empty set with Euler characteristic zero.So, by Equation (3.4), (L) = (TL).Because the restriction of the scalar field to a grid edge is a linear function, no critical point can appear there.As a result, the new cases are critical points occurring at vertices or in the interior of faces of the grid.For a critical point p in a vertex, stratification can be carried out recursively, using the edges of the cubes meeting in p as tangential and normal submanifolds.Denoting by nl1,nl2,nl3 the number of vertices adjacent to p with scalar value less than that of p in each Cartesian coordinate direction, Equation (3.4) gives:"}, {"x": 163, "text": "(L+(p)) can be computed similarly, but considering the number of neighbors of p in each Cartesian direction with scalars higher than that of p."}, {"x": 166, "text": "A similar analysis can be be carried out for every type of critical point, regardless of whether the point belongs to the interior of a grid cell (and so would yield equally well to a smooth Morse theory analysis), an interior face, a boundary face, or a vertex of any type.The Euler characteristic  of any isosurface with isovalue  is simply given as: where C is the set of critical points with critical values less than ."}, {"x": 167, "text": "It is worth mentioning once again that, to the best of our knowledge, no other work has presented a scheme which provides such a simple mechanism for computing the Euler characteristic of level sets of piecewise-smooth trilinear functions.Compare, for example, the case analyses and state machines performed separately by Nielson <125>, by Carr and Snoeyink <17>, and by Carr and Max <15>.In contrast, we can recover an (admittedly weaker) topological invariant by a much simpler argument.In addition, this argument already generalizes (trivially because of the stratification argument) to arbitrary dimensions, unlike the other arguments in the literature."}, {"x": 171, "text": "As previously mentioned, MC-like algorithms which use disambiguation techniques are expected to generate PL manifold isosurfaces no matter how complex the function sampled in the vertices of the regular grid.In order to stress the consistency test, we generate a random scalar field with values in the interval <1,1> and extract the isosurface with isovalue  = 0 (which is all but guaranteed not to be a critical value) using a given isosurfacing technique, subjecting the resulting triangle mesh to the consistency verification.This process is repeated a large number of times, and if the implementation fails to produce PL manifolds for all cases, then the counterexample provides a documented starting point for debugging.If it passes the tests, we consider the implementation verified."}, {"x": 172, "text": "3.4.2 Verification Using Stratified Morse Theory"}, {"x": 173, "text": "We can use the formulation described in Section 3.3.2 to verify isosurfacing programs which promise to match the topology of the trilinear interpolant.The SMT-based verifi- cation procedure is summarized in Algorithm 3.The algorithm has four main steps.A random scalar field with node values in the interval <1, 1> is initially created.Representing the trilinear interpolation in a grid cell by f(x, y, z) = axyz+bxy+cxz+dyz+ex+fy+gz+h,"}, {"x": 175, "text": "Algorithm 4 shows the verification pipeline using the MI algorithm, and Figure 3.6 depicts the refinement process.Once again a random scalar field, with potentially many ambiguous cubes, is initially generated in the vertices of a grid G.The algorithm illustrated in Algorithm 4 is applied to refine G so as to generate a new grid G  which does not have ambiguous cells.If the maximum number of refinement is reached and ambiguous cells still remain, then the process is restarted from scratch.Notice that cube subdivision does not need to be uniform.For instance, each cube may be refined using a randomly placed new node point or using tis critical points, and the result of the verification process still holds.This is because Theorem 3.3.1 only requires ci to be unambiguous.For simplicity, in this work, we refine G uniformly doubling the grid resolution in each dimension."}, {"x": 176, "text": "Scalars are assigned to the new vertices of G  (the ones not in G) by trilinearly in- terpolating from scalars in G, thus ensuring that G and G  have exactly the same scalar field <125>.As all cubic cells in G  are unambiguous, Theorem 3.3.1 guarantees the topology of the digital surface O obtained from G  is equivalent to that of t(x) = .Algorithm InvariantFromDS computes topological invariants of O using the scheme discussed in Section 3.3.1.In this context, InvariantFromDS is the algorithm illustrated in Algo-"}, {"x": 177, "text": "Algorithm 4 Overview of the method of manufactured solutions (MMS) using digital topology.The method either fails to match the expected topology, in which case G is provided as a counterexample, or succeeds otherwise."}, {"x": 180, "text": "VTKMC <155> is the Visualization Toolkit (VTK) implementation of the Marching Cubes algorithm with the implicit disambiguation scheme proposed by Montani et al.<117>.Essentially, it separates positive vertices when a face saddle appears and assumes no tunnels exist inside a cube.The proposed scheme is topologically consistent, but it does not reproduce the topology of the trilinear interpolant."}, {"x": 182, "text": "Afront <153> is an advancing-front method for isosurface extraction, remeshing, and triangulation of point sets.It works by advancing triangles over an implicit surface.A sizing function that takes curvature into account is used to adapt the triangle mesh to features of the surface.Afront uses cubic spline reconstruction kernels to construct the scalar field from a regular grid.The algorithm produces high-quality triangle meshes with bounded Hausdorff error.As occurred with the VTK and Macet implementations, Afront produces consistent surfaces but, as expected, the results do not match the trilinear interpolant."}, {"x": 183, "text": "Matlab  <103> is a high-level language for building codes that requires intensive nu- merical computation.It has a number of features and among them an isosurface extraction routine for volume data visualization.Unfortunately, Matlab documentation does not offer information on the particularities of the implemented isosurface extraction technique (e.g., Marching Cubes, Delaunay-based, etc; consistent or correct)."}, {"x": 184, "text": "SnapMC <141> is a Marching Cubes variant which produces high-quality triangle meshes from regular grids.The central idea is to extend the original lookup table to account for cases where the isosurface passes exactly through the grid nodes.Specifically, a user-controlled parameter dictates maximum distance for snapping the isosurface into the grid node.The authors report an improvement in the minimum triangle angle when compared to previous techniques."}, {"x": 185, "text": "MC33 was introduced by Chernyaev <21> to solve ambiguities in the original MC.It extends the Marching Cubes table from 15 to 33 cases to account for ambiguous cases and to reproduce the topology of the trilinear interpolant inside each cube.The original table was later modified to remove two redundant cases, which leads to 31 unique configurations.Chernyaevs MC solves face ambiguity using Nielsen and Hamanns <126> asymptotic decider and internal ambiguity by evaluating the bilinear function over a plane parallel to a face.Additional points may be inserted to reproduce some configuration requiring subvoxel accuracy.We use the implementation provided by Lewiner et al.<94>."}, {"x": 186, "text": "DelIso <32> is a Delaunay-based approach for isosurface extraction.It uses the inter- section of the 3D Voronoi diagram and the desired surface to define a restricted Delaunay triangulation.Moreover, it builds the restricted Delaunay triangulation without having to compute the whole 3D Voronoi structure.DelIso has theoretical guarantees of homeomor- phism and mesh quality."}, {"x": 187, "text": "MCFlow is a proof-of-concept implementation of the algorithm described in Schei- degger et al.<151>.It works by successive cube subdivision until it has a simple edge flow.A cube has a simple edge flow if it has only one minima and one maxima.A vertex s  ci is a minimum if all vertices sj  ci connected to it has t(sj) > t(si).Similarly, a vertex is a maximum if t(sj) < t(si) for every neighbor vertex j. This property guarantees that the Marching Cubes method will generate a triangle mesh homeomorphic to the isosurface.After subdivision, the surfaces must be attached back together.The final mesh is topologically correct with respect to the trilinear interpolant."}, {"x": 189, "text": "3.5.1 Topology Consistency"}, {"x": 190, "text": "All implementations were subject to the consistency test (Section 3.4.1), resulting in the outputs reported in the first column of Table 3.1.We observed mismatches for DelIso, SnapMC (with nonzero snap value), and Matlab implementations.Now, we detail these results."}, {"x": 192, "text": "We analyzed 50 cases where DelIsos output mismatched the ground truth produced by MMS, and we found that: 1) 28 cases had incorrect hole(s) in the mesh, 2) 15 cases had missing triangle(s), and 3) 7 cases had duplicated vertices.These cases are illustrated in Figure 3.7.The first problem is possibly due to the nonsmooth nature of the piecewise trilinear interpolant, since in all 28 cases, the holes appeared in the faces of the cubic grid.It is important to recall that DelIso is designed to reproduce the topology of the trilinear interpolant inside each grid cube, but the underlying algorithm requires the isosurface to be C2 continuous everywhere, which does not hold for the piecewise trilinear isosurface.In practice, real-world datasets such as medical images may induce smoother piecewise trilinear fields when compared to the extreme stressing from the random field, which should reduce the incidence of such cases.Missing triangles, however, occurred in the interior of cubic cells where the trilinear surface is smooth.Those problems deserve a deeper analysis, as one cannot say beforehand if the mismatches are caused by problems in the code or numerical instability associated with the initial sampling, ray-surface intersection, and the 3D Delaunay triangulation construction."}, {"x": 196, "text": "Matlab documentation does not specify the properties of the implemented isosurface extraction technique.Consequently, it becomes hard to justify the results for the high number of mismatches we see in Table 3.1.For instance, Figure 3.8(b) shows an example of a nonmanifold mesh extracted using Matlab.In that figure, the two highlighted edges have more than two faces connected to them and the faces between these edges are coplanar.Since we do not have enough information to explain this behavior, this might be the actual expected behavior or an unexpected side effect.An advantage of our tests is the record of the observed behavior of mesh topologies generated by Matlab."}, {"x": 198, "text": "In our first tests, Macet failed in all consistency tests for a 555 grid.An inspection in the code revealed that the layer of cells in the boundary of the grid has not been traversed.Once that bug was fixed, Macet started to produce PL manifold meshes and was successful in the consistency test, as shown in Table 3.1."}, {"x": 199, "text": "3.5.6 Topology Correctness"}, {"x": 200, "text": "The verification tests described in Section 3.4.2 and 3.4.3 were applied to all algorithms, although only MC33, DelIso, and MCFlow were expected to generate meshes with the same topology of the trilinear interpolant.Our tests consisted of one thousand random fields generated in a rectilinear 5  5  5 grid G.The verification test using Digital Surfaces demanded a compact, orientable, 2-manifold without boundary, so we set scalars to one for grid vertices in the boundary of the grid.As stratified Morse theory supports surfaces with boundary, no special treatment was employed in the boundary of G.We decided to run these tests using all algorithms for completeness and also for testing the tightness of the theory, which says that if the algorithms do not preserve the topology of the trilinear interpolant, a mismatch should occur.Interestingly, with this test, we were able to find another code mistake in Macet that prevented it from terminating safely when the SMT procedure was applied.For all nontopology-preserving algorithms, there was a high number of mismatches as expected."}, {"x": 201, "text": "One might think that the algorithms described in Algorithms 3 and 4 do not cover all possible topology configurations because some scalar fields are eventually discarded (lines 7 and 6, respectively).This could happen due to the presence of ambiguous cells after refining the input grid to the maximum tolerance (digital topology test) or critical points falling too close to edges/faces of the cubic cells (SMT test).However, we can ensure that all possible configurations for the trilinear interpolation were considered in the tests.Figure 3.9 shows the incidence of each possible configuration (including all ambiguous cases) for the trilinear interpolation in the generated random fields.Dark bars correspond to the number of times a specific case happens in the random field, and the light bars show how many of those cases are accepted by our verification methodology, that is, the random field is not discarded.Notice that no significant differences can be observed, implying that our rejection-sampling method does not bias the case frequencies."}, {"x": 203, "text": "For MCFlow, we applied the verification framework systematically during its imple- mentation/development.Obviously, many bugs were uncovered and fixed over the course of its development.Since we are randomizing the piecewise trilinear field, we are likely to cover all possible Marching Cubes entries and also different cube combinations.As verification tests have been applied since the very beginning, all detectable bugs were removed, resulting in no mismatches.The downside of MCFlow, though, is that typical bad quality triangles appearing in Marching Cubes become even worse in MCFlow, because cubes of different sizes are glued together.MCFlow geometrical convergence is presented in the supplementary material <151>."}, {"x": 205, "text": "Whenever one uses MMS, one very important question is that of the quality of the manufactured solutions, since it reflects directly on the quality of the verification process.Using random solutions, for which we compute the necessary invariants, naturally seems to yield good results.However, our random solutions will almost always have nonidentical values.This raises the issue of detecting and handling degenerate inputs, such as the ones arising from quantization.We note that most implementations use techniques such as Simulation of Simplicity <37> (for example, by arbitrarily breaking ties using node ordering) to effectively keep the facade of nondegeneracy.However, we note that developing man- ufactured solutions specifically to stress degeneracies is desirable when using verification tools during development.We decided against this since different implementations might employ different strategies to handle degeneracies and our goal was to keep the presentation sufficiently uniform."}, {"x": 206, "text": "3.6.2 Topology and Geometry"}, {"x": 209, "text": "3.6.3 SMT vs.DT"}, {"x": 210, "text": "The verification approach using digital surfaces generates detailed information about the expected topology because it provides 0, 1, and 2.However, verifying isosurfaces with boundaries would require additional theoretical results, as the theory supporting our verification algorithm is only valid for surfaces without boundary.In contrast, the verification methodology using stratified Morse theory can handle surfaces with boundary.However, SMT only provides information about the Euler characteristic, making it harder to determine when the topological verification process fails.Another issue with SMT is that if a code incorrectly introduces topological features so as to preserve , then no failure will be detected.For example, suppose the surface to be reconstructed is a torus, but the code produces a torus plus three triangles, each one sharing two vertices with the other triangles but not an edge.In this case, torus plus three cycling triangles also has  = 0, exactly the Euler characteristic of the single torus.In that case, notice that the digital surface-based test would be able to detect the spurious three triangles by comparing 0.Despite being less sensitive in theory, SMT-based verification revealed similar problems as the digital topology tests have.We believe this effectiveness comes in part from the randomized nature of our tests."}, {"x": 211, "text": "3.6.4 Implementation of SMT and DT"}, {"x": 213, "text": "First, note that the implementation of either verifier is simpler than the isosurfacing techniques under scrutiny.This reduces the chances of a bug impacting the original verification.In addition, we can use the same strategy to check if the verification tools are implemented correctly.For SMT, one may compute  for an isovalue that is greater than any other in the grid.In such case, the verification tool should result in  = 0.For DT, we can use the fact that Majority Interpolation always produces a 2-manifold.Fortunately, this test reduces to check for two invalid cube configurations, as described by Stelldinger et al.<164>.Obviously, there might remain bugs in the verification code.As we have stated before, a mismatch between the expected invariants and the computed ones indicates a problem somewhere in the pipeline; our experiments are empirical evidence of the techniques effectiveness in detecting implementation problems."}, {"x": 214, "text": "Another concern is the performance of the verification tools.In our experiments, the invariant computation via SMT and DS is faster than any isosurface extraction presented in this work, for most of the random grids.In some scenarios, DS might experience a slowdown because it refines the grid in order to eliminate ambiguous cubes (the maximum number of refinement is set to 4).Thus, both SMT and DS (after grid refinement) need to perform a constant number of operations for each grid cube to determine the digital surface (DS) or critical points (SMT).In this particular context, we highlight the recent developments on certifying algorithms, which produce both the output and an efficiently checkable certificate of correctness <107>."}, {"x": 216, "text": "Contour trees <18> are powerful structures to describe the evolution of level-sets of simply connected domains.It normally assumes a simplicial complex as input, but there are extensions to handle regular grids <130>.Contour trees naturally provide 0, and they can be extended to report 1 and 2.Hence, for any isovalue, we have information about all Betti numbers, even for surfaces with boundaries.This fact renders contour trees a good candidate for verification purposes.In fact, if an implementation is available, we encourage its use so as to increase confidence in the algorithms behavior.However, the implementation of a contour tree is more complicated than the techniques presented here.For regular-grids, a divide-and-conquer approach can be used along with oracles representing the split and join trees in the deepest level of the recursion, which is nontrivial.Also, implementing the merging of the two trees to obtain the final contour tree is still involving and error- prone.Our approach, on the other hand, is based on regular grid refinement and voxel selection for the DT method and critical point computation and classification for the SMT method.There are other tools, including contour trees, that could be used to assess topology correctness of isosurface extraction algorithms, and an interesting experiment would be to compare the number of mismatches found by each of these tools.Nevertheless, in this work, we have focused on the approaches using SMT and DT because of their simplicity and effectiveness in finding code mistakes in publicly available implementations.We believe that the simpler methodologies we have presented here are more likely to be adopted during development of visualization isosurfacing tools."}, {"x": 217, "text": "3.6.6 Topology of the Underlying Object"}, {"x": 218, "text": "In this work, we are interested in how to effectively verify topological properties of codes which employ trilinear interpolation.In particular, this means that our verification tools will work for implementations other than marching methods (for example, DelIso is based on Delaunay refinement).Nevertheless, in practice, the original scalar field will not be trilinear, and algorithms which assume a trilinearly interpolated scalar field might not provide any topological guarantee regarding the reconstructed object.Consider, for example, a piecewise linear curve  built by walking through diagonals of adjacent cubes ci  G and define the distance field d(x) = min<||xx||such that x  >.The isosurface d(x) =  for any  > 0 is a single tube around .However, none of the implementations tested could successfully reproduce the tubular structure for all  > 0.This is not particularly surprising, since the trilinear interpolation from samples of d is quite different from the d. Figure 3.11 shows a typical output produced by VTK Marching Cubes for the distance field d = .Notice, however, that this is not only an issue of sampling rate because if the tube keeps going through the diagonals of cubic cells, VTK will not be able reproduce d =  yet.Also recall that some structures cannot even be reproduced by trilinear interpolants, as when  crosses diagonals of two parallel faces of a cubic cell, as described in <21, 130>.The aspects above are not errors in the codes but reflect software design choices that should be clearly expressed to users of those visualization techniques."}, {"x": 222, "text": "In this chapter, we extended the framework presented in the previous chapter by in- cluding topology into the verification cycle.We used machinery from digital topology and stratified Morse theory to derive two verification tools that are simple and yet capable of finding unexpected behavior and coding mistakes.We argue that researchers and de- velopers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.Topological properties are as important as geometric ones, and they deserve the same amount of attention.It is telling that the only algorithm that passed all verification tests proposed here is the one that used the verification procedures during its development.We believe this happened because topological properties are particularly subtle and require an unusually large amount of care."}, {"x": 223, "text": "CHAPTER 4 PRACTICAL CONSIDERATIONS ON THE TOPOLOGICAL CORRECTNESS OF MARCHING CUBES 33"}, {"x": 224, "text": "Isosurface extraction techniques can be divided into two classes according to their topo- logical guarantees, namely, consistency or correctness.Topologically consistent techniques produce surfaces that are piecewise-linear (PL) manifolds (i.e., crack-free surfaces), except at the boundary of the domain.Topologically correct techniques produce a PL-manifold homeomorphic to the surface induced by a given interpolant, such as the trilinear inter- polant.Although there are many topologically consistent MC-based techniques, only a handful are topologically correct.Marching Cubes 33 is one of the first MC-based algorithms that aim to preserve the topology of the trilinear interpolant."}, {"x": 225, "text": "Topological correctness increases the complexity of isosurface extraction algorithms.The many isosurface configurations possible for a given interpolant in a cubic grid makes both the algorithm and its implementation a challenging task.As algorithms and implementations become more complex, issues may be overlooked and remain hidden in the multitude of (pseudo-) lines of code.Throughout years of research, it has been shown that some supposedly topologically correct techniques, including MC33, have issues that prevent correctness <45, 98, 124>.In particular, the work of Etiene et al.<45> shows that the MC33 implementation by Lewiner et al.<93, 94> fails to produce topologically correct isosurfaces.Alas, the authors do not provide an explanation for the problem source, let alone fix the problem.They only provide cases that are mishandled by MC33 and a conjecture regarding the root of one of the observed flaws.As we studied the MC33 implementation, we realized that the source of the problem was not merely implementation bugs but the core ideas behind the implemented algorithm.In this work, we address issues with Chernyaevs original algorithm, its extension, and its implementation.Our work closes an existing gap in the topological correctness of Marching Cubes 33."}, {"x": 226, "text": "The subtleties involved in the correctness of isosurface extraction techniques are some- times difficult to grasp in the ordinary paper medium.Both the geometry and topology inside grid voxels are often complex and challenging to understand, study and replicate (e.g., see Figures 9 and 10 in <125>).As an attempt to bridge this gap, we build on recent efforts towards executable papers <82, 172>.Executable papers extend the traditional paper/digital counterpart by including tools that allow readers to interact, explore, and verify experiments more easily.In this chapter, we use executable papers to increase the reproducibility of our results.Our contributions, which have a practical nature, are the following:"}, {"x": 227, "text": "We explain and address three algorithmic issues and one nontrivial implementation issue with Marching Cubes 33.In particular, we solve an issue with the core MC33 disambiguation procedure that, as far as we know, has not been addressed elsewhere.Hence, we close an existing gap in the MC33 literature."}, {"x": 231, "text": "This work is organized as follows.Section 4.2 reviews key aspects related to the Marching Cubes 33 algorithm.Section 4.3 explains how experiments that uncovered problems in both MC33 algorithm and implementation were conducted.The details of the problems found are shown in Section 4.4 and the solutions are presented in Section 4.5.Section 4.6 shows the results of applying algorithm with different topological guarantees to real-world datasets."}, {"x": 233, "text": "Soon after the publication of the MC algorithm, the quest for a topologically correct isosurface extraction technique began.A number of approaches were proposed for dealing with cracks, face ambiguity, and, lastly, interior ambiguity.Du rst <35> was the first to point out that some MC cases allow multiple triangulations.A consequence of this is that MC does not always generate topologically consistent surfaces.This problem arises due to the ambiguity problem; the Asymptotic Decider <126> provides a simple and elegant solution to face ambiguity."}, {"x": 234, "text": "The ambiguity problem also occurs in the interior of a voxel.Natarajan <122> was the first to address this problem by adding four new cases to the standard MC triangulation table (subcases of cases 3, 4, 6, and 7).To find the correct subcases, the author proposed a disambiguation procedure based on both face and interior critical points.Nevertheless, the method misses the possibility of two interior critical points in case 7; consequently, the proposed algorithm may generate a surface with the incorrect topology <15, 124>."}, {"x": 235, "text": "Using a different approach, Chernyaev <21> extended the original MC table to 33 cases  hence MC33; this extension included all the subcases for each ambiguous case.He used the Asymptotic Decider and a new interior ambiguity test to discriminate among subcases.Lewiner et al.<94> provided a practical open-source implementation of the Chernyaev algorithm.It is worth noting that some of the configurations shown in Chernyaevs work <21> may have been inspired by personal communication with Nielson <125>.Matveyev <105> introduced an isosurface technique that is also based on an extended table and used the intersections of isosurfaces with cube diagonals to determine the correct case."}, {"x": 236, "text": "Lopes and Brodlie <98> extended the tests proposed by Natarajan.The goals of the work are threefold: i) extract topologically correct isosurfaces; ii) produce geometrically accurate isosurface; iii) allow continuity with respect to changes in threshold and data.Nevertheless, as in Natarajans work, the method missed the possibility of two interior critical points in case 7 <98>.Cignoni et al.<23> also used the test proposed by Natarajan to reconstruct topologically correct isosurfaces.The work of Theisel <168> uses B ezier patches to build G1 continuous isosurfaces that are topologically correct.Nielson <125> lists all possible cases of a trilinear interpolant inside a cubic grid and builds a topologically correct MC using a three stage algorithm for surface polygonization."}, {"x": 237, "text": "The past two decades have also produced a number of isosurface techniques that are not MC-based.Dual Contouring <73> (DC) is a robust, crack-free, isosurface extraction technique that works on the dual grid.Several improvements over Dual Contouring have been proposed: Schaefer et al.<149> address the issue of nonmanifold surfaces generated by DC; Varadhan et al.<182> combine a signed distance field with DC to reconstruct details such as thin features; and Zhang et al.<193> use DC for topology-preserving simplification of isosurfaces.Note that none of these techniques are intended to preserve the topology of the trilinear interpolant.Dey and Levine <32> presented an algorithm that computes a Delaunay triangulation based on the intersection between the isosurface and the 3D Voronoi diagram.Another paradigm for isosurface extraction is the advancing front method.Advancing front algorithms build a triangulated surface by progressively adding triangles to an implicit surface <59>, possibly creating several fronts that are simultaneously advanced one triangle at a time.A number of extensions have been proposed for advancing front techniques <153, 154, 159>."}, {"x": 238, "text": "In the following sections, we focus on MC33.Note that, although many of the algorithms presented previously are topologically consistent, only a handful of them are topologically correct <21, 32>.Also, the implementation of a topologically correct isosurface extraction algorithm is nontrivial.Hence, once the algorithm is implemented, topological guarantees, both consistency and correctness, may be lost because of algorithm or implementation issues, as shown in the work of Etiene et al.<45>.Although it has been ten years since the publication of MC33, we believe it is important to correct a mistake in the algorithm that has gone unnoticed since Chernyaev published it almost 20 years ago.In this work, we aim to close an existing gap in the MC33 literature.Furthermore, we aim not only to provide a correct algorithm but verify that our modified implementation is faithful to the correct algorithm.We explain the issues and propose solutions for both algorithm and implementation.We note that MC33 may refer to either the Marching Cubes 33 algorithm presented in Chernyaevs work <21> or its implementation, as in Lewiner et al.<94> depending on the context."}, {"x": 240, "text": "In this section, we present the notation that will be used throughout this chapter.We also briefly review the main concepts behind Chernyaevs algorithm and the implementation of Lewiner et al.. Let G be a rectilinear grid with scalar values associated with each vertex xj  G. Let g : R3  R be a piecewise-trilinear interpolation function defined on G.Given an isovalue , the isosurface S is defined as the set of points for which g(x) = .For each voxel vi  G, and x  vi, g(x) = gi(x) where gi is the trilinear interpolant inside the cubic cell vi."}, {"x": 241, "text": "The output of MC-based algorithms is a piecewise-linear mesh M, and we say that an algorithm and its implementation are topologically correct if M is homeomorphic to S. Without loss of generality, we assume that  = 0, and thus S = S0 = S.We say that a point x is positive (negative) if g(x) > 0 (g(x) < 0)."}, {"x": 244, "text": "The two pillars of Marching Cubes 33s topological correctness are Nielson and Hamanns Asymptotic Decider and Chernyaevs interior ambiguities test; together these solve the face ambiguity and interior ambiguity problems in the Marching Cubes 33 algorithm.A face ambiguity occurs when face vertices have alternating signs.That is, one face diagonal is positive (both vertices are positive) and the other is negative (both vertices are negative).In this case, the signs of the face vertices are insufficient to determine the correct way to triangulate the isosurface.Similarly, an interior ambiguity occurs when the signs of the cube vertices are insufficient to determine the correct surface triangulation, i.e., when multiple triangulations are possible for the same cube configuration (see Figure 4.1)."}, {"x": 245, "text": "The idea behind the Asymptotic Decider is to verify the face saddle sign and compare it to the sign on the face vertices.A positive saddle means that the positive face vertices are connected; consequently, the positive face vertices are separated if the face saddle point is negative (see Figure 4.2).To compute the face saddle sign, the saddle point position xc must be computed <21>: where A, B, C, and D are the scalar values at the face vertices (see Figure 4.2).The sign of xc can easily be checked by replacing Equation (4.1) into the bilinear interpolant:"}, {"x": 247, "text": "Due to the interior ambiguity, the Asymptotic Decider alone cannot solve the topological correctness problem.Chernyaev uses the idea behind the Asymptotic Decider to solve the interior ambiguity problem.The proposed test uses a sweeping cutting-plane to evaluate the behavior of the trilinear interpolant inside the cube."}, {"x": 248, "text": "Given a cube with an ambiguous configuration, define the scalar values at the base and top planes as A0, B0, C0, D0, and A1, B1, C1, D1, respectively (see Figure 4.2).Let A0 and C1, the vertices to be tested, be positive.Observe that, although A0 and C1 belong to opposite cube faces, they can be connected through the cube interior.In other words, there may exist a path from A0 to C1 passing through the voxel interior for which all points belonging to that path are positive.To determine whether A0 and C1 are connected, Chernyaev begins by observing that the saddle points at the top and base cube faces are negative, i.e., Equation (4.2) is negative at the bottom and top faces.Since the denominator is positive, it follows that:"}, {"x": 250, "text": "This can be achieved by solving a second order equation in t. Replacing Xt = X0 + (X1  X0)t, X  <A, B, C, D> and t  <0, 1> in Equation (4.5), one obtains a second order equation in t:"}, {"x": 252, "text": "where a, b, and c are functions of A,B,C, and D (see Appendix A).Chernyaev concludes that positive vertices A0 and C1 are connected through the cube interior if: of the test proposed by Chernyaev, but condition (i) is not used, and condition (ii) is always true because e is an edge intersected by the isosurface; consequently, talt  (0, 1)."}, {"x": 253, "text": "Section 4.4 explains why the algorithm proposed by Chernyaev and its modified version proposed by Lewiner et al.may fail to extract surfaces that are topologically correct.In the following section, we present the tools we use to detect, debug, and reproduce the issues found in the MC33 algorithm and its implementation.The full Marching Cubes table can be found in the works of Chernyaev <21> and Lewiner et al.<94>."}, {"x": 255, "text": "We begin by investigating the source of topological problems in the MC33 implemen- tation <45>.The topological issues described were obtained by systematically stress-testing the implementation over many topological configurations using the verification framework proposed in Etiene et al.<45>.These authors algorithm can be summarized as follows.(I) A random scalar field G is built by uniformly sampling scalar values in the range <1, 1> for each xj  G.(II) The expected topological invariants are obtained directly from S, i.e., without extracting the isosurface of interest.The topological invariants used are the Euler characteristic (S) and the Betti numbers k(S).(III) The MC33 implementation is used to extract a piecewise linear mesh M, and its invariants (M) and k(M) are computed.(IV) Lastly, the pairs of topological invariants <(S), (M)> and <k(S),k(M)> are compared.A mismatch indicates that a problem has occurred.Nevertheless, as the authors note, a match between invariants does not imply a bug-free code <45>.The verification process does not prove the absence of bugs but only increases ones confidence in its correctness.In this chapter, we exploit the fact that when the expected and obtained surfaces are not homeomorphic, a counterexample is given in the form of a scalar field G and a mesh M. We use this information to find and correct errors in MC33."}, {"x": 257, "text": "As investigators in a mature field within the scientific visualization community, isosurface extraction researchers have developed ways to help other researchers and practitioners repro- duce their results.Published journal articles offer a first approximation of reproducibility.Nevertheless, many details regarding implementation, source code, input data, and other types of information are often omitted.Many, but not all, published techniques make source code and input data freely available, and some are part of widely used visualization packages such as VTK <155>.This practice greatly increases the degree of reproducibility of the work.We use CrowdLabs <172> and Vistrails <49, 158> as a platform to achieve this goal.To explore some of the results shown in this chapter, the reader may click on individual figure captions and interact with the results via web browser.We have selected cases in which MC33 fails and have provided the respective correct results.In addition, to allow the reader to explore and study the results presented here, he or she can also download the scalar fields and respective topological invariants  and  used for stress testing MC33.We also provide 10000 Marching Cubes cases grids and randomly generated 5x5x5 grids <28>.This dataset can be used to test any topologically correct isosurface extraction technique."}, {"x": 268, "text": "The source of the problem can be tracked to Equations (4.3) and (4.4) and the as- sumption that the denominator of f(xc) (Equation (4.2)) is positive.These assumptions can easily be verified to be true for case 4, shown in Figure 4.2.However, for case 13, the saddle points at the top and bottom planes have opposite signs, which contradicts Equations (4.3) and (4.4).In addition, the denominator A + C  B  D of f (xc ) changes its sign at the asymptote of f(xc), contrary to the assumption that it is always positive.The consequence of incorrectly tracking sign changes is that the three rules used for resolving internal ambiguity will fail for some scalar fields.As an example, Figure 4.5 shows a case 13.5.2 that will mistakenly be taken as case 13.5.1 because a > 0 characterizes multiples surface sheets instead of a tunnel (see also Appendix A).The problem is not only related to the misclassification of case 13.5.2 as 13.5.1.We have also devised examples in which case 13.5.1 is mistakenly taken as case 13.5.2 because the three criteria shown in Section 4.2 hold.Thus, Chernyaevs interior ambiguity test does not always yield topologically correct isosurfaces."}, {"x": 287, "text": "We solve this problem by proposing a new interior test that uses the fact that case 13.5.2 requires both roots t1 and t2 of f(xc(t)) and the associated saddle points to be inside the voxel.First, recall that xc(t) tracks the path of the face saddle inside the voxel as a function of height plane at height t, and f(xc(t)) tracks the value (and thus the sign) of that saddle.Both functions are illustrated in the rightmost image in Figure 4.4, in which the black hyperbolic curves represent the path of xc(t) and the color of the circles represents the sign of the face saddle at a given point (white and black circles are points with negative and positive values, respectively).For case 13.5.2, the path traced by the curve xc(t) must intersect the isosurface tunnel twice, once at each of the roots t1 and t2 of f(xc(t)).This implies that both saddle points xc(t1) and xc(t2) must lie inside the voxel.This is not the case for 13.5.1 because the face saddle can cross the middle sheet at most once.Therefore, it suffices to verify that both roots of f(xc(t)) and its saddle points are inside the voxel.Algorithm 6 illustrates our solution.Our algorithm is very simple, and does not require the computation of the critical points of the trilinear interpolant, or a detailed description of its behavior inside a voxel.Our algorithm uses the ideas proposed by Chernyaev in order to fix an algorithmic problem in his work.We have implemented and tested this solution on C-MC33 using over 10000 randomly generated instances of case 13.5."}, {"x": 294, "text": "Nonmanifold surfaces are created when two adjacent voxels that share an ambiguous face have tunnels in the voxel interior.By splitting both voxels at the critical point of that face, the face ambiguity is eliminated <15>.To simplify the algorithm, we split not only the voxels sharing the ambiguous face but all faces in the volume slice that contains that face (see Figure 4.10).Assuming an input of size nnn, each subdivision will add n2 voxels to the grid.Assuming that k subdivisions are required, kn2 voxels will be added.In practice k = O(1), and thus kn2 = O(1)O(n2) = O(n2).This implies that the asymptotic size of the dataset does not change.This subdivision adds the degree of freedom necessary to eliminate the problem, making this implementation of the Marching Cubes 33 topologically correct (see Figure 4.7)."}, {"x": 301, "text": "We now turn our attention to the practical impact of the topological correctness of the trilinear interpolant.For real-world datasets, the vast majority of Marching Cubes cases match the nonambiguous configurations, namely, 1, 2, 5, 8, and 9.This means that the standard Marching Cubes will match the topology generated by both MC33 and C-MC33."}, {"x": 302, "text": "Algorithm 7 Algorithm for case 10 <28>"}, {"x": 304, "text": "For the sake of completeness, in this section, we provide a qualitative analysis of these differences.The aneurysm dataset shown in Figure 4.11 provides an example of the dif- ferences.From left to right, Figure 4.11 shows meshes extracted with VTK Marching Cubes, MC33, and C-MC33.The VTK implementation is based on the work of Montani et al.<116> and does not have topological guarantees aside from consistency.These three implementations can be viewed as three distinct ways of extracting the mesh topology.Although only a handful of voxels differ among the implementations, for the aneurysm dataset, the consequence is that the (largest) main brain artery appears quite different in each interpretation.Because the dataset contains several thin features, subvoxel accuracy is required to connect the pieces of the blood vessels.As shown in the inset images in Figure 4.11, one voxel is sufficient to separate fairly large vessels."}, {"x": 305, "text": "VTK and MC33 generate more extra connected components (shown in purple) than does C-MC33.Figure 4.12 shows the difference in the number of connected components components extracted by VTK implementation of Marching Cubes and the number of connected components extracted by our C-MC33 implementation.The right plot shows the difference in the number of connected components but between the MC33 and C-MC33 implementations.Negative values indicate that the C-MC33 implementation generated more connected components.Clearly, VTK generates more components that C-MC33.MC33 generates more components for most of the isovalues.generated by VTK and C-MC33 (left) and by MC33 and C-MC33 (right) as a function of the isovalue for the aneurysm dataset.Clearly, VTK produces substantially more connected components than C-MC33 (up to 2400 more components).The differences between MC33 and C-MC33 are not as large, although they are sufficient to disconnect important artery segments.In this example, MC33 generates more connected components than C-MC33 for most isovalues.The aneurysm dataset shows that changes in the topology of some voxels can impact the final surface.In this particular example, it is reasonable to assume that the blood vessels form a single connected component and thus that the dataset contains as few connected components as possible.Using this criterion, C-MC33 shows the best performance for most isovalues.We emphasize that the importance of the differences in the number of connected components ought to be measured.For instance, although in general C-MC33 produced fewer connected components, for some isovalues the number of components extracted with C-MC33 was greater than the number extracted using MC33.As it turns out, this is due to the presence of pieces of small components disconnected from the main artery.However, because small isolated components do not disconnect large portions of the datasets, contrary to what is shown in Figure 4.11, MC33 and C-MC33 could be considered only slightly different.A thorough study of impact of the different approaches for extracting mesh topology is desirable but is beyond the scope of this work."}, {"x": 309, "text": "In this chapter, we discussed in detail three issues with the Marching Cubes 33 algorithm and one nontrivial issue with its implementation.We presented solutions for the issues raised and implement them into C-MC33, a topologically correct version of MC33.In addition, we made our results reproducible so that the reader can easily study, explore, and use the results presented here for his or her own purpose."}, {"x": 310, "text": "CHAPTER 5 VERIFYING DIRECT VOLUME RENDERING ALGORITHM"}, {"x": 312, "text": "To allow the verification of volume rendering algorithms, we start with an analysis of the volume rendering integral and the most common discretization of this continuous model  Riemman summation.This analysis gives us insight into the expected behavior of the observed algorithms, which is essential to perform verification <67>.In this sense, our main assumption, serving as a foundation for the proposed verification approach, is that discretization errors of the implementations under verification should behave as the errors introduced by the discretization of the volume rendering integral.Based on this, we can mathematically derive the expected behavior from the discretization of the volume rendering integral and verify existing implementations through convergence analysis by comparing their actual behavior to the expected behavior.Based on the results of this comparison, we can assess the correctness of the implementation under verification.To get further insights about deviations from the expected behavior, we present an investigation of the sensitivity of this method.We can demonstrate that our methodology is capable of increasing the confidence in volume rendering algorithms.To our knowledge, the proposed approach is the first step towards the verification of DVR algorithms.Thus, it can be seen as an important contribution towards a formal verification methodology of volume rendering techniques <143>.Our main contributions are:"}, {"x": 313, "text": "we derive the theoretical foundations necessary for verifying volume rendering with order of accuracy and convergence analysis.We analyze the volume rendering integral and its (common) discretization using Riemann summation to derive an algorithms expected behavior when being subject to parameter changes;"}, {"x": 315, "text": "we discuss the limitations of the proposed concepts by analyzing frequently occurring errors and by documenting those errors we could identify when applying the presented methodology to two widely used volume rendering frameworks, VTK <155> and Voreen <113> (see Figure 5.1)."}, {"x": 319, "text": "Among several aspects to consider in the correctness of volume rendering algorithms, one of the most important is the approximation of the volume rendering integral.The solution with linearly interpolated attributes is presented by Williams and Max <188>, with further discussions on its numerical stability by Williams et al.<189>.Interpolant approximations and errors <39, 114, 115, 128>, gradient computation <179> and opacity correction <90> are also the subject of analysis with regard to numerical accuracy.The idea of pre-integration enables high-quality, accurate and efficient algorithms using graphics hardware <42, 85, 145>.Similarly, VTK currently uses partial pre-integration, in particular for unstructured grids <119>.Note that although there has been work on high-accuracy volume rendering  to the best of our knowledge  none of these approaches attempted to evaluate the convergence rate of the standard discretization process of the volume rendering integral."}, {"x": 320, "text": "The use of a verification framework has only recently been discussed in scientific vi- sualization, despite the vast literature on verification in computer science.Globus and Uselton <55> first pointed out the need to verify not only visualization algorithms but also their implementations, and Kirby and Silva suggested a research program around verifica- tion <76>.The verification of isosurface algorithms was discussed by Etiene et al.<45, 46>, where a systematic evaluation identified and corrected problems in several implementations of isosurface extraction techniques.Zheng et al.<194> address CT reconstruction and interpolation errors in direct volume rendering algorithms using a verifiable framework based on projection errors.In contrast, our work focuses on the verification of the final image produced through direct volume rendering."}, {"x": 322, "text": "Before presenting our verification procedure, let us consider four of the techniques used for code verification in computational science <146>: expert judgment, a procedure in which a field expert determines if the output of an implementation is correct by evaluating the results; error quantification, which is the quantification of the discretization errors when compared to an analytical solution, a benchmark solution or some ground-truth; convergence analysis, a procedure in which one evaluates if the discretization errors converge to zero as a function of some parameter; and order of accuracy, a procedure where one evaluates if the discretization errors decrease according to the expected rate.In this list, the expert judgment is the least rigorous test, followed by error quantification and convergence analysis.Order of accuracy is widely recognized as the most rigorous code verification tool <3, 80, 143, 146>.In this chapter, we focus on the latter two methods, namely, convergence analysis and order of accuracy.Before we dive into these methods, let us first consider some of the limitation of the expert analysis and error quantification."}, {"x": 325, "text": "5.3 Discretization Errors"}, {"x": 331, "text": "When a solution F (x, y) for the VRI is known, the procedure is equivalent to the Method of Manufactured Solutions <3>.In the previous section, we have shown that the solution F can be written as: where I is the approximated image, r is the discretization parameter, and   R is a constant, multiplicative factor that is not a function of the dataset.An important assumption is that the HOT, or higher order terms, are small enough that they do not affect the convergence of order k  R; i.e., high order derivatives of F must have negligible impact in the asymptotic convergence of I <146>.This formulation implies that not all solutions F are suitable for verification purposes, only those for which the HOT are negligible.In addition, integration methods whose approximation errors cannot be written as shown cannot be compared by only evaluating k, as we propose next.The expected value of k for the cases of step size and pixel size refinement is k = 1, whereas we do not expect to see error reduction when examining grid size refinement.This implies that the pixel intensity converges to the true solution at a rate determined by k, and thus the error can be written as:"}, {"x": 332, "text": "One can evaluate the convergence for all pixels in the image using L2, L, or other norms.Henceforth, we adopt the L norm because it provides a rigorous and yet intuitive way of evaluating errors: it tells us that the maximum image error should decay at the same rate k. Mathematically, the error is then:"}, {"x": 333, "text": "We denote individual images (and the respective errors) by a subscript i. For each image Ii, we first calculate the supremum of the absolute difference supx,y (|F (x, y)  Ii(x, y)|).We then compute the observed convergence rate k by taking logarithms of both definitions of E and solving the resulting equations for log() and k in a least-squares sense:"}, {"x": 334, "text": "The system of equations has as many equations as the number of images and calculated errors.We note that the solution F (x, y) cannot always be computed analytically <106>.In the general case, we need an alternative method for determining the error."}, {"x": 336, "text": "In the case where the true solution is unknown a priori, using a numerical approximation in a high-precision context (i.e., a gold standard solution) to compute a reference image is a valid approach for verification <83>.The main disadvantage of this approach is that it might mask errors which appear in the reference image itself.Our slightly different approach requires neither an analytical solution nor a numerical approximation, but still retains a high sensitivity to errors.Suppose we want to verify the convergence of a sequence of images Ii with ri+1 = cri, where c  (0,1) is a constant factor.As we have seen in the previous section, the approximation written respectively as: for the solution F at resolution i and i + 1 can be"}, {"x": 338, "text": "Equation (5.49) shows us how to compute the convergence rate using only the images ob- tained from the VRI approximation and consequently avoiding any bias and/or limitations introduced by simple manufactured solutions or numerical approximations using reference images.We have generated sequences of images based on the refinements in the following section.The steps are shown in Algorithm 8."}, {"x": 340, "text": "We present the results of applying our verification framework to two mature and widely- used libraries, namely, VTK and Voreen.We stress that the goal here is first to show that our verification technique is very sensitive to changes that cause the output image to deviate from the correct solution; secondly, it is very easy to apply and thus can help developers and practitioners to gain confidence in their implementations."}, {"x": 342, "text": "In what follows, we show all the implementations that will be under scrutiny."}, {"x": 345, "text": "The VTK library provides several implementations of the well-known VRI techniques.In our tests, we included two modules from version 5.6.1: vtkVolumeRayCast (RCM) and vtkFixedPointVolumeRayCast (FP).The RCM module accepts as input scalar fields with 8- or 16-bit precision and internal computations are performed with single or double precision.FP accepts input datasets with up to 32 bits of precision but it uses 15-bit fixed-point arithmetic internally.Both techniques use back-to-front compositing.We have also modified the VTK source to capture 15 bit and 32 bit precision images for FP and RCM respectively."}, {"x": 347, "text": "As opposed to the tested modules in VTK, Voreen uses the graphics processing unit (GPU) and front-to-back compositing for its implementations.From the ray casting pro- cessors available within Voreen, we have chosen the SingleVolumeRaycaster, which is the standard processor in most Voreen workspaces.At the time of writing, version 2.6.1 is the latest, and the one we verified.We made minor modifications to the code so that floating point data of the format Nearly Raw Raster Data NRRD <74> could be imported and smaller step sizes could be used."}, {"x": 349, "text": "The grid lies in the domain <0,2>3 for VTK and <0,1>3 for Voreen.The scalar values at grid nodes are chosen from a uniform random distribution.The camera is centered at the xy plane and is aimed along the z axis.We did not include shading since that gives a more complex VRI.To verify shaded results, a different theoretical analysis is necessary.The images can be generated using both perspective and parallel projections.We only use postclassification, which simplifies the analysis.In addition, we assume an identity opacity transfer function (that is, the opacity is exactly equal to the sampled scalar).We do this because for every pair of scalar field and opacity transfer function, there is another scalar field (which admittedly need to be of finer resolution) that, when combined with the identity transfer function, represents the composition arbitrarily well.The function composition arising from volume classification can increase the high-frequency content of a volume <4>, and a full treatment of the impact of arbitrary transfer functions on the convergence of the integral remains a topic for future explorations.In addition, this assumption enabled much of the theoretical analysis that would not be possible otherwise, while still being stringent enough to uncover issues in the implementations."}, {"x": 353, "text": "For VTK, we also have the following setup: no auto adjustment of the step size d; single thread; interpolation type is set to linear.For Voreen, we enabled floating point buffers in the pipeline.The Voreen version under verification does not support parallel projection."}, {"x": 354, "text": "The errors are computed using the L norm and are given by the maximum distance between two images, defined as Ei = maxx,y |Ii(x, y)  Ii+1(x, y)|, where Ii(x, y) is the pixel with center in (x,y) of the image Ii rendered with the implementation under verification.If a solution F is available, Ei = maxx,y |Ii(x, y)  F (x, y)|."}, {"x": 357, "text": "The results of our verification procedure are summarized in Figure 5.6.We tested both VTK and Voreen and found unexpected behaviors.We emphasize that this does not immediately translate into a code mistake but only that a deeper investigation is needed."}, {"x": 366, "text": "(b) Pixel size refinement.Exp.: k = 1.Before: k = 0.37.After: k = 1.23"}, {"x": 368, "text": "Our first ray refinement tests did not result in linear convergence for Voreen (blue line in Figure 5.6(g)) due to the early ray termination (ERT).By simply adapting the ERT threshold, we were able to obtain the expected convergence for ray refinement (orange line in the Figure 5.6(g))."}, {"x": 369, "text": "As can be seen in the Figure 5.6(i), the blue curve indicates that increasing the resolution of the dataset decreases the error.We remind the reader that using our upsampled data, as described in Section 5.3.2, rendering the same scalar field represented by a different number of voxels should not affect the result.For Voreen, the unexpected behavior was caused by sampling at incorrect texture locations.More specifically, internally, Voreen assumed that the texture data are node centered when, in fact, OpenGL uses grid centered data."}, {"x": 370, "text": "In this case, both the volume and transfer function values were affected.In OpenGL, the texture coordinates of a texture of resolution Rm lie in the domain <0,1>m, where m is the texture dimension.Since the data values are grid centered, this means that the outermost data values are located at < 1 , 1  1 > with the settings used in Voreen.We will refer to 2R 2R the domain in which the data values lie as the data domain.For volume rendering, the integration of a ray should be done over the data domain, but for Voreen, the entry and exit points of the rays went outside of that domain which caused the unexpected behavior.To obtain the expected constant convergence, we apply the following transformation to the input texture coordinate p (see orange line in Figure 5.6(i)): does not require special treatment at the border of the domain; and due to its simplicity, it is easy to implement.We have contacted Voreen developers and the issue found was indeed identified as a bug.The proposed solution will be adopted into Voreens next release."}, {"x": 373, "text": "The convergence analysis presented in the previous section helped us to identify un- expected behavior in two stable and widely-used frameworks.Unexpected behavior is not indicative of an implementation bug but rather a warning about potential problems.For instance, some valid design decisions might affect the convergence results.Consider the widely used ERT acceleration technique.Depending on the thresholds involved, the convergence results might deviate from the ideal, and the expected curve is recovered once this feature is turned off.In this sense, the verification tool can help the developer to identify portions of the code that introduce numerical errors and quantify their effect on the final image.The issue with the RCM module is another example.The dataset size convergence curve was unexpectedly linear because of a small variation in the number of steps.While this particular issue might not be harmful, we were able to learn and reason about its consequences after the verification process was done.Furthermore, minor bugs and even design decisions cannot be ignored as they can mask more complex mistakes.Therefore, one will be more confident after the design decisions that affect convergence are turned off and the expected convergence is recovered.The FP module, on the other hand, significantly deviates from the ideal number of steps required to march inside the volume.Although we could force VTK to march the expected number of steps, we are still investigating possible solutions to and consequences of this issue.To promote an unexpected behavior to a bug, we need interaction with the developers of the code to confirm the code mistake, which was the case with Voreen.One should be aware of the discussed issues when implementing a volume rendering algorithm as their consequences are often not discussed in the literature <41>."}, {"x": 374, "text": "5.6.1 Test Sensitivity"}, {"x": 376, "text": "We already presented the results of applying our verification framework to two libraries and with our experiments we confirm the previously reported sensitivity of convergence analysis <146>.We went further to explore other scenarios in volume rendering that may affect the convergence curve.Thus, in the spirit of mutation testing, we created new versions of VTK which contain known issues.Table 5.2 shows the results of some of the performed tests.In our experiments, we observed that some issues did not affect the observed behavior.The reason for this is that an incomplete set of tests <80> was performed, as shown with test #10 in Table 5.2.In that case, a bug in the G and B color lookups went unnoticed because our framework only used the R channel.Once the verification framework includes all three channels, the convergence behavior does not match the expectations, hence revealing an aberrant behavior that should be investigated.For bug #9, we swapped two of the polynomial coefficients, but they were equal for the scalar field used and thus the bug was not detected.After changing the scalar field to s(x, y, z) = 1xyz + 2xy + 3xz +    , the convergence curve no longer matches the expected one, and thus the bug is detected.Bug #11 was introduced in a matrix-vector multiplication routine which turned out to be dead code.However, for bug #12, the loop range was slightly incorrect and it was not detected, even after additional changes to the verification framework."}, {"x": 377, "text": "Aside from the defects injected into VTK, the following is a list of details known to affect the convergence curve: ERT, as explained before; opacity correction, when using the analytical solution of the volume rendering integral; hardcoded tolerance constants, the famous epsilons; off-by-one indexing problems (sometimes VTK does not render pixels in the first or last column of an image); improper volume sampling (cell centered versus"}, {"x": 381, "text": "The verification process has the same limitations previously described but it also has practical limitations.For instance, one may be able to observe that the convergence rate may not be the expected one for low sampling rates.However, this is not due to the random scalar field generated (which is a trilinear function and thus can be represented exactly with the trilinear interpolant) but high-frequency details in  or C.This may lead to a violation of the Nyquist rate.Because the process is iterative, the expected convergence must be recovered once the resolution is fine enough, assuming that the implementation under verification is correct.Another limitation is related to the number of rays used per pixel.Many implementations can shoot several rays per pixel, although this work assumes that only one ray is used.Also, because the verification procedure considers the code as a blackbox, it does not provide clues on the reasons for the unexpected behavior."}, {"x": 387, "text": "CHAPTER 6 FLOW VISUALIZATION"}, {"x": 388, "text": "Flow visualization has been around in some form for as long as people have studied flows.In some cases, visualization was done explicitly  that is, with the expressed purpose of the viewer to highlight some feature of the flow.In other cases, it was done tacitly, as when a child looks out the window of an airplane to see the slip-stream over the wing generated upon take-off.Visualization has many roles, spanning from art to science.In this chapter, we focused on visualization techniques used for the scientific exploration and explanation of flow phenomena.In particular, we are interested in how two communities  the AIAA community and the Visualization community  consider flow visualization.To accomplish this task, we have used the AIAA Journal and the IEEE Transactions on Visualization and Computer Graphics (TVCG) as representative publication venues of the two communities, and have explored the papers published therein to try to glean how each community approaches visualization of flow, how they might differ from each other, and how the two communities might complement each other."}, {"x": 389, "text": "This chapter is organized as follows.In Section 6.1, we provide a review of the state-of- the-art in flow visualization, both from the perspective of the Visualization and well as the AIAA communities.Tools such as Tecplot <2> and Paraview <163> have implemented many standard flow visualization techniques such as LIC (line integral convolution), streamlines, stream ribbons, and more.As we will show, our review encompasses much of the current practices in flow visualization and also provide pointers to new developments.In the next two sections, we focus our attention on research advances made within the Visualization community that we think will, in time, have impact on flow visualization and on other application domains that use visualization as a means of both scientific exploration and explanation.In Section 6.2, we show how perception and user studies may impact flow visualization, and in particular, we focus on issues related to color maps.In Section 6.3, we then provide discussions on the current Visualization community research trends in Visualization Verification and Uncertainty Quantification.We have chosen these topics because they are all related to flow visualization.In Section 6.4, we speculate on some of the opportunities for collaboration and more effective communication between the two communities, and we conclude in Section 6.5."}, {"x": 390, "text": "6.1 Review of Flow Visualization Techniques"}, {"x": 391, "text": "Vector field visualization is an important and vibrant subfield of both the Visualization and AIAA communities.The techniques developed for vector field visualization extend beyond these communities to fields such as medical imaging, meteorology, the automotive industry, and others.In the past two decades, visualization experts and practitioners have seen the development and improvement of many vector field visualization techniques.The contributions are numerous: the ability of handling different grid types (structured, unstructured, curvilinear, etc), high dimension data (2D, 2.5D, and 3D), time-dependent flow, seeding and placement of geometric primitives, improved performance, perception, rendering, among others.In this section, we review some of the developments inside the Visualization community and compare with current practices inside the AIAA community."}, {"x": 394, "text": "For thoroughness, we also define some commonly used mathematical/physical terms used within the flow visualization literature.A streamline is the path traced by a massless particle in a steady flow.Streamlines are sometimes referred to as instantaneous particle trace.A streakline is the path traced by massless particles seeded at the same position but at different times in a unsteady flow.Stream surfaces and streak surfaces are the 2-manifold analog of streamlines and streakline, where the seeding primitive is a curve instead of a point."}, {"x": 396, "text": "Flow visualization techniques can be classified as direct, geometric, texture-, and feature- based (see Figure 6.1).Table 6.1 provides an overview of the classification and a subset of the available techniques within each class.The table provides a hierarchy of the flow visualization tools available.The Subclass column provides the main component of a given visualization techniques that can be found within the Technique column.One can find reference to extra material within the Reference column.For more details about the articles shown in Table 6.1 and others, we refer the interested reader to the excellent surveys by Hauser et al.<60> and Peng and Laramee <134> for an overview of the flow visualization field, Edmunds et al.<38> and McLoughlin et al.<108> for geometric flow visualization, Laramee et al.<88, 87> for texture-based flow visualization, and Pobitzer et al.<136> for feature-based flow visualization.Next, we briefly go over each of the classes."}, {"x": 398, "text": "Direct visualization techniques provide an intuitive and straightforward way of visual- izing vector fields.In this approach, primitives of interest  such as arrows, glyphs, or lines  are placed at (often regularly-spaced) seed points.The primitives are then oriented according to the vector field.Optionally, the vector magnitude can be mapped to the primitives via scaling.Other flow properties, such as pressure and vorticity, can also be mapped using color maps.In the 3D case, volume rendering <40> is the natural choice for mapping flow properties into color and transparency.Although direct visualization provides an easy first approximation of the vector field, the visual complexity and occlusion may impair the interpretation of the results, especially in 3D datasets."}, {"x": 399, "text": "6.1.2.2 Geometric visualization"}, {"x": 400, "text": "In geometric visualization, curves and surfaces are used for summarizing flow behavior at particular seed points.Geometry-based approaches requires a more intensive processing of the data before the visualization than direct approaches.The main idea behind integration- based geometric flow visualization is to trace particles or curves through the vector field.By tracing particles (or respectively curves) one builds a 1-manifold (or respectively a 2-manifold) that can later be visualized.Geometric visualization techniques have a two steps: first, geometry computation; and secondly, rendering.Often, the rendering step is straightforward  e.g., rendering a polyline  in which case the algorithm collapses into one step.Streamlines are one of the most well-known representative visualization tools within this class.Although flow visualization using both curves and surface dates back over two decades, in recent years, there has been constant research on the topic <38>.For curves, the main contributions of the past decade are related to rendering, seeding, and placement of curves.Edmunds et al.<38> classify the surface-based flow visualization into surface construction and rendering.Methods for surface construction are based on integral surface, implicit, and topological construction.This is an area of intense research in the past few years.The authors present a variety of algorithm for both steady and time-dependent surfaces.Surface rendering methods involve the use of several techniques for improving the quality of the visualization of the flow over a surface of interest.Surface-based techniques can take advantages of direct or texture-based methods by including static/animated arrows over stream surfaces, shading for the evaluation of the shape of surfaces, placing streamlines over 3D surfaces, employing line-integral convolution (LIC) techniques, and/or nonphotorealistic rendering techniques."}, {"x": 402, "text": "In feature-based flow visualization, the input vector field is segmented according to features of interest.As an example, consider a segmentation using classical vector field topology in 2D <61> (see also the right image in Figure 6.1).Let us assume that the features of interest are first order critical points, namely, focus source, focus sink, node source, node sink, and saddles.A segmentation is performed by building a topological skeleton through the computation of the vector fields separatrices.The final result provides a cleaner representation of the flow behavior in terms of the aforementioned features.The intensive processing of extracting features before visualization brings many advantages to the practitioner.First, feature-based techniques are valuable for visualization purposes: feature extraction provides an excellent level of abstraction of the data by removing unde- sired features and focusing the viewer on the important regions of the dataset.In addition, it can be used for vector field compressing, topological simplification, and even for building custom vector fields <170>.Topology-based approaches for feature-based visualization is not the only methodology available.In Lagrangian methods, the trajectories of particles are used to describe and segment the fluid flow.In particular, FLTE <58> methods have gained prominence as a research area within the last decade.One advantage of Lagrangian methods over traditional vector field topology is that they can naturally deal with unsteady flow <136>.Space-time domain techniques are another example of feature-based visualization.In this approach, in order to deal with the problems involved in unsteady flows, the problem of 2D and 3D flow visualization is moved to higher dimensions.As an example, time-dependent domains are merged into a single dataset where traditional techniques used for steady vector fields can be employed.A comprehensive survey on the topic can be found in the state-of-the-art report by Pobitzer et al.<136>."}, {"x": 404, "text": "In texture-based flow visualization, the user replaces geometrical information with 2D texture mapped over surfaces.Line integral convolution (LIC) is a well-known (within the visualization community, at least) representative of the class.Texture-based techniques generate what is considered a dense visualization, i.e., it covers the entire domain of interest, and it does not have to deal with the problem of finding appropriate seeding spots for streamlines.Texture-based techniques can be applied along with geometric or feature-based visualization; for instance, it can be used to render flow on 2-manifolds embedded in 3D spaces, or providing an overview of the flow behavior along with topological skeletons.The main issue with texture-based visualizations is the high computational cost associated with it.Nevertheless, the advances in both computer hardware and algorithms have granted to users the ability to handle large data sets and unstructured grid at interactive rates <38, 87>."}, {"x": 406, "text": "In his position paper On the death of visualization <99>, Lorensen argues for the need to bring visualization researchers closer to experts and practitioners.We have run a simple experiment in order to attempt to ascertain the distance between the Visualization and"}, {"x": 407, "text": "AIAA communities.We evaluated 78 articles published within the AIAA Journal over the period of Jan/2010-Oct/2012 containing at least one flow visualization image.Then, we simply counted the number of papers that contained at least one occurrences of the techniques shown in Table 6.1.We did not include the 2D color mapping and 2D isocontour visualizations as they appear quite often.Since multiple visualization techniques can be used in a single article, the percentages shown below are just the fraction of publications containing at least one particular type of visualization.Particle tracing using integration- based geometric visualization techniques for 2D vector fields is the most commonly used technique (42%), followed by 3D isocontouring (35%), 2D and 3D arrows and glyphs (33%), and 3D particle tracing (19%).Excluding isocontouring (which is mainly used for depicting scalar, instead of vector, data), 61% of the articles used at least one geometric approach to flow visualization, whereas 33% used a direct approach.Finally, 73% of the papers contained at least one visualization for 2D domains, whereas this number is 56% for 3D domains.The latter number drops to 22% if one considers only techniques for visualization of vector field data (i.e., excluding 3D isocontouring)."}, {"x": 408, "text": "Although the data are limited to a short window of time, they raised a few interesting points.With the exception of a handful of papers, most of the flow visualization appears to be using the standard form of the traditional visualization technique.As an example, consider some the papers that use streamlines for visualizing 3D flow.It may be the case that a subset of these paper can benefit from using stream ribbons <177>, which simultaneously encode the streamlines path and local flow vorticity, or from stream tubes <177>, which simultaneously encode the streamlines path and local cross flow divergence.Both stream ribbons and stream tubes are well-known, and commonly used visualization packages such as Paraview or Tecplot have them available within their tool options.Secondly, the preference for the two visualization techniques (direct and curve-based geometric visualization) shown in past three years is perhaps due to their simplicity and availability.The underrepre- sented methods in the same period of time are texture-, feature-, and surface-based flow visualization.Third, one could argue that the visualized datasets were simple, and thus standard techniques worked well.Even though this may be the case for some datasets, some vector fields, especially in 3D, suffered from traditional problem of curves and arrows: cluttering, irregularly spaced streamlines, poor seeding, lack of depth cues, etc.These problems can make the detection of some flow features such as vortex more difficult.Direct visualization for 2D vector fields using glyphs can be improved by using, for instance, a resampling technique, such as shown in Laramee <89>, where the author introduce a user-driven approach for reducing visual clutter via resampling.Another way is to segment the flow using features of interest, e.g., critical points.Possible reasons for not using alternative techniques include that the technique might not be easily available, the technique might not improve the quality of the visualization, users are not aware of their existence or find them difficult to use, or the AIAA community requires a different class of techniques, among other.Both communities would benefit from knowing the reasons for using one technique over another.The visualization community has, throughout the years, defined a set of priorities based on an interaction with researchers from different fields and their own experience.Some recurrent themes that are the focus of research are: a more comprehensive theory and techniques for dealing with unsteady 3D flows; improved rendering (for instance, by using techniques inspired in handcrafted illustrations <13>); handling of large data sets; and others.Together, the AIAA and Visualization communities should be able to define a set of priorities for their research agendas in order to address the concerns and issues raised."}, {"x": 409, "text": "6.2 Perception and Evaluation"}, {"x": 410, "text": "An important aspect of the visualization research consists of the building of new vi- sualization techniques and tools.Ideally, new techniques should be able improve the user cognitive process <174>, for instance, by allowing the visualization of data that have never been visualized before, or increasing ones ability to interact with, understand, and explore data.As visualization techniques are developed and improved, a question is raised: how can we compare and understand the differences between visualization techniques?The answer to this question leads us to a second important research topic: the need for rigorous evaluation of the strengths and weaknesses of visualization techniques.By strength and weakness we mean not only the evaluation of techniques according to traditional (computer science) metrics such as performance, memory footprint, ability to handle large datasets, etc., but also in terms of the errors introduced through visualization, property of these errors, user perception, among others.In particular, questions involving perception and cognition are related to the user.In this section, we review two topics of interest for flow visualization from the point of view of perception and evaluation: the use of color maps for visualization of scalar properties and the representation of steady 2D vector fields, respectively."}, {"x": 411, "text": "6.2.1 Perception and Color Maps"}, {"x": 413, "text": "The rainbow color map is built by varying hue in order to cover the whole spectrum of visible light, from red to purple or vice versa.In practice, many visualization tools use colors varying from red to blue because red and purple are very similar.It is the default map in several visualization / simulation software packages, such as MatlabR .Here we review three issues known to hinder visualizations, namely, lack of ordering, iso-luminance, and introduction of artifacts.Figure 6.2 shows examples for each of these issues.The first issue is due to the lack of a natural sorting order.Even though the rainbow color map is ordered from shorter to longer wavelength of light, users do not easily perceive it as such, which makes quantitative analysis more difficult <10>.In addition, the rainbow color map can obscure data.The problem arises for data containing high spatial frequency.Isoluminant maps can obfuscate these frequencies because our visual system perceives them through changes in luminance.This is illustrated in the left images in Figure 6.2.Note how details on the top half and left portions of the rainbow color mapped image were removed by the choice of the color map.Lastly, the rainbow color map can also add artifacts to the visualization <175>.The problem is that the gradient in color map creates the illusion of patterns where none exist.This is illustrated in the right image in Figure 6.2.In association with the lack of a natural sorting order, it becomes difficult to identify that patterns are not due to the underlying data but due to the color map.Although Figure 6.2 shows simple synthetic examples, there have also been user studies and analysis showing that these problems are also present in the visualization of real-world scenarios <175>.Despite its disadvantages, the rainbow color map is widely used in the sciences.In the study by Borkin et al.<9>, participants reported that they liked it because they are used to seeing, that the saturated colors are easier to see, and it is the most aesthetically pleasing.Another possible reason for its widespread use is that it is default in many popular simulation and visualization tools.Paraview is one of the tools that no longer uses the rainbow color map as the default option since the publication of Rainbow Color Map (Still) Considered Harmful <118> by Borland et al.The author even suggest that a better name for it would be misleading color map.In light of the many pitfalls of the rainbow color map, the visualization community has, in the past few years, been moving away from it.In 2005, 52% of the scientific publication using a color map at the IEEE Visualization Conference had at least one occurrence of the rainbow color map <10>.This number has dropped to a single paper published at the IEEE Transactions on Visualization and Computer Graphics in 2011.Motivated by this experiment, we reviewed all publications from the AIAA Journal for the years of 2010, 2011, and 2012 that contained a color map and counted the number of papers that used the rainbow color map.Table 6.2 shows the obtained results.Note that we do not evaluate the potential problems caused by the rainbow color map.Nevertheless, we tried the methodology explained above for a flow simulation dataset.The left image in Figure 6.3 shows the results of a flow simulation.Note how some regions are over-emphasized (shown in red) while details are blurred (shown in green).The problems with the rainbow color map can be avoided by simply switching to another color map, such as the gray scale color map shown in the middle image in Figure 6.3.The image to the right shows the decolorized rainbow color map: although some details are easier to see, the result is still very different from the gray scale color map."}, {"x": 414, "text": "The visualization community has also investigated what should constitute a good color map.Research on the topic of color selection can be found in the work by Treinish et al.<175>, Moreland <118>, Kindlmann et al.<75>, and others <101, 173>.The AIAA community can benefit from a set of standard color maps suitable for visualization of typical simulation data such as pressure fields, angle fields, etc."}, {"x": 416, "text": "In recent years, the Visualization community has seen a substantial increase in the number of papers dealing with evaluation of visualization techniques published within IEEE TVCG.Figure 6.4 shows the number of such papers published per year within the IEEE TVCG journal.The data were obtained by searching the TVCG website for the keywords evaluation, user study, design study, and case study in articles published in the period between 2002 and 2012.We then read the abstracts to make sure the papers were indeed relevant.From this corpora, 96% of the aforementioned articles were user studies."}, {"x": 417, "text": "As a representative example, we focus on a user study by Laidlaw et al.<86> comparing techniques for the visualization of steady 2D vector fields.The authors recruited five experts and 12 nonexperts users to evaluate the efficacy of each of the six techniques displayed in Figure 6.5.The evaluation was measured by the user performance during the execution of several tasks of three types: critical point detection; critical points classification; and simulation of particle advection.The first two tasks are standard whereas the third task is motivated by the fact that often experts were interested in the global flow direction.The three tasks were chosen based on the authors interaction with fluid mechanics researchers.The authors built a collection of 500 vector fields for evaluation of the tasks.Among the results, they cite no significant difference between experts and nonexperts regarding accuracy in the tasks or the response times.More interestingly, performance when using the standard method of arrows on a regular grid (GRID in Figure 6.5) falls below average for multiples tasks involving critical points location, classification, and advection (which means that users required more time to complete the task and committed more errors).On the other end of the spectrum, user performance when using GSTR consistently scored above average.Another similar study compare the user performance when using line and tube integral curves (with monoscopic and stereoscopic viewing) for 3D vector field data <48>.User study can be a powerful tool for helping users choose the best tool for their needs and the visualization community has been working on evaluating and testing techniques as they become more widespread."}, {"x": 419, "text": "Uncertainty visualization and visualization verification are two important topics in the pursuit for reliable visualizations.The AIAA community is familiar with both topics.In this chapter, however, we present some of the recent advancements in this area from the point of view of the Visualization community.The goal is to increase the user confidence in the results of the visualization by answering questions such as: how can one visualize the inherent error sources in the visualization?or, how can one increase her/his confidence that an implementation of a visualization algorithm does what was intended?In the following sections we present some of the recent developments in uncertainty visualization and the verification of isosurface extraction techniques."}, {"x": 421, "text": "In the course of scientific inquiry, uncertainty is the norm.The visualization community has recently turned its attention to uncertain data, and is trying to solve problems on how to best compute and convey uncertainty information.Since 2010, around 30 papers were published at TVCG on the topic, with application on information visualization and scientific visualization.So far, the community has seen several different representation for uncertainty, varying from traditional method such as bars, glyphs, and colors, to texture, multilayering, animations, and volume rendering.At the AIAA community, we analyzed ten papers since 2010 dealing with material uncertainty, uncertainty in flows, and fluid simulation.The visualization step, on the other hand, is restricted almost exclusively to error bars and charts."}, {"x": 422, "text": "In the user study conducted by Sanyal et al.<148>, the authors evaluate the effectiveness of four commonly used uncertainty visualization techniques: namely, glyphs size, glyphs color mapping, surface color mapping, and error bars (see Figure 6.6 for examples).The users performed two search tasks by identifying regions that are least and most uncertain, and two counting tasks where users counted the number of data and uncertainty features.The authors reported that, in general, users required more time and committed more mistakes when using error bars.The authors conjecture that a possible reasons for the poor performance displayed by error bars is due to the high density of the dataset used in their study.Nevertheless, a similar pattern can be found in the AIAA community (e.g., see Figures 4 and 6 in Chassaing and Lucor <19>)."}, {"x": 423, "text": "Several techniques for uncertainty visualization of vector fields are available.Botchen et al.<11> introduce a texture-mapping approach for uncertainty visualization of 2D vector fields.Hlawatsch et al.<63> introduce a new static visualization of unsteady vector fields with uncertainty based on a new type of glyph.Osorio and Brodlie <1> introduce a LIC- based method for uncertainty visualization.The work by Petz et al.<135> uses Gaussian random fields and takes into account spatial correlation of the data, which affects vector field features.Fout and Ma <123> presents a framework based on possibility theory for uncertainty visualization and as a case study, the authors use streamlines in 3D steady vector fields.Because many researchers have recently turned their attention to uncertainty visualization, this area of research is rapidly evolving."}, {"x": 424, "text": "6.3.2 Verifiable Visualization"}, {"x": 427, "text": "Much of the early motivation for flow visualization in the visualization community came from the AIAA community, but over the last two decades, it appears that a major gap has developed, and developments in the visualization community have been done much more independently of applications and new developments in the aeronautics area.This is in part due to the different needs of the many users of visualization techniques, including the automotive industry, meteorology, medical imaging, geosciences, to cite a few.Summarizing decades of developments in the field of flow visualization and related areas is a nontrivial process.As an alternative, every year, a summary of recent relevant advances of visualization techniques could be published at the AIAA community; and conversely, the AIAA community could help the visualization community not only by providing expertise, but also research directions <121>.Yearly panels are held at the IEEE Vis conference, many of them with an applications focus.Consistent participation by the AIAA in these communities would help raise the level of awareness of current pressing issues.This gap between communities seems to be particular true in the need for validation and verification of visualizations techniques and codes, which over time seem to have lost track with the new rigor expected of computational codes.A related topic is the need for increasing the level of reproducibility of computational results, which cannot be simply accomplish by making codes available to other researchers <158>."}, {"x": 428, "text": "There is a natural progression from research idea within the visualization community to prototype tool, and from prototype tool to hardened user-available software.The challenge put forward to the visualization community to continue to seek out how to be relevant to collaborators such as our colleagues in the AIAA community, and the challenge of disseminating the advances made by the visualization community to application domains.Over the last 20 years, visualization techniques have merged as a key enabling technology for computation science by helping people explore and explain data through the creation of both static and interactive visual representations.Visualizations libraries such as Kitwares VTK contain a very large number of highly-complex visualization algorithms with thousand of lines of code implementing them.The most powerful of these algorithms are often based on complex mathematical concepts, e.g., Morse-Smale complex, spectral analysis, and partial differential equations (PDEs).Robust implementations of these techniques require the use of nontrivial techniques.The overall complexity and size of these datasets leave no room for inefficient code, thus making their implementation even more complex.The complexity of the codes coupled with the new visualization techniques make it highly nontrivial for nonexperts to use them, although, in principle, it should be easier."}, {"x": 429, "text": "We believe better connections between the two communities have the chance to improve the adoption of new techniques.Furthermore, by working together, AIAA researchers can also help the Visualization community not only by providing new problems and datasets and being a major driver of problems to the community (such as they were when the visualization field was coming of age), but also by making sure the needs of the AIAA community are reflected in new research topics in Visualization."}, {"x": 431, "text": "In this chapter, we have briefly visited two decades worth of flow visualization.In particular, we first focused on vector field visualization.In this regard, we presented a classification of flow visualization seen from the perspective of the Visualization community and contrasted it with AIAA publications containing flow visualization over the last 3 years.By exposing the current advances in visualization, we have a starting point for building a common research agenda that can benefit both communities.In addition, we have also visited some topics related to flow visualization that have been attracting attention in the Visualization community, namely, evaluation of visualization techniques, perception, uncertainty visualization, and verifiable visualization.The common thread in all these topics is the need for improving visualization techniques in general via error mitigation, and understanding how visualization can improve the user cognitive process.We showed some of the recent work on each of these topics in the context of flow visualization.As we mentioned at the start, (computational) flow visualization is a research area that was birthed simultaneously in two communities, and early in its development benefited from strong interaction between the communities.It is our hope that a more tight coupling between the research needs/interests of the AIAA community and the research agendas of the Visualization community can be developed.This can only happen through cooperation, collaboration, and communication.In part, we hope that this work is the start of a dialog between the two communities."}, {"x": 433, "text": "In this dissertation, we have introduced a framework for the verification of two of the most popular visualization techniques available in scientific visualization, namely, isosurface extraction and volume rendering.The framework is based on the Method of Manufactured Solutions (MMS), a well-established idea inside the Computation Science & Engineering community."}, {"x": 435, "text": "As previously mentioned, the two main steps involved in the practice of the MMS are the theoretical analysis of important mathematical properties and the black-box testing.The analysis was the most time-consuming part because required intense research.The convergence of geometrical properties of isosurfaces, such as function value and normals, were mostly available in the literature.Hence, the research was fairly straightforward in this case.On the other hand, the verification of topological properties were available only by using relatively complex algorithms, such as contour trees.The complexity was one of our motivations to devise new algorithms for computing the Euler characteristics of isosurfaces directly from scalar fields.In addition to that, our work on topological verification played a crucial role in correcting an almost 20-year-old bug with Marching Cubes 33.The case of verification of volume rendering algorithms also required a convergence analysis not available in the literature.Thus, the analysis of the theoretical behavior of visualization algorithms presented in this work constitute an important contribution of this dissertation.Another important consideration is that often simplifications must be made so that an algorithm can be verified, such as illustrated by the volume rendering case.Many of the commonly used improvements to the standard volume rendering, such as opacity correction or advanced shading, must be turned off because the theoretical analysis does not include the influence of these improvements."}, {"x": 436, "text": "Because of its simplicity, we believe MMS could become a standard tool for the verification of scientific visualization software in the same way that it has been adopted by the CS&E community as a trustworthy tool for assess code correctness."}, {"x": 437, "text": "We observed that the MMS contrasts with a common practice within the visualization community, namely, the evaluation of new techniques through the use of real-world data.By using real-world data during development, one can evaluate a new technique using the data it is supposed to represent.When the data do not look right in the eyes of an expert, or the error quantification exceeds some predetermined threshold, it is assumed that there is a problem that must be fixed.This approach is certainly valuable and we do not advocate the MMS as a replacement for using real-world data, or any other method that users are accustomed with for that matter.Instead, we advocate its use in addition to the methods already adopted by developers."}, {"x": 439, "text": "As our work have shown, it is not always possible to use order of accuracy as a standard method for the verification of visualization algorithms.While geometrical properties can be continuously evaluated, topological properties have a binary nature.We then conclude that the implementation of the MMS is problem-dependent and the necessary mathematical tools must be tailored accordingly.Nevertheless, the idea of verification through manufactured solutions can be used across many visualizations techniques.We expect MMS to enjoy a similar effectiveness in many areas of scientific visualization.This is the most direct direction of future work: the application of the MMS to other visualization techniques such as vector field visualization and mesh simplification."}, {"x": 441, "text": "The economic impact due to the lack of appropriate infrastructure for software testing is well studied.A NIST report estimates that the total loss due to lack of software testing is about $22.2 to $59.5 billion <166>.To the best of our knowledge, the economic impact and consequences of the lack of software testing for the subfield of scientific visualization has not yet been evaluated.Nevertheless, there is anecdotal evidence of the need for this evaluation.As an example, we cite a medical report extracted from the Manufacturer and User Facility Device Experience (MAUDE), a data repository of adverse events involving medical devices under the umbrella of the FDA:"}, {"x": 445, "text": "Verification has gained some traction inside the field of visualization in recent years.We have seen several initiatives that support this: two workshops on reproducibility, verifica- tion, and validation in visualization (EuroRV3 2012-2013) at Eurovis; a discussion panel Verification in Visualization: Building a Common Culture at IEEE VisWeek 2011; and verification as part of the call for participation for IEEE VisWeek 2010-2013.We hope the examples presented here will further encourage the adoption of MMS by the visualization community at large, increasing the impact of its contributions to a wider audience.We believe that researchers and developers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.We hope that the results of this work further motivate the visualization community to develop a culture of verification."}], "chapters": [{"text": "ABSTRACT", "sentence_id": "s_0", "sentence_rank": "0", "paragraph_id": "p_0", "paragraph_rank": 0}, {"text": "CHAPTER 1 INTRODUCTION", "sentence_id": "s_17", "sentence_rank": "17", "paragraph_id": "p_2", "paragraph_rank": 2}, {"text": "1.1 Verification of Scientific Theories", "sentence_id": "s_31", "sentence_rank": "31", "paragraph_id": "p_5", "paragraph_rank": 5}, {"text": "1.2 Verification", "sentence_id": "s_59", "sentence_rank": "59", "paragraph_id": "p_10", "paragraph_rank": 10}, {"text": "1.3 Contributions", "sentence_id": "s_95", "sentence_rank": "95", "paragraph_id": "p_16", "paragraph_rank": 16}, {"text": "CHAPTER 2 VERIFYING GEOMETRY OF ISOSURFACE EXTRACTION ALGORITHMS", "sentence_id": "s_134", "sentence_rank": "134", "paragraph_id": "p_40", "paragraph_rank": 40}, {"text": "2.1 Related Work", "sentence_id": "s_138", "sentence_rank": "138", "paragraph_id": "p_42", "paragraph_rank": 42}, {"text": "2.2 Verifying Isosurface Extraction Algorithms", "sentence_id": "s_157", "sentence_rank": "157", "paragraph_id": "p_48", "paragraph_rank": 48}, {"text": "2.2.1 Convergence of Vertex Position", "sentence_id": "s_174", "sentence_rank": "174", "paragraph_id": "p_52", "paragraph_rank": 52}, {"text": "2.2.2 Convergence of Normals", "sentence_id": "s_188", "sentence_rank": "188", "paragraph_id": "p_55", "paragraph_rank": 55}, {"text": "2.2.3 Convergence of Area", "sentence_id": "s_190", "sentence_rank": "190", "paragraph_id": "p_57", "paragraph_rank": 57}, {"text": "2.2.4 Convergence of Curvature", "sentence_id": "s_199", "sentence_rank": "199", "paragraph_id": "p_60", "paragraph_rank": 60}, {"text": "2.3 Experimental Results", "sentence_id": "s_208", "sentence_rank": "208", "paragraph_id": "p_64", "paragraph_rank": 64}, {"text": "2.3.1 VTK Marching Cubes", "sentence_id": "s_213", "sentence_rank": "213", "paragraph_id": "p_66", "paragraph_rank": 66}, {"text": "2.3.2 SnapMC", "sentence_id": "s_218", "sentence_rank": "218", "paragraph_id": "p_68", "paragraph_rank": 68}, {"text": "2.3.3 Macet", "sentence_id": "s_224", "sentence_rank": "224", "paragraph_id": "p_70", "paragraph_rank": 70}, {"text": "2.3.4 Dual Contouring", "sentence_id": "s_229", "sentence_rank": "229", "paragraph_id": "p_72", "paragraph_rank": 72}, {"text": "2.3.5 Afront", "sentence_id": "s_233", "sentence_rank": "233", "paragraph_id": "p_74", "paragraph_rank": 74}, {"text": "2.3.6 DelIso", "sentence_id": "s_241", "sentence_rank": "241", "paragraph_id": "p_76", "paragraph_rank": 76}, {"text": "2.3.7 Observed Order of Accuracy", "sentence_id": "s_247", "sentence_rank": "247", "paragraph_id": "p_79", "paragraph_rank": 79}, {"text": "2.3.7.1 Algebraic distance", "sentence_id": "s_258", "sentence_rank": "258", "paragraph_id": "p_82", "paragraph_rank": 82}, {"text": "2.3.7.2 Normals", "sentence_id": "s_261", "sentence_rank": "261", "paragraph_id": "p_84", "paragraph_rank": 84}, {"text": "2.3.7.3 Area", "sentence_id": "s_267", "sentence_rank": "267", "paragraph_id": "p_86", "paragraph_rank": 86}, {"text": "2.3.7.4 Curvature", "sentence_id": "s_277", "sentence_rank": "277", "paragraph_id": "p_88", "paragraph_rank": 88}, {"text": "2.3.8 Detected Bugs", "sentence_id": "s_286", "sentence_rank": "286", "paragraph_id": "p_90", "paragraph_rank": 90}, {"text": "2.4 Discussion", "sentence_id": "s_303", "sentence_rank": "303", "paragraph_id": "p_94", "paragraph_rank": 94}, {"text": "2.4.1 On the Implementation and Use of MMS", "sentence_id": "s_307", "sentence_rank": "307", "paragraph_id": "p_96", "paragraph_rank": 96}, {"text": "2.4.2 On the Complexity of the Manufactured Solution", "sentence_id": "s_320", "sentence_rank": "320", "paragraph_id": "p_98", "paragraph_rank": 98}, {"text": "2.4.3 On the Order of Accuracy", "sentence_id": "s_332", "sentence_rank": "332", "paragraph_id": "p_101", "paragraph_rank": 101}, {"text": "2.4.4 On the Limitations of the Test", "sentence_id": "s_348", "sentence_rank": "348", "paragraph_id": "p_106", "paragraph_rank": 106}, {"text": "2.5 Conclusion", "sentence_id": "s_353", "sentence_rank": "353", "paragraph_id": "p_108", "paragraph_rank": 108}, {"text": "CHAPTER 3 VERIFYING TOPOLOGY OF ISOSURFACE EXTRACTION ALGORITHMS", "sentence_id": "s_357", "sentence_rank": "357", "paragraph_id": "p_110", "paragraph_rank": 110}, {"text": "3.1 Related Work", "sentence_id": "s_389", "sentence_rank": "389", "paragraph_id": "p_122", "paragraph_rank": 122}, {"text": "3.1.1 Topology-aware Isosurfacing", "sentence_id": "s_392", "sentence_rank": "392", "paragraph_id": "p_124", "paragraph_rank": 124}, {"text": "3.1.2 Verifiable Visualization", "sentence_id": "s_412", "sentence_rank": "412", "paragraph_id": "p_128", "paragraph_rank": 128}, {"text": "3.2 Verifying Isosurface Topology", "sentence_id": "s_426", "sentence_rank": "426", "paragraph_id": "p_131", "paragraph_rank": 131}, {"text": "3.2.1 Simple Example", "sentence_id": "s_437", "sentence_rank": "437", "paragraph_id": "p_133", "paragraph_rank": 133}, {"text": "3.3 Mathematical Tools", "sentence_id": "s_460", "sentence_rank": "460", "paragraph_id": "p_136", "paragraph_rank": 136}, {"text": "3.3.1 Digital Topology", "sentence_id": "s_473", "sentence_rank": "473", "paragraph_id": "p_140", "paragraph_rank": 140}, {"text": "3.3.2 Stratified Morse Theory", "sentence_id": "s_505", "sentence_rank": "505", "paragraph_id": "p_150", "paragraph_rank": 150}, {"text": "3.4 Manufactured Solution Pipeline", "sentence_id": "s_573", "sentence_rank": "573", "paragraph_id": "p_168", "paragraph_rank": 168}, {"text": "3.4.1 Consistency", "sentence_id": "s_577", "sentence_rank": "577", "paragraph_id": "p_170", "paragraph_rank": 170}, {"text": "3.4.2 Verification Using Stratified Morse Theory", "sentence_id": "s_582", "sentence_rank": "582", "paragraph_id": "p_172", "paragraph_rank": 172}, {"text": "3.4.3 Verification Using Digital Topology", "sentence_id": "s_588", "sentence_rank": "588", "paragraph_id": "p_174", "paragraph_rank": 174}, {"text": "3.5 Experimental Results", "sentence_id": "s_603", "sentence_rank": "603", "paragraph_id": "p_178", "paragraph_rank": 178}, {"text": "3.5.1 Topology Consistency", "sentence_id": "s_651", "sentence_rank": "651", "paragraph_id": "p_189", "paragraph_rank": 189}, {"text": "3.5.2 DelIso", "sentence_id": "s_655", "sentence_rank": "655", "paragraph_id": "p_191", "paragraph_rank": 191}, {"text": "3.5.3 SnapMC", "sentence_id": "s_663", "sentence_rank": "663", "paragraph_id": "p_193", "paragraph_rank": 193}, {"text": "3.5.4 Matlab", "sentence_id": "s_668", "sentence_rank": "668", "paragraph_id": "p_195", "paragraph_rank": 195}, {"text": "3.5.5 Macet", "sentence_id": "s_675", "sentence_rank": "675", "paragraph_id": "p_197", "paragraph_rank": 197}, {"text": "3.5.6 Topology Correctness", "sentence_id": "s_679", "sentence_rank": "679", "paragraph_id": "p_199", "paragraph_rank": 199}, {"text": "3.6 Discussion and Limitations 3.6.1 Quality of Manufactured Solutions", "sentence_id": "s_702", "sentence_rank": "702", "paragraph_id": "p_204", "paragraph_rank": 204}, {"text": "3.6.2 Topology and Geometry", "sentence_id": "s_710", "sentence_rank": "710", "paragraph_id": "p_206", "paragraph_rank": 206}, {"text": "3.6.3 SMT vs.", "sentence_id": "s_719", "sentence_rank": "719", "paragraph_id": "p_209", "paragraph_rank": 209}, {"text": "3.6.4 Implementation of SMT and DT", "sentence_id": "s_731", "sentence_rank": "731", "paragraph_id": "p_211", "paragraph_rank": 211}, {"text": "3.6.5 Contour Trees", "sentence_id": "s_757", "sentence_rank": "757", "paragraph_id": "p_215", "paragraph_rank": 215}, {"text": "3.6.6 Topology of the Underlying Object", "sentence_id": "s_771", "sentence_rank": "771", "paragraph_id": "p_217", "paragraph_rank": 217}, {"text": "3.6.7 Limitations", "sentence_id": "s_782", "sentence_rank": "782", "paragraph_id": "p_219", "paragraph_rank": 219}, {"text": "3.7 Conclusion", "sentence_id": "s_786", "sentence_rank": "786", "paragraph_id": "p_221", "paragraph_rank": 221}, {"text": "CHAPTER 4 PRACTICAL CONSIDERATIONS ON THE TOPOLOGICAL CORRECTNESS OF MARCHING CUBES 33", "sentence_id": "s_793", "sentence_rank": "793", "paragraph_id": "p_223", "paragraph_rank": 223}, {"text": "4.1 Related Work", "sentence_id": "s_830", "sentence_rank": "830", "paragraph_id": "p_232", "paragraph_rank": 232}, {"text": "4.2 Preliminaries", "sentence_id": "s_875", "sentence_rank": "875", "paragraph_id": "p_239", "paragraph_rank": 239}, {"text": "4.2.1 Chernyaevs MC33", "sentence_id": "s_883", "sentence_rank": "883", "paragraph_id": "p_243", "paragraph_rank": 243}, {"text": "4.3 Experiments Setup", "sentence_id": "s_915", "sentence_rank": "915", "paragraph_id": "p_254", "paragraph_rank": 254}, {"text": "4.3.1 Reproducibility", "sentence_id": "s_929", "sentence_rank": "929", "paragraph_id": "p_256", "paragraph_rank": 256}, {"text": "4.4 Issues with the MC33", "sentence_id": "s_941", "sentence_rank": "941", "paragraph_id": "p_258", "paragraph_rank": 258}, {"text": "4.4.1 Issue I  Case 13.5", "sentence_id": "s_956", "sentence_rank": "956", "paragraph_id": "p_261", "paragraph_rank": 261}, {"text": "4.4.1.1 Tunnel orientation", "sentence_id": "s_985", "sentence_rank": "985", "paragraph_id": "p_269", "paragraph_rank": 269}, {"text": "4.4.2 Issue II  Nonmanifold Surfaces", "sentence_id": "s_997", "sentence_rank": "997", "paragraph_id": "p_271", "paragraph_rank": 271}, {"text": "4.4.3 Issue III  Cutting-plane Computation", "sentence_id": "s_1011", "sentence_rank": "1011", "paragraph_id": "p_274", "paragraph_rank": 274}, {"text": "4.5 Solutions", "sentence_id": "s_1037", "sentence_rank": "1037", "paragraph_id": "p_283", "paragraph_rank": 283}, {"text": "4.5.1 Issue I  Case 13.5", "sentence_id": "s_1039", "sentence_rank": "1039", "paragraph_id": "p_285", "paragraph_rank": 285}, {"text": "4.5.1.1 Tunnel orientation", "sentence_id": "s_1059", "sentence_rank": "1059", "paragraph_id": "p_288", "paragraph_rank": 288}, {"text": "4.5.2 Issue II  Nonmanifold Surfaces", "sentence_id": "s_1074", "sentence_rank": "1074", "paragraph_id": "p_291", "paragraph_rank": 291}, {"text": "4.5.3 Issue III  Cutting-plane Computation", "sentence_id": "s_1094", "sentence_rank": "1094", "paragraph_id": "p_296", "paragraph_rank": 296}, {"text": "4.5.4 Issue IV  Case 10", "sentence_id": "s_1096", "sentence_rank": "1096", "paragraph_id": "p_298", "paragraph_rank": 298}, {"text": "4.6 Experiments with Real-world Datasets", "sentence_id": "s_1099", "sentence_rank": "1099", "paragraph_id": "p_300", "paragraph_rank": 300}, {"text": "4.7 Conclusion", "sentence_id": "s_1138", "sentence_rank": "1138", "paragraph_id": "p_308", "paragraph_rank": 308}, {"text": "CHAPTER 5 VERIFYING DIRECT VOLUME RENDERING ALGORITHM", "sentence_id": "s_1142", "sentence_rank": "1142", "paragraph_id": "p_310", "paragraph_rank": 310}, {"text": "5.1 Related Work", "sentence_id": "s_1164", "sentence_rank": "1164", "paragraph_id": "p_316", "paragraph_rank": 316}, {"text": "5.2 Verification", "sentence_id": "s_1188", "sentence_rank": "1188", "paragraph_id": "p_321", "paragraph_rank": 321}, {"text": "5.3 Discretization Errors", "sentence_id": "s_1219", "sentence_rank": "1219", "paragraph_id": "p_325", "paragraph_rank": 325}, {"text": "5.4 Convergence Computation", "sentence_id": "s_1231", "sentence_rank": "1231", "paragraph_id": "p_328", "paragraph_rank": 328}, {"text": "5.4.1 Numerical Errors Using a Known Solution", "sentence_id": "s_1239", "sentence_rank": "1239", "paragraph_id": "p_330", "paragraph_rank": 330}, {"text": "5.4.2 Numerical Errors when the True Solution Is Unknown", "sentence_id": "s_1254", "sentence_rank": "1254", "paragraph_id": "p_335", "paragraph_rank": 335}, {"text": "5.5 Application Examples", "sentence_id": "s_1264", "sentence_rank": "1264", "paragraph_id": "p_339", "paragraph_rank": 339}, {"text": "5.5.1 Implementations Under Verification", "sentence_id": "s_1267", "sentence_rank": "1267", "paragraph_id": "p_341", "paragraph_rank": 341}, {"text": "5.5.1.1 VTK", "sentence_id": "s_1271", "sentence_rank": "1271", "paragraph_id": "p_344", "paragraph_rank": 344}, {"text": "5.5.1.2 Voreen", "sentence_id": "s_1278", "sentence_rank": "1278", "paragraph_id": "p_346", "paragraph_rank": 346}, {"text": "5.5.2 System Setup", "sentence_id": "s_1283", "sentence_rank": "1283", "paragraph_id": "p_348", "paragraph_rank": 348}, {"text": "5.5.3 Observed Behavior", "sentence_id": "s_1313", "sentence_rank": "1313", "paragraph_id": "p_356", "paragraph_rank": 356}, {"text": "5.5.3.1 FP", "sentence_id": "s_1319", "sentence_rank": "1319", "paragraph_id": "p_359", "paragraph_rank": 359}, {"text": "5.5.3.2 RCM", "sentence_id": "s_1339", "sentence_rank": "1339", "paragraph_id": "p_362", "paragraph_rank": 362}, {"text": "5.5.3.3 Voreen", "sentence_id": "s_1355", "sentence_rank": "1355", "paragraph_id": "p_367", "paragraph_rank": 367}, {"text": "5.6 Discussion", "sentence_id": "s_1372", "sentence_rank": "1372", "paragraph_id": "p_372", "paragraph_rank": 372}, {"text": "5.6.1 Test Sensitivity", "sentence_id": "s_1388", "sentence_rank": "1388", "paragraph_id": "p_374", "paragraph_rank": 374}, {"text": "5.7 Limitations", "sentence_id": "s_1410", "sentence_rank": "1410", "paragraph_id": "p_379", "paragraph_rank": 379}, {"text": "5.8 Conclusion", "sentence_id": "s_1435", "sentence_rank": "1435", "paragraph_id": "p_384", "paragraph_rank": 384}, {"text": "CHAPTER 6 FLOW VISUALIZATION", "sentence_id": "s_1446", "sentence_rank": "1446", "paragraph_id": "p_387", "paragraph_rank": 387}, {"text": "6.1 Review of Flow Visualization Techniques", "sentence_id": "s_1463", "sentence_rank": "1463", "paragraph_id": "p_390", "paragraph_rank": 390}, {"text": "6.1.1 Preliminaries", "sentence_id": "s_1469", "sentence_rank": "1469", "paragraph_id": "p_392", "paragraph_rank": 392}, {"text": "6.1.2 Classes of Techniques", "sentence_id": "s_1479", "sentence_rank": "1479", "paragraph_id": "p_395", "paragraph_rank": 395}, {"text": "6.1.2.1 Direct visualization", "sentence_id": "s_1492", "sentence_rank": "1492", "paragraph_id": "p_397", "paragraph_rank": 397}, {"text": "6.1.2.2 Geometric visualization", "sentence_id": "s_1500", "sentence_rank": "1500", "paragraph_id": "p_399", "paragraph_rank": 399}, {"text": "6.1.2.3 Feature-based visualization", "sentence_id": "s_1517", "sentence_rank": "1517", "paragraph_id": "p_401", "paragraph_rank": 401}, {"text": "6.1.2.4 Texture-based visualization", "sentence_id": "s_1535", "sentence_rank": "1535", "paragraph_id": "p_403", "paragraph_rank": 403}, {"text": "6.1.3 Means to an End", "sentence_id": "s_1542", "sentence_rank": "1542", "paragraph_id": "p_405", "paragraph_rank": 405}, {"text": "6.2 Perception and Evaluation", "sentence_id": "s_1571", "sentence_rank": "1571", "paragraph_id": "p_409", "paragraph_rank": 409}, {"text": "6.2.1 Perception and Color Maps", "sentence_id": "s_1579", "sentence_rank": "1579", "paragraph_id": "p_411", "paragraph_rank": 411}, {"text": "6.2.2 Evaluation and User Studies", "sentence_id": "s_1624", "sentence_rank": "1624", "paragraph_id": "p_415", "paragraph_rank": 415}, {"text": "6.3 Uncertainty and Verification", "sentence_id": "s_1642", "sentence_rank": "1642", "paragraph_id": "p_418", "paragraph_rank": 418}, {"text": "6.3.1 Uncertainty Visualization", "sentence_id": "s_1649", "sentence_rank": "1649", "paragraph_id": "p_420", "paragraph_rank": 420}, {"text": "6.3.2 Verifiable Visualization", "sentence_id": "s_1672", "sentence_rank": "1672", "paragraph_id": "p_424", "paragraph_rank": 424}, {"text": "6.4 Opportunities", "sentence_id": "s_1674", "sentence_rank": "1674", "paragraph_id": "p_426", "paragraph_rank": 426}, {"text": "6.5 Conclusion", "sentence_id": "s_1693", "sentence_rank": "1693", "paragraph_id": "p_430", "paragraph_rank": 430}, {"text": "CHAPTER 7 CONCLUSION", "sentence_id": "s_1705", "sentence_rank": "1705", "paragraph_id": "p_432", "paragraph_rank": 432}, {"text": "7.1 The Method of Manufactured Solutions", "sentence_id": "s_1708", "sentence_rank": "1708", "paragraph_id": "p_434", "paragraph_rank": 434}, {"text": "7.2 Order of Accuracy", "sentence_id": "s_1726", "sentence_rank": "1726", "paragraph_id": "p_438", "paragraph_rank": 438}, {"text": "7.3 Evaluation", "sentence_id": "s_1733", "sentence_rank": "1733", "paragraph_id": "p_440", "paragraph_rank": 440}, {"text": "7.4 Broad Impact", "sentence_id": "s_1746", "sentence_rank": "1746", "paragraph_id": "p_444", "paragraph_rank": 444}], "scenes": [["Engineering", "Stratified_Morse_theory", "Computational_science", "Marching_cubes"], ["The_Logic_of_Scientific_Discovery", "Karl_Popper"], ["Sun", "Newton_(unit)", "Arthur_Eddington", "Newton's_law_of_universal_gravitation", "Hyades_(star_cluster)", "Earth"], ["Computer_science", "Color", "Computational_science", "Foreach_loop", "Engineering", "Fluid_dynamics", "Computational_fluid_dynamics"], ["Computer_science", "Computational_science", "Computer_simulation", "IEEE_Standards_Association"], ["Brazil", "Sobral,_Cear\u00e1", "Earth"], ["Partial_differential_equation"], ["Computer_science"], ["Geometry", "Isosurface"], ["Isosurface", "Topology"], ["Digital_topology"], ["Stratified_Morse_theory"], ["Correctness_(computer_science)", "Marching_cubes"], ["Marching_cubes"], ["Algorithm", "Volume_rendering"], ["Flow_visualization"], ["Geometry", "Isosurface"], ["Rapid_transit"], ["William_Forsell_Kirby"], ["Isosurface"], ["Multimedia_Messaging_Service", "Algorithm"], ["Multimedia_Messaging_Service"], ["Taylor_series"], ["Limit_of_a_sequence"], ["Limit_of_a_sequence"], ["Taylor_series"], ["Limit_of_a_sequence"], ["Limit_of_a_sequence"], ["Limit_of_a_sequence"], ["Probability_of_kill"], ["Curvature"], ["Multimedia_Messaging_Service"], ["VTK", "Marching_cubes"], ["VTK"], ["Marching_cubes", "Cartesian_coordinate_system"], ["Marching_cubes"], ["Marching_cubes"], ["Marching_cubes", "Contour_plowing"], ["3D_computer_graphics", "Voronoi_diagram", "Delaunay_triangulation"], ["VTK", "Marching_cubes", "Contour_plowing"], ["VTK", "Lp_space", "Marching_cubes", "Contour_plowing"], ["VTK", "Marching_cubes", "Contour_plowing"], ["Lp_space", "VTK", "Marching_cubes", "Gaussian_curvature", "Contour_plowing"], ["Contour_plowing"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service", "Marching_cubes"], ["Marvel_Comics"], ["Multimedia_Messaging_Service", "Cubic_Hermite_spline"], ["Multimedia_Messaging_Service"], ["Gaussian_curvature", "Vertex_(geometry)"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service", "Betti_number", "Euler_characteristic"], ["Topological_space", "Verification_and_validation", "Isosurface"], ["Multimedia_Messaging_Service"], ["Stratified_Morse_theory"], ["Euler_characteristic", "Stratified_Morse_theory"], ["Marching_cubes", "Marvel_Comics"], ["Homeomorphism", "Marching_cubes"], ["Formal_verification"], ["Multimedia_Messaging_Service", "Marvel_Comics"], ["Computational_topology"], ["Isosurface"], ["Marching_cubes"], ["Piecewise_linear_manifold", "Marching_cubes"], ["Euler_characteristic", "Betti_number"], ["Mark_Goresky", "Stratified_Morse_theory"], ["Euler_characteristic", "Stratified_Morse_theory", "Betti_number"], ["Euler_characteristic", "Betti_number"], ["Euclidean_space"], ["Video_game", "Scalar_(mathematics)", "Voronoi_diagram"], ["Video_game"], ["Pasting_lemma", "Michigan"], ["Morse_theory"], ["Mark_Goresky", "Stratified_Morse_theory", "Betti_number", "Leonhard_Euler"], ["Euler_characteristic", "Morse_theory"], ["Hessian_matrix"], ["Morse_theory"], ["2D_computer_graphics", "Morse_theory"], ["Euler_characteristic", "Morse_theory"], ["Morse_theory", "NL_(complexity)"], ["NL_(complexity)"], ["Euler_characteristic"], ["Euler_characteristic", "Critical_point_(mathematics)", "Morse_theory", "Cartesian_coordinate_system"], ["Cartesian_coordinate_system"], ["Euler_characteristic", "Morse_theory"], ["Euler_characteristic"], ["Piecewise_linear_manifold", "Monte_Carlo_method"], ["Morse_theory"], ["Algorithm"], ["Michigan", "Scalar_(mathematics)", "Algorithm"], ["ALGO", "Algorithm"], ["Multimedia_Messaging_Service"], ["VTK", "Marching_cubes"], ["VTK", "MATLAB"], ["MATLAB", "Marching_cubes"], ["Marching_cubes"], ["Marching_cubes", "Monte_Carlo_method"], ["Voronoi_diagram", "Delaunay_triangulation", "Dimension"], ["Marching_cubes"], ["Topological_space"], ["MATLAB"], ["Multimedia_Messaging_Service", "Delaunay_triangulation"], ["MATLAB"], ["Piecewise_linear_manifold"], ["Topological_space"], ["Surface-mount_technology", "Stratified_Morse_theory"], ["Surface-mount_technology"], ["Marching_cubes"], ["Simplicity", "Computer_simulation", "Multimedia_Messaging_Service"], ["Topological_space"], ["Simultaneous_multithreading"], ["Simultaneous_multithreading", "Euler_characteristic", "Stratified_Morse_theory"], ["Simultaneous_multithreading"], ["Simultaneous_multithreading", "Digital_television"], ["Simultaneous_multithreading", "Nintendo_DS"], ["Simultaneous_multithreading", "Digital_television", "Betti_number"], ["Topological_space"], ["Ruppert's_algorithm", "VTK", "Marching_cubes"], ["Stratified_Morse_theory", "Topological_property"], ["Pragmatism", "Ontario", "Marching_cubes"], ["Piecewise_linear_manifold", "Marching_cubes"], ["Marching_cubes"], ["Executable"], ["Marching_cubes"], ["Marching_cubes"], ["Asymptotic_decider", "Marching_cubes"], ["Marching_cubes"], ["Asymptotic_decider", "Marching_cubes"], ["Marching_cubes"], ["Voronoi_diagram", "Washington,_D.C.", "Delaunay_triangulation", "Marching_cubes", "Dimension"], ["Marching_cubes"], ["Euclidean_space"], ["Marching_cubes"], ["Asymptotic_decider", "Marching_cubes"], ["British_Columbia", "Asymptotic_decider"], ["Asymptotic_decider"], ["C0_and_C1_control_codes", "D1"], ["British_Columbia"], ["British_Columbia", "C0_and_C1_control_codes"], ["Marching_cubes"], ["Euler_characteristic", "Betti_number", "Sadomasochism"], ["VTK", "Marching_cubes"], ["BDSM"], ["Algorithm"], ["Marching_cubes"], ["Marching_cubes", "Algorithm"], ["Algorithm"], ["VTK", "Marching_cubes"], ["VTK", "Marching_cubes"], ["Marching_cubes"], ["Algorithm", "Volume_rendering"], ["Holotype", "Bernhard_Riemann"], ["Bernhard_Riemann"], ["Voreen", "VTK"], ["VTK", "Interpolation"], ["CT_scan"], ["Order_of_accuracy"], ["Discretization"], ["Derivative", "C_(programming_language)", "Temperature"], ["Norm_(mathematics)", "Lp_space"], ["Derivative", "World_War_II", "Foreach_loop"], ["Derivative"], ["World_War_II"], ["Algorithm"], ["Voreen", "VTK"], ["Algorithm"], ["VTK", "Floating_point"], ["Graphics_processing_unit", "Voreen", "VTK", "Nrrd"], ["Voreen", "VTK"], ["Voreen", "VTK"], ["Derivative", "Lp_space", "World_War_II"], ["Voreen", "VTK"], ["Pixel"], ["Voreen"], ["Voreen", "OpenGL"], ["Voreen", "OpenGL"], ["Voreen", "VTK"], ["Software_testing"], ["Software_bug", "VTK"], ["VTK"], ["Nyquist_rate"], ["Scientific_visualization", "Flow_visualization"], ["Institute_of_Electrical_and_Electronics_Engineers", "AIAA_Journal", "Computer_graphics", "American_Institute_of_Aeronautics_and_Astronautics", "Scientific_visualization"], ["Uncertainty_quantification", "Line_integral_convolution", "Tecplot", "Scientific_visualization", "American_Institute_of_Aeronautics_and_Astronautics", "ParaView"], ["Flow_visualization"], ["3D_computer_graphics", "2D_computer_graphics", "American_Institute_of_Aeronautics_and_Astronautics", "Scientific_visualization"], ["Streamlines,_streaklines,_and_pathlines"], ["The_Technique"], ["3D_computer_graphics"], ["Geometry"], ["Geometry", "3D_computer_graphics", "Line_integral_convolution", "Streamlines,_streaklines,_and_pathlines", "Surface"], ["Lagrangian_(field_theory)", "2D_computer_graphics", "3D_computer_graphics"], ["3D_computer_graphics", "2D_computer_graphics", "Line_integral_convolution"], ["Scientific_visualization"], ["AIAA_Journal", "3D_computer_graphics", "2D_computer_graphics", "Particle_system"], ["2D_computer_graphics", "3D_computer_graphics", "Tecplot", "Scientific_visualization", "American_Institute_of_Aeronautics_and_Astronautics", "ParaView"], ["Perception"], ["2D_computer_graphics"], ["Color", "Perception"], ["Computer_graphics", "Borland", "Considered_harmful", "Color", "Scientific_visualization", "Institute_of_Electrical_and_Electronics_Engineers", "ParaView", "AIAA_Journal"], ["American_Institute_of_Aeronautics_and_Astronautics"], ["Institute_of_Electrical_and_Electronics_Engineers", "Scientific_visualization"], ["Grid_computing", "2D_computer_graphics", "Euclidean_vector"], ["American_Institute_of_Aeronautics_and_Astronautics", "Scientific_visualization"], ["American_Institute_of_Aeronautics_and_Astronautics"], ["American_Institute_of_Aeronautics_and_Astronautics"], ["Normal_distribution", "2D_computer_graphics", "Massachusetts", "Euclidean_vector"], ["Scientific_visualization"], ["Institute_of_Electrical_and_Electronics_Engineers", "American_Institute_of_Aeronautics_and_Astronautics"], ["VTK", "American_Institute_of_Aeronautics_and_Astronautics", "Partial_differential_equation"], ["American_Institute_of_Aeronautics_and_Astronautics", "Scientific_visualization"], ["American_Institute_of_Aeronautics_and_Astronautics", "Scientific_visualization"], ["Science", "Engineering", "Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service", "Leonhard_Euler"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service"], ["Multimedia_Messaging_Service"], ["National_Institute_of_Standards_and_Technology"], ["Institute_of_Electrical_and_Electronics_Engineers", "Visualization_(computer_graphics)", "Multimedia_Messaging_Service", "COMMON"]], "characters": [{"name": "Surface-mount technology", "offsets": [84165, 84692], "paragraph_occurrences": [200, 201], "sentence_occurrences": [685, 688], "affiliation": "light", "frequency": 2, "id": "Surface-mount_technology"}, {"name": "Gaussian curvature", "offsets": [34059, 34103, 41507], "paragraph_occurrences": [89, 89, 103], "sentence_occurrences": [279, 279, 339], "affiliation": "light", "frequency": 3, "id": "Gaussian_curvature"}, {"name": "Flow visualization", "offsets": [16811, 171655, 174133], "paragraph_occurrences": [36, 387, 390], "sentence_occurrences": [130, 1446, 1463], "affiliation": "light", "frequency": 3, "id": "Flow_visualization"}, {"name": "Grid computing", "offsets": [195464], "paragraph_occurrences": [417], "sentence_occurrences": [1638], "affiliation": "light", "frequency": 1, "id": "Grid_computing"}, {"name": "Asymptotic decider", "offsets": [101788, 102574, 107507, 108243, 109046, 109155], "paragraph_occurrences": [233, 235, 244, 245, 247, 247], "sentence_occurrences": [835, 841, 884, 889, 895, 896], "affiliation": "light", "frequency": 6, "id": "Asymptotic_decider"}, {"name": "Newton's law of universal gravitation", "offsets": [6093], "paragraph_occurrences": [8], "sentence_occurrences": [45], "affiliation": "light", "frequency": 1, "id": "Newton's_law_of_universal_gravitation"}, {"name": "William Forsell Kirby", "offsets": [19179], "paragraph_occurrences": [46], "sentence_occurrences": [150], "affiliation": "light", "frequency": 1, "id": "William_Forsell_Kirby"}, {"name": "Computational fluid dynamics", "offsets": [8076], "paragraph_occurrences": [9], "sentence_occurrences": [57], "affiliation": "light", "frequency": 1, "id": "Computational_fluid_dynamics"}, {"name": "Pixel", "offsets": [160092], "paragraph_occurrences": [366], "sentence_occurrences": [1350], "affiliation": "light", "frequency": 1, "id": "Pixel"}, {"name": "Simplicity", "offsets": [87004], "paragraph_occurrences": [205], "sentence_occurrences": [707], "affiliation": "light", "frequency": 1, "id": "Simplicity"}, {"name": "Norm", "offsets": [149274], "paragraph_occurrences": [332], "sentence_occurrences": [1247], "affiliation": "light", "frequency": 1, "id": "Norm_(mathematics)"}, {"name": "Graphics processing unit", "offsets": [152908], "paragraph_occurrences": [347], "sentence_occurrences": [1279], "affiliation": "light", "frequency": 1, "id": "Graphics_processing_unit"}, {"name": "OpenGL", "offsets": [160966, 161073], "paragraph_occurrences": [369, 370], "sentence_occurrences": [1361, 1363], "affiliation": "light", "frequency": 2, "id": "OpenGL"}, {"name": "Karl Popper", "offsets": [4772], "paragraph_occurrences": [6], "sentence_occurrences": [35], "affiliation": "light", "frequency": 1, "id": "Karl_Popper"}, {"name": "Floating point", "offsets": [152393, 152543, 152787], "paragraph_occurrences": [345, 345, 345], "sentence_occurrences": [1273, 1274, 1277], "affiliation": "light", "frequency": 3, "id": "Floating_point"}, {"name": "The Logic of Scientific Discovery", "offsets": [4794], "paragraph_occurrences": [6], "sentence_occurrences": [35], "affiliation": "light", "frequency": 1, "id": "The_Logic_of_Scientific_Discovery"}, {"name": "C", "offsets": [148513], "paragraph_occurrences": [331], "sentence_occurrences": [1242], "affiliation": "light", "frequency": 1, "id": "C_(programming_language)"}, {"name": "American Institute of Aeronautics and Astronautics", "offsets": [172278, 172937, 174256, 175020, 186779, 187402, 193641, 196314, 197568, 198564, 199765, 200421, 200457, 200702, 201523, 202763, 203033, 203407, 204486], "paragraph_occurrences": [388, 389, 391, 391, 408, 408, 414, 419, 421, 422, 427, 427, 427, 427, 428, 429, 429, 431, 431], "sentence_occurrences": [1452, 1455, 1464, 1468, 1566, 1570, 1623, 1644, 1654, 1661, 1675, 1678, 1678, 1680, 1684, 1692, 1692, 1696, 1702], "affiliation": "light", "frequency": 19, "id": "American_Institute_of_Aeronautics_and_Astronautics"}, {"name": "COMMON", "offsets": [210442], "paragraph_occurrences": [445], "sentence_occurrences": [1748], "affiliation": "light", "frequency": 1, "id": "COMMON"}, {"name": "Line integral convolution", "offsets": [173068, 179962, 182230, 182257], "paragraph_occurrences": [389, 400, 404, 404], "sentence_occurrences": [1456, 1516, 1536, 1537], "affiliation": "light", "frequency": 4, "id": "Line_integral_convolution"}, {"name": "Particle system", "offsets": [183974], "paragraph_occurrences": [407], "sentence_occurrences": [1549], "affiliation": "light", "frequency": 1, "id": "Particle_system"}, {"name": "Arthur Stanley Eddington", "offsets": [5859, 6000], "paragraph_occurrences": [8, 8], "sentence_occurrences": [42, 44], "affiliation": "light", "frequency": 2, "id": "Arthur_Eddington"}, {"name": "Correctness", "offsets": [15826], "paragraph_occurrences": [28], "sentence_occurrences": [118], "affiliation": "light", "frequency": 1, "id": "Correctness_(computer_science)"}, {"name": "Nrrd", "offsets": [153285, 153308], "paragraph_occurrences": [347, 347], "sentence_occurrences": [1282, 1282], "affiliation": "light", "frequency": 2, "id": "Nrrd"}, {"name": "Volume rendering", "offsets": [16339, 135777], "paragraph_occurrences": [32, 310], "sentence_occurrences": [124, 1142], "affiliation": "light", "frequency": 2, "id": "Volume_rendering"}, {"name": "Taylor series", "offsets": [21954, 24028], "paragraph_occurrences": [51, 54], "sentence_occurrences": [170, 187], "affiliation": "light", "frequency": 2, "id": "Taylor_series"}, {"name": "Euclidean space", "offsets": [58473, 106500], "paragraph_occurrences": [141, 240], "sentence_occurrences": [474, 877], "affiliation": "light", "frequency": 2, "id": "Euclidean_space"}, {"name": "Formal verification", "offsets": [50329], "paragraph_occurrences": [128], "sentence_occurrences": [412], "affiliation": "light", "frequency": 1, "id": "Formal_verification"}, {"name": "2D computer graphics", "offsets": [65253, 174742, 180247, 181770, 182198, 183701, 183722, 184055, 184151, 184493, 186221, 188912, 194557, 198804], "paragraph_occurrences": [155, 391, 402, 402, 404, 407, 407, 407, 407, 407, 408, 410, 417, 423], "sentence_occurrences": [526, 1467, 1519, 1531, 1536, 1548, 1548, 1550, 1550, 1552, 1564, 1578, 1631, 1664], "affiliation": "light", "frequency": 14, "id": "2D_computer_graphics"}, {"name": "Limit of a sequence", "offsets": [22423, 23352, 24101, 24306, 25296], "paragraph_occurrences": [52, 53, 55, 57, 60], "sentence_occurrences": [174, 182, 188, 190, 199], "affiliation": "light", "frequency": 5, "id": "Limit_of_a_sequence"}, {"name": "Betti number", "offsets": [43057, 56172, 56989, 57683, 58042, 58186, 58308, 62267, 92862, 111989], "paragraph_occurrences": [107, 135, 138, 139, 139, 139, 139, 151, 216, 255], "sentence_occurrences": [351, 458, 465, 469, 471, 472, 472, 506, 761, 922], "affiliation": "light", "frequency": 10, "id": "Betti_number"}, {"name": "Rapid transit", "offsets": [18761], "paragraph_occurrences": [44], "sentence_occurrences": [147], "affiliation": "light", "frequency": 1, "id": "Rapid_transit"}, {"name": "Computed tomography", "offsets": [142283], "paragraph_occurrences": [320], "sentence_occurrences": [1186], "affiliation": "light", "frequency": 1, "id": "CT_scan"}, {"name": "IEEE Standards Association", "offsets": [8867], "paragraph_occurrences": [11], "sentence_occurrences": [64], "affiliation": "light", "frequency": 1, "id": "IEEE_Standards_Association"}, {"name": "Sun", "offsets": [5955], "paragraph_occurrences": [8], "sentence_occurrences": [43], "affiliation": "light", "frequency": 1, "id": "Sun"}, {"name": "Computer simulation", "offsets": [8830, 86990], "paragraph_occurrences": [11, 205], "sentence_occurrences": [63, 707], "affiliation": "light", "frequency": 2, "id": "Computer_simulation"}, {"name": "Video game", "offsets": [59742, 59815, 59860, 59933, 60172, 60746], "paragraph_occurrences": [146, 146, 146, 146, 146, 147], "sentence_occurrences": [485, 486, 486, 486, 487, 492], "affiliation": "light", "frequency": 6, "id": "Video_game"}, {"name": "Digital television", "offsets": [91251, 93599, 93993], "paragraph_occurrences": [213, 216, 216], "sentence_occurrences": [747, 767, 769], "affiliation": "light", "frequency": 3, "id": "Digital_television"}, {"name": "Surface", "offsets": [179546], "paragraph_occurrences": [400], "sentence_occurrences": [1514], "affiliation": "light", "frequency": 1, "id": "Surface"}, {"name": "Ruppert's algorithm", "offsets": [94569], "paragraph_occurrences": [218], "sentence_occurrences": [773], "affiliation": "light", "frequency": 1, "id": "Ruppert's_algorithm"}, {"name": "Bernhard Riemann", "offsets": [137606, 139089], "paragraph_occurrences": [312, 313], "sentence_occurrences": [1150, 1161], "affiliation": "light", "frequency": 2, "id": "Bernhard_Riemann"}, {"name": "Michigan", "offsets": [61069, 73286], "paragraph_occurrences": [148, 175], "sentence_occurrences": [496, 589], "affiliation": "light", "frequency": 2, "id": "Michigan"}, {"name": "Delaunay triangulation", "offsets": [30645, 78243, 78301, 81369, 104566], "paragraph_occurrences": [77, 186, 186, 192, 237], "sentence_occurrences": [243, 634, 635, 662, 860], "affiliation": "light", "frequency": 5, "id": "Delaunay_triangulation"}, {"name": "Massachusetts", "offsets": [199192], "paragraph_occurrences": [423], "sentence_occurrences": [1670], "affiliation": "light", "frequency": 1, "id": "Massachusetts"}, {"name": "Algorithm", "offsets": [16356, 20524, 72962, 73499, 74451, 74628, 126978, 131438, 131450, 135794, 151478, 152057], "paragraph_occurrences": [32, 49, 173, 175, 176, 176, 287, 301, 302, 310, 338, 342], "sentence_occurrences": [124, 159, 584, 591, 598, 600, 1054, 1102, 1103, 1142, 1263, 1268], "affiliation": "light", "frequency": 12, "id": "Algorithm"}, {"name": "Foreach loop", "offsets": [7219, 149585], "paragraph_occurrences": [9, 333], "sentence_occurrences": [51, 1249], "affiliation": "light", "frequency": 2, "id": "Foreach_loop"}, {"name": "Contour plowing", "offsets": [29027, 29476, 31521, 32987, 33663, 34553, 34749, 34920], "paragraph_occurrences": [73, 73, 81, 85, 87, 89, 91, 91], "sentence_occurrences": [230, 232, 250, 265, 274, 285, 287, 289], "affiliation": "light", "frequency": 8, "id": "Contour_plowing"}, {"name": "Dimension", "offsets": [78177, 78360, 104646], "paragraph_occurrences": [186, 186, 237], "sentence_occurrences": [634, 635, 860], "affiliation": "light", "frequency": 3, "id": "Dimension"}, {"name": "Simultaneous multithreading", "offsets": [88534, 88987, 89146, 89735, 89927, 91108, 91866, 92145, 92305, 93667, 93985], "paragraph_occurrences": [209, 210, 210, 210, 211, 213, 214, 214, 214, 216, 216], "sentence_occurrences": [719, 724, 725, 729, 731, 745, 753, 755, 755, 767, 769], "affiliation": "light", "frequency": 11, "id": "Simultaneous_multithreading"}, {"name": "World War II", "offsets": [149600, 149682, 150717, 156234, 156263, 156319, 156417], "paragraph_occurrences": [333, 333, 336, 354, 354, 354, 354], "sentence_occurrences": [1249, 1249, 1258, 1310, 1310, 1310, 1311], "affiliation": "light", "frequency": 7, "id": "World_War_II"}, {"name": "Streamlines, streaklines, and pathlines", "offsets": [175928, 178829], "paragraph_occurrences": [394, 400], "sentence_occurrences": [1475, 1506], "affiliation": "light", "frequency": 2, "id": "Streamlines,_streaklines,_and_pathlines"}, {"name": "Uncertainty quantification", "offsets": [173844], "paragraph_occurrences": [389], "sentence_occurrences": [1460], "affiliation": "light", "frequency": 1, "id": "Uncertainty_quantification"}, {"name": "Washington, D.C.", "offsets": [103984, 104211, 104273, 104348], "paragraph_occurrences": [237, 237, 237, 237], "sentence_occurrences": [854, 856, 857, 858], "affiliation": "light", "frequency": 4, "id": "Washington,_D.C."}, {"name": "ALGO", "offsets": [74623], "paragraph_occurrences": [176], "sentence_occurrences": [600], "affiliation": "light", "frequency": 1, "id": "ALGO"}, {"name": "Brazil", "offsets": [9389], "paragraph_occurrences": [12], "sentence_occurrences": [68], "affiliation": "light", "frequency": 1, "id": "Brazil"}, {"name": "Ontario", "offsets": [97163], "paragraph_occurrences": [223], "sentence_occurrences": [793], "affiliation": "light", "frequency": 1, "id": "Ontario"}, {"name": "Temperature", "offsets": [148419, 148737], "paragraph_occurrences": [331, 331], "sentence_occurrences": [1242, 1243], "affiliation": "light", "frequency": 2, "id": "Temperature"}, {"name": "Hessian matrix", "offsets": [63515], "paragraph_occurrences": [153], "sentence_occurrences": [514], "affiliation": "light", "frequency": 1, "id": "Hessian_matrix"}, {"name": "Newton", "offsets": [6589], "paragraph_occurrences": [8], "sentence_occurrences": [48], "affiliation": "light", "frequency": 1, "id": "Newton_(unit)"}, {"name": "Pragmatism", "offsets": [97138], "paragraph_occurrences": [223], "sentence_occurrences": [793], "affiliation": "light", "frequency": 1, "id": "Pragmatism"}, {"name": "ParaView", "offsets": [172984, 185398, 191788], "paragraph_occurrences": [389, 408, 413], "sentence_occurrences": [1456, 1558, 1605], "affiliation": "light", "frequency": 3, "id": "ParaView"}, {"name": "Multimedia Messaging Service", "offsets": [20469, 20517, 20895, 26168, 35918, 36583, 36991, 37143, 37183, 37327, 38524, 40291, 40806, 41941, 42242, 42854, 45751, 45883, 51026, 51165, 74690, 80194, 86483, 205034, 205235, 206749, 206974, 207488, 208007, 208228, 208380, 210636], "paragraph_occurrences": [49, 49, 50, 63, 92, 95, 95, 97, 97, 97, 97, 100, 102, 104, 105, 107, 113, 113, 129, 129, 177, 192, 205, 433, 435, 436, 437, 437, 439, 439, 439, 445], "sentence_occurrences": [158, 159, 162, 205, 297, 304, 306, 308, 308, 310, 317, 329, 334, 343, 346, 350, 371, 372, 417, 418, 601, 656, 703, 1707, 1709, 1720, 1721, 1724, 1729, 1731, 1732, 1749], "affiliation": "light", "frequency": 32, "id": "Multimedia_Messaging_Service"}, {"name": "Cartesian coordinate system", "offsets": [27521, 69587, 69728], "paragraph_occurrences": [67, 162, 163], "sentence_occurrences": [216, 560, 561], "affiliation": "light", "frequency": 3, "id": "Cartesian_coordinate_system"}, {"name": "Mark Goresky", "offsets": [56735, 62758], "paragraph_occurrences": [137, 151], "sentence_occurrences": [464, 509], "affiliation": "light", "frequency": 2, "id": "Mark_Goresky"}, {"name": "Perception", "offsets": [187564, 188949], "paragraph_occurrences": [409, 411], "sentence_occurrences": [1571, 1579], "affiliation": "light", "frequency": 2, "id": "Perception"}, {"name": "Digital topology", "offsets": [15331], "paragraph_occurrences": [25], "sentence_occurrences": [114], "affiliation": "light", "frequency": 1, "id": "Digital_topology"}, {"name": "Computational science", "offsets": [867, 8182, 8810, 8851], "paragraph_occurrences": [1, 9, 11, 11], "sentence_occurrences": [7, 58, 63, 64], "affiliation": "light", "frequency": 4, "id": "Computational_science"}, {"name": "Curvature", "offsets": [25562], "paragraph_occurrences": [62], "sentence_occurrences": [201], "affiliation": "light", "frequency": 1, "id": "Curvature"}, {"name": "Pasting lemma", "offsets": [61679], "paragraph_occurrences": [148], "sentence_occurrences": [501], "affiliation": "light", "frequency": 1, "id": "Pasting_lemma"}, {"name": "Vertex", "offsets": [41484], "paragraph_occurrences": [103], "sentence_occurrences": [338], "affiliation": "light", "frequency": 1, "id": "Vertex_(geometry)"}, {"name": "Voreen", "offsets": [139665, 151634, 152866, 153018, 153108, 153449, 155978, 156040, 156723, 160244, 160779, 160896, 161331, 161512, 161909, 163970], "paragraph_occurrences": [315, 340, 347, 347, 347, 349, 353, 353, 357, 368, 369, 369, 370, 370, 370, 373], "sentence_occurrences": [1163, 1265, 1279, 1280, 1280, 1284, 1308, 1309, 1315, 1356, 1360, 1361, 1364, 1366, 1368, 1386], "affiliation": "light", "frequency": 16, "id": "Voreen"}, {"name": "Stratified Morse theory", "offsets": [1308, 15529, 46157, 46715, 56612, 56795, 57107, 62697, 83685, 88920, 96421], "paragraph_occurrences": [1, 26, 114, 118, 137, 137, 138, 151, 200, 210, 222], "sentence_occurrences": [10, 115, 374, 382, 462, 464, 466, 509, 683, 723, 788], "affiliation": "light", "frequency": 11, "id": "Stratified_Morse_theory"}, {"name": "Nintendo DS", "offsets": [91874, 91990, 92153, 92281], "paragraph_occurrences": [214, 214, 214, 214], "sentence_occurrences": [753, 754, 755, 755], "affiliation": "light", "frequency": 4, "id": "Nintendo_DS"}, {"name": "MATLAB", "offsets": [76525, 76752, 80048, 82461, 82835], "paragraph_occurrences": [182, 183, 190, 196, 196], "sentence_occurrences": [618, 621, 653, 671, 674], "affiliation": "light", "frequency": 5, "id": "MATLAB"}, {"name": "British Columbia", "offsets": [108618, 110436, 110596], "paragraph_occurrences": [245, 250, 252], "sentence_occurrences": [891, 906, 908], "affiliation": "light", "frequency": 3, "id": "British_Columbia"}, {"name": "Topology", "offsets": [15138], "paragraph_occurrences": [23], "sentence_occurrences": [112], "affiliation": "light", "frequency": 1, "id": "Topology"}, {"name": "Morse theory", "offsets": [62185, 67492, 62895, 64051, 64119, 65466, 65696, 68950, 72743, 70655], "paragraph_occurrences": [150, 157, 152, 154, 154, 155, 156, 162, 172, 166], "sentence_occurrences": [505, 539, 511, 517, 518, 528, 529, 554, 582, 567], "affiliation": "light", "frequency": 10, "id": "Morse_theory"}, {"name": "Geometry", "offsets": [14215, 17144, 178082, 178597], "paragraph_occurrences": [18, 40, 399, 400], "sentence_occurrences": [104, 134, 1500, 1504], "affiliation": "light", "frequency": 4, "id": "Geometry"}, {"name": "Computational topology", "offsets": [51784], "paragraph_occurrences": [130], "sentence_occurrences": [423], "affiliation": "light", "frequency": 1, "id": "Computational_topology"}, {"name": "VTK", "offsets": [26814, 27135, 31477, 32800, 32908, 33376, 34337, 75141, 76389, 95319, 95501, 113296, 131852, 131893, 132541, 132725, 133063, 133175, 133292, 139651, 141350, 151626, 152202, 152726, 152861, 153430, 155845, 156715, 163698, 165342, 166501, 166787, 201920], "paragraph_occurrences": [65, 66, 81, 85, 85, 87, 89, 180, 182, 218, 218, 257, 304, 304, 304, 305, 305, 305, 305, 315, 319, 340, 345, 345, 347, 349, 353, 357, 373, 376, 377, 377, 428], "sentence_occurrences": [210, 213, 250, 263, 264, 270, 283, 606, 618, 778, 779, 933, 1107, 1108, 1113, 1115, 1118, 1120, 1121, 1163, 1179, 1265, 1272, 1277, 1279, 1284, 1307, 1315, 1385, 1396, 1406, 1406, 1686], "affiliation": "light", "frequency": 33, "id": "VTK"}, {"name": "Scientific visualization", "offsets": [171642, 172032, 172301, 172438, 172907, 173363, 173770, 173813, 174238, 174950, 183377, 187411, 192264, 192427, 193853, 196470, 199507, 202798, 203088, 203360, 203744, 204533], "paragraph_occurrences": [387, 388, 388, 388, 389, 389, 389, 389, 391, 391, 406, 408, 413, 413, 416, 419, 424, 429, 429, 431, 431, 431], "sentence_occurrences": [1446, 1449, 1452, 1453, 1455, 1458, 1460, 1460, 1464, 1468, 1544, 1570, 1609, 1610, 1625, 1645, 1672, 1692, 1692, 1696, 1698, 1702], "affiliation": "light", "frequency": 22, "id": "Scientific_visualization"}, {"name": "Lagrangian (field theory)", "offsets": [181266, 181479], "paragraph_occurrences": [402, 402], "sentence_occurrences": [1527, 1529], "affiliation": "light", "frequency": 2, "id": "Lagrangian_(field_theory)"}, {"name": "Order of accuracy", "offsets": [143370], "paragraph_occurrences": [322], "sentence_occurrences": [1190], "affiliation": "light", "frequency": 1, "id": "Order_of_accuracy"}, {"name": "Sadomasochism", "offsets": [112180], "paragraph_occurrences": [255], "sentence_occurrences": [924], "affiliation": "light", "frequency": 1, "id": "Sadomasochism"}, {"name": "Computer Science", "offsets": [8222, 8792, 12129], "paragraph_occurrences": [9, 11, 14], "sentence_occurrences": [58, 63, 87], "affiliation": "light", "frequency": 3, "id": "Computer_science"}, {"name": "Discretization", "offsets": [146209], "paragraph_occurrences": [325], "sentence_occurrences": [1219], "affiliation": "light", "frequency": 1, "id": "Discretization"}, {"name": "Voronoi diagram", "offsets": [30678, 60004, 78180, 78363, 104649], "paragraph_occurrences": [77, 146, 186, 186, 237], "sentence_occurrences": [243, 487, 634, 635, 860], "affiliation": "light", "frequency": 5, "id": "Voronoi_diagram"}, {"name": "Tecplot", "offsets": [172968, 185410], "paragraph_occurrences": [389, 408], "sentence_occurrences": [1456, 1558], "affiliation": "light", "frequency": 2, "id": "Tecplot"}, {"name": "IEEE Fellow", "offsets": [172413, 192255, 192402, 194081, 194002, 200605, 210460, 210538], "paragraph_occurrences": [388, 413, 413, 416, 416, 427, 445, 445], "sentence_occurrences": [1453, 1609, 1610, 1626, 1625, 1679, 1748, 1748], "affiliation": "light", "frequency": 8, "id": "Institute_of_Electrical_and_Electronics_Engineers"}, {"name": "Normal distribution", "offsets": [199068], "paragraph_occurrences": [423], "sentence_occurrences": [1669], "affiliation": "light", "frequency": 1, "id": "Normal_distribution"}, {"name": "Engineering", "offsets": [891, 8206, 205097], "paragraph_occurrences": [1, 9, 433], "sentence_occurrences": [7, 58, 1707], "affiliation": "light", "frequency": 3, "id": "Engineering"}, {"name": "Holotype", "offsets": [138024, 138272], "paragraph_occurrences": [312, 312], "sentence_occurrences": [1152, 1153], "affiliation": "light", "frequency": 2, "id": "Holotype"}, {"name": "Marching cubes", "offsets": [1893, 15841, 15890, 26818, 27915, 28502, 28623, 27175, 28181, 29218, 29391, 29535, 29697, 31481, 32804, 32912, 33380, 34341, 38834, 47888, 48187, 48327, 52517, 53264, 53396, 53524, 54490, 55190, 75191, 75519, 76881, 76959, 77490, 78892, 85949, 86219, 95323, 97197, 97719, 97819, 101354, 101603, 101672, 102026, 102463, 103806, 103953, 106777, 97781, 99163, 99990, 100939, 106064, 107440, 107647, 111229, 113928, 130434, 131250, 131365, 131856, 132747, 135402], "paragraph_occurrences": [1, 28, 29, 65, 69, 71, 71, 67, 69, 73, 73, 73, 73, 81, 85, 85, 87, 89, 97, 125, 125, 126, 132, 134, 134, 134, 134, 134, 180, 180, 183, 184, 185, 187, 203, 203, 218, 223, 224, 224, 233, 233, 233, 234, 235, 236, 237, 241, 224, 225, 227, 231, 238, 244, 244, 253, 257, 294, 301, 301, 304, 305, 309], "sentence_occurrences": [15, 118, 119, 210, 219, 225, 226, 214, 222, 231, 231, 232, 232, 250, 263, 264, 271, 283, 319, 393, 394, 396, 429, 438, 439, 440, 447, 452, 606, 609, 621, 622, 627, 642, 698, 700, 778, 793, 797, 798, 831, 833, 834, 837, 840, 852, 853, 880, 797, 810, 817, 826, 873, 884, 884, 913, 939, 1090, 1101, 1102, 1107, 1115, 1139], "affiliation": "light", "frequency": 63, "id": "Marching_cubes"}, {"name": "Software bug", "offsets": [166221], "paragraph_occurrences": [376], "sentence_occurrences": [1403], "affiliation": "light", "frequency": 1, "id": "Software_bug"}, {"name": "Lp space", "offsets": [32644, 34033, 149321, 156145], "paragraph_occurrences": [85, 89, 332, 354], "sentence_occurrences": [263, 279, 1248, 1310], "affiliation": "light", "frequency": 4, "id": "Lp_space"}, {"name": "Isosurface", "offsets": [14227, 15150, 17156, 20294, 43848, 52272], "paragraph_occurrences": [18, 23, 40, 48, 110, 131], "sentence_occurrences": [104, 112, 134, 157, 357, 426], "affiliation": "light", "frequency": 6, "id": "Isosurface"}, {"name": "Executable", "offsets": [99578], "paragraph_occurrences": [226], "sentence_occurrences": [813], "affiliation": "light", "frequency": 1, "id": "Executable"}, {"name": "Topological space", "offsets": [43836, 79814, 83177, 87470, 94261], "paragraph_occurrences": [110, 189, 199, 206, 217], "sentence_occurrences": [357, 651, 679, 710, 771], "affiliation": "light", "frequency": 5, "id": "Topological_space"}, {"name": "Borland", "offsets": [191960], "paragraph_occurrences": [413], "sentence_occurrences": [1606], "affiliation": "light", "frequency": 1, "id": "Borland"}, {"name": "Considered harmful", "offsets": [191932], "paragraph_occurrences": [413], "sentence_occurrences": [1606], "affiliation": "light", "frequency": 1, "id": "Considered_harmful"}, {"name": "C0 and C1 control codes", "offsets": [109441, 109461, 109510, 109583, 109715, 109838, 110674], "paragraph_occurrences": [248, 248, 248, 248, 248, 248, 252], "sentence_occurrences": [898, 898, 899, 900, 901, 902, 909], "affiliation": "light", "frequency": 7, "id": "C0_and_C1_control_codes"}, {"name": "Euclidean vector", "offsets": [195921, 199332], "paragraph_occurrences": [417, 423], "sentence_occurrences": [1640, 1670], "affiliation": "light", "frequency": 2, "id": "Euclidean_vector"}, {"name": "Derivative", "offsets": [148049, 149672, 149982, 156427], "paragraph_occurrences": [331, 333, 334, 354], "sentence_occurrences": [1240, 1249, 1252, 1311], "affiliation": "light", "frequency": 4, "id": "Derivative"}, {"name": "AIAA Journal", "offsets": [172396, 183457, 192539], "paragraph_occurrences": [388, 407, 413], "sentence_occurrences": [1453, 1546, 1611], "affiliation": "light", "frequency": 3, "id": "AIAA_Journal"}, {"name": "Visualization", "offsets": [210416], "paragraph_occurrences": [445], "sentence_occurrences": [1748], "affiliation": "light", "frequency": 1, "id": "Visualization_(computer_graphics)"}, {"name": "The Technique", "offsets": [176710], "paragraph_occurrences": [396], "sentence_occurrences": [1483], "affiliation": "light", "frequency": 1, "id": "The_Technique"}, {"name": "Software Testing", "offsets": [164143], "paragraph_occurrences": [374], "sentence_occurrences": [1388], "affiliation": "light", "frequency": 1, "id": "Software_testing"}, {"name": "Marvel Comics", "offsets": [39227, 47910, 50408], "paragraph_occurrences": [99, 125, 129], "sentence_occurrences": [323, 393, 413], "affiliation": "light", "frequency": 3, "id": "Marvel_Comics"}, {"name": "Probability of kill", "offsets": [25389], "paragraph_occurrences": [61], "sentence_occurrences": [200], "affiliation": "light", "frequency": 1, "id": "Probability_of_kill"}, {"name": "Computer graphics (images)", "offsets": [172456, 192445], "paragraph_occurrences": [388, 413], "sentence_occurrences": [1453, 1610], "affiliation": "light", "frequency": 2, "id": "Computer_graphics"}, {"name": "3D computer graphics", "offsets": [30675, 174756, 177769, 178062, 179912, 181777, 182739, 184127, 184158, 184190, 184536, 184667, 185011, 185964, 187239], "paragraph_occurrences": [77, 391, 398, 398, 400, 402, 404, 407, 407, 407, 407, 407, 408, 408, 408], "sentence_occurrences": [243, 1467, 1498, 1499, 1516, 1531, 1539, 1550, 1550, 1550, 1552, 1553, 1556, 1562, 1569], "affiliation": "light", "frequency": 15, "id": "3D_computer_graphics"}, {"name": "Verification and validation", "offsets": [43826], "paragraph_occurrences": [110], "sentence_occurrences": [357], "affiliation": "light", "frequency": 1, "id": "Verification_and_validation"}, {"name": "Homeomorphism", "offsets": [48932], "paragraph_occurrences": [126], "sentence_occurrences": [400], "affiliation": "light", "frequency": 1, "id": "Homeomorphism"}, {"name": "Fluid dynamics", "offsets": [8146], "paragraph_occurrences": [9], "sentence_occurrences": [57], "affiliation": "light", "frequency": 1, "id": "Fluid_dynamics"}, {"name": "Hyades", "offsets": [6027], "paragraph_occurrences": [8], "sentence_occurrences": [44], "affiliation": "light", "frequency": 1, "id": "Hyades_(star_cluster)"}, {"name": "Science", "offsets": [205087], "paragraph_occurrences": [433], "sentence_occurrences": [1707], "affiliation": "light", "frequency": 1, "id": "Science"}, {"name": "Sobral", "offsets": [9372, 9778], "paragraph_occurrences": [12, 12], "sentence_occurrences": [68, 71], "affiliation": "light", "frequency": 2, "id": "Sobral,_Cear\u00e1"}, {"name": "Interpolation", "offsets": [141036], "paragraph_occurrences": [319], "sentence_occurrences": [1176], "affiliation": "light", "frequency": 1, "id": "Interpolation"}, {"name": "Piecewise linear manifold", "offsets": [54534, 54696, 54949, 55335, 72023, 72540, 83086, 97439, 97562], "paragraph_occurrences": [134, 134, 134, 134, 171, 171, 198, 224, 224], "sentence_occurrences": [447, 448, 450, 452, 578, 580, 678, 795, 796], "affiliation": "light", "frequency": 9, "id": "Piecewise_linear_manifold"}, {"name": "Partial differential equation", "offsets": [11342, 202214], "paragraph_occurrences": [13, 428], "sentence_occurrences": [82, 1687], "affiliation": "light", "frequency": 2, "id": "Partial_differential_equation"}, {"name": "Euler characteristic", "offsets": [43033, 46612, 56194, 56964, 57199, 57305, 57605, 58061, 58157, 58283, 63397, 66134, 67970, 68669, 69032, 70742, 71051, 89027, 89529, 111956], "paragraph_occurrences": [107, 118, 135, 138, 138, 139, 139, 139, 139, 139, 152, 156, 159, 162, 162, 166, 167, 210, 210, 255], "sentence_occurrences": [351, 381, 458, 465, 467, 468, 469, 471, 472, 472, 513, 532, 544, 551, 555, 568, 569, 724, 727, 922], "affiliation": "light", "frequency": 20, "id": "Euler_characteristic"}, {"name": "NL", "offsets": [67096, 67119, 67464, 67570], "paragraph_occurrences": [157, 157, 157, 158], "sentence_occurrences": [538, 538, 539, 540], "affiliation": "light", "frequency": 4, "id": "NL_(complexity)"}, {"name": "Scalar", "offsets": [60036, 74110], "paragraph_occurrences": [146, 175], "sentence_occurrences": [487, 596], "affiliation": "light", "frequency": 2, "id": "Scalar_(mathematics)"}, {"name": "Leonhard Euler", "offsets": [62446, 205834], "paragraph_occurrences": [151, 435], "sentence_occurrences": [508, 1714], "affiliation": "light", "frequency": 2, "id": "Leonhard_Euler"}, {"name": "National Institute of Standards and Technology", "offsets": [208596], "paragraph_occurrences": [441], "sentence_occurrences": [1735], "affiliation": "light", "frequency": 1, "id": "National_Institute_of_Standards_and_Technology"}, {"name": "Topological property", "offsets": [96738], "paragraph_occurrences": [222], "sentence_occurrences": [789], "affiliation": "light", "frequency": 1, "id": "Topological_property"}, {"name": "Monte Carlo method", "offsets": [71943, 77472, 77758], "paragraph_occurrences": [171, 185, 185], "sentence_occurrences": [578, 626, 629], "affiliation": "light", "frequency": 3, "id": "Monte_Carlo_method"}, {"name": "Nyquist rate", "offsets": [168600], "paragraph_occurrences": [381], "sentence_occurrences": [1423], "affiliation": "light", "frequency": 1, "id": "Nyquist_rate"}, {"name": "Color", "offsets": [8137, 188964, 191914], "paragraph_occurrences": [9, 411, 413], "sentence_occurrences": [57, 1579, 1606], "affiliation": "light", "frequency": 3, "id": "Color"}, {"name": "Critical point", "offsets": [68839], "paragraph_occurrences": [162], "sentence_occurrences": [553], "affiliation": "light", "frequency": 1, "id": "Critical_point_(mathematics)"}, {"name": "Submissive", "offsets": [118139], "paragraph_occurrences": [268], "sentence_occurrences": [979], "affiliation": "light", "frequency": 1, "id": "BDSM"}, {"name": "Cubic Hermite spline", "offsets": [39899], "paragraph_occurrences": [100], "sentence_occurrences": [327], "affiliation": "light", "frequency": 1, "id": "Cubic_Hermite_spline"}, {"name": "Earth", "offsets": [6212, 9611], "paragraph_occurrences": [8, 12], "sentence_occurrences": [45, 69], "affiliation": "light", "frequency": 2, "id": "Earth"}, {"name": "D1", "offsets": [109465], "paragraph_occurrences": [248], "sentence_occurrences": [898], "affiliation": "light", "frequency": 1, "id": "D1"}], "all_paragraphs": [{"paragraph_info": {"end": 8, "start": 0, "text": "ABSTRACT", "rank": 0, "paragraph_comparative_number": 1, "entities": [], "id": "p_0"}, "sentences": [{"end": 8, "text": "ABSTRACT", "rank": 0, "start": 0, "IsComparative": "1", "id": "st_0"}]}, {"paragraph_info": {"end": 2163, "start": 8, "text": "In this dissertation, we advance the theory and practice of verifying visualization algori- thms.We present techniques to assess visualization correctness through testing of impor- tant mathematical properties.Where applicable, these techniques allow us to distinguish whether anomalies in visualization features can be attributed to the underlying physical process or to artifacts from the implementation under verification.Such scientific scrutiny is at the heart of verifiable visualization  subjecting visualization algorithms to the same veri- fication process that is used in other components of the scientific pipeline.The contributions of this dissertation are manifold.We derive the mathematical framework for the expected behavior of several visualization algorithms, and compare them to experimentally observed results in the selected codes.In the Computational Science & Engineering community CS&E, this technique is know as the Method of Manufactured Solution (MMS).We apply MMS to the verification of geometrical and topological properties of isosurface extraction algorithms, and direct volume rendering.We derive the convergence of geometrical prop- erties of isosurface extraction techniques, such as function value and normals.For the verification of topological properties, we use stratified Morse theory and digital topology to design algorithms that verify topological invariants.In the case of volume rendering algorithms, we provide the expected discretization errors for three different error sources.The results of applying the MMS is another important contribution of this dissertation.We report unexpected behavior for almost all implementations tested.In some cases, we were able to find and fix bugs that prevented the correctness of the visualization algorithm.In particular, we address an almost 20-year-old bug with the core disambiguation procedure of Marching Cubes 33, one of the first algorithms intended to preserve the topology of the trilinear interpolant.Finally, an important by-product of this work is a range of responses practitioners can expect to encounter with the visualization technique under verification.", "rank": 1, "paragraph_comparative_number": 8, "entities": [], "id": "p_1"}, "sentences": [{"end": 105, "text": "In this dissertation, we advance the theory and practice of verifying visualization algori- thms.", "rank": 1, "start": 8, "IsComparative": "0", "id": "st_1"}, {"end": 218, "text": "We present techniques to assess visualization correctness through testing of impor- tant mathematical properties.", "rank": 2, "start": 105, "IsComparative": "1", "id": "st_2"}, {"end": 433, "text": "Where applicable, these techniques allow us to distinguish whether anomalies in visualization features can be attributed to the underlying physical process or to artifacts from the implementation under verification.", "rank": 3, "start": 218, "IsComparative": "1", "id": "st_3"}, {"end": 634, "text": "Such scientific scrutiny is at the heart of verifiable visualization  subjecting visualization algorithms to the same veri- fication process that is used in other components of the scientific pipeline.", "rank": 4, "start": 433, "IsComparative": "0", "id": "st_4"}, {"end": 686, "text": "The contributions of this dissertation are manifold.", "rank": 5, "start": 634, "IsComparative": "0", "id": "st_5"}, {"end": 860, "text": "We derive the mathematical framework for the expected behavior of several visualization algorithms, and compare them to experimentally observed results in the selected codes.", "rank": 6, "start": 686, "IsComparative": "1", "id": "st_6"}, {"end": 987, "text": "In the Computational Science & Engineering community CS&E, this technique is know as the Method of Manufactured Solution (MMS).", "rank": 7, "start": 860, "IsComparative": "0", "id": "st_7"}, {"end": 1127, "text": "We apply MMS to the verification of geometrical and topological properties of isosurface extraction algorithms, and direct volume rendering.", "rank": 8, "start": 987, "IsComparative": "0", "id": "st_8"}, {"end": 1253, "text": "We derive the convergence of geometrical prop- erties of isosurface extraction techniques, such as function value and normals.", "rank": 9, "start": 1127, "IsComparative": "0", "id": "st_9"}, {"end": 1409, "text": "For the verification of topological properties, we use stratified Morse theory and digital topology to design algorithms that verify topological invariants.", "rank": 10, "start": 1253, "IsComparative": "1", "id": "st_10"}, {"end": 1533, "text": "In the case of volume rendering algorithms, we provide the expected discretization errors for three different error sources.", "rank": 11, "start": 1409, "IsComparative": "1", "id": "st_11"}, {"end": 1620, "text": "The results of applying the MMS is another important contribution of this dissertation.", "rank": 12, "start": 1533, "IsComparative": "1", "id": "st_12"}, {"end": 1688, "text": "We report unexpected behavior for almost all implementations tested.", "rank": 13, "start": 1620, "IsComparative": "0", "id": "st_13"}, {"end": 1799, "text": "In some cases, we were able to find and fix bugs that prevented the correctness of the visualization algorithm.", "rank": 14, "start": 1688, "IsComparative": "1", "id": "st_14"}, {"end": 2003, "text": "In particular, we address an almost 20-year-old bug with the core disambiguation procedure of Marching Cubes 33, one of the first algorithms intended to preserve the topology of the trilinear interpolant.", "rank": 15, "start": 1799, "IsComparative": "0", "id": "st_15"}, {"end": 2163, "text": "Finally, an important by-product of this work is a range of responses practitioners can expect to encounter with the visualization technique under verification.", "rank": 16, "start": 2003, "IsComparative": "1", "id": "st_16"}]}, {"paragraph_info": {"end": 2185, "start": 2163, "text": "CHAPTER 1 INTRODUCTION", "rank": 2, "paragraph_comparative_number": 0, "entities": [], "id": "p_2"}, "sentences": [{"end": 2185, "text": "CHAPTER 1 INTRODUCTION", "rank": 17, "start": 2163, "IsComparative": "0", "id": "st_17"}]}, {"paragraph_info": {"end": 3242, "start": 2185, "text": "Todays technology provides unprecedented opportunities to scientists for deriving, ex- panding, or correcting scientific theories.In the past few decades, we have seen a sharp increase in ones ability to acquire, store, and process data.Simultaneously, the scientific visualization emerged as a discipline and became the centerpiece in the pipeline of many scientists.In fact, visualization techniques became the means through which scientists explore, evaluate, and present results.Propelled by a vibrant community, visualization techniques have become more widespread, and have successfully been applied to a variety of fields including medical diagnosis, computational fluid dynamics, weather simulation, among others.The wide range of applications, and the uniqueness of each field have further motivated the development of complex visualization techniques, some of which include isosurface extraction, direct volume rendering, flow visualization, to name a few.The amount of work published in these (and other) areas in the past 20 years is remarkable.", "rank": 3, "paragraph_comparative_number": 6, "entities": [], "id": "p_3"}, "sentences": [{"end": 2315, "text": "Todays technology provides unprecedented opportunities to scientists for deriving, ex- panding, or correcting scientific theories.", "rank": 18, "start": 2185, "IsComparative": "1", "id": "st_18"}, {"end": 2422, "text": "In the past few decades, we have seen a sharp increase in ones ability to acquire, store, and process data.", "rank": 19, "start": 2315, "IsComparative": "1", "id": "st_19"}, {"end": 2553, "text": "Simultaneously, the scientific visualization emerged as a discipline and became the centerpiece in the pipeline of many scientists.", "rank": 20, "start": 2422, "IsComparative": "1", "id": "st_20"}, {"end": 2668, "text": "In fact, visualization techniques became the means through which scientists explore, evaluate, and present results.", "rank": 21, "start": 2553, "IsComparative": "0", "id": "st_21"}, {"end": 2906, "text": "Propelled by a vibrant community, visualization techniques have become more widespread, and have successfully been applied to a variety of fields including medical diagnosis, computational fluid dynamics, weather simulation, among others.", "rank": 22, "start": 2668, "IsComparative": "1", "id": "st_22"}, {"end": 3151, "text": "The wide range of applications, and the uniqueness of each field have further motivated the development of complex visualization techniques, some of which include isosurface extraction, direct volume rendering, flow visualization, to name a few.", "rank": 23, "start": 2906, "IsComparative": "1", "id": "st_23"}, {"end": 3242, "text": "The amount of work published in these (and other) areas in the past 20 years is remarkable.", "rank": 24, "start": 3151, "IsComparative": "1", "id": "st_24"}]}, {"paragraph_info": {"end": 4302, "start": 3242, "text": "With the increasing complexity and importance of visualization techniques in the scien- tific pipeline, questions related to the reliability of visualizations began to attract attention.In the past few years, there has been a growing number of published articles related to the way humans perceive images, the accuracy of visualizations, ways to extract and depict uncertainty, and how visualizations compare to each other.More generally, the goal is to determine how reliable visualizations are.In this context, reliable is used in a broad sense so as to include many of the topics of current interest of the visualization community that contributes to increase ones confidence in visualizations: uncertainty visualization; uncer- tainty quantification; evaluation; user perception; and verification.In this dissertation, we focus on the verification of visualization algorithms and implementation.Many techniques can be used for verification purposes, but at the heart of the methodology for verifying visualization, one will find good-old science practices.", "rank": 4, "paragraph_comparative_number": 3, "entities": [], "id": "p_4"}, "sentences": [{"end": 3428, "text": "With the increasing complexity and importance of visualization techniques in the scien- tific pipeline, questions related to the reliability of visualizations began to attract attention.", "rank": 25, "start": 3242, "IsComparative": "1", "id": "st_25"}, {"end": 3665, "text": "In the past few years, there has been a growing number of published articles related to the way humans perceive images, the accuracy of visualizations, ways to extract and depict uncertainty, and how visualizations compare to each other.", "rank": 26, "start": 3428, "IsComparative": "1", "id": "st_26"}, {"end": 3738, "text": "More generally, the goal is to determine how reliable visualizations are.", "rank": 27, "start": 3665, "IsComparative": "0", "id": "st_27"}, {"end": 4043, "text": "In this context, reliable is used in a broad sense so as to include many of the topics of current interest of the visualization community that contributes to increase ones confidence in visualizations: uncertainty visualization; uncer- tainty quantification; evaluation; user perception; and verification.", "rank": 28, "start": 3738, "IsComparative": "0", "id": "st_28"}, {"end": 4141, "text": "In this dissertation, we focus on the verification of visualization algorithms and implementation.", "rank": 29, "start": 4043, "IsComparative": "0", "id": "st_29"}, {"end": 4302, "text": "Many techniques can be used for verification purposes, but at the heart of the methodology for verifying visualization, one will find good-old science practices.", "rank": 30, "start": 4141, "IsComparative": "1", "id": "st_30"}]}, {"paragraph_info": {"end": 4341, "start": 4302, "text": "1.1 Verification of Scientific Theories", "rank": 5, "paragraph_comparative_number": 1, "entities": [], "id": "p_5"}, "sentences": [{"end": 4341, "text": "1.1 Verification of Scientific Theories", "rank": 31, "start": 4302, "IsComparative": "1", "id": "st_31"}]}, {"paragraph_info": {"end": 4839, "start": 4341, "text": "New theories are put forward and evaluated through the scientific method: observations; hypothesis formulation; predictions and testing; and analysis of the results.Details on how to perform each of these steps vary according to the phenomena being studied.A particularly important step in the process of deriving a valid scientific theory is the process of falsification: the process by which the theory predictions are tested.As Karl Popper argued in The Logic of Scientific Discovery <140, p.9>:", "rank": 6, "paragraph_comparative_number": 3, "entities": [], "id": "p_6"}, "sentences": [{"end": 4506, "text": "New theories are put forward and evaluated through the scientific method: observations; hypothesis formulation; predictions and testing; and analysis of the results.", "rank": 32, "start": 4341, "IsComparative": "0", "id": "st_32"}, {"end": 4598, "text": "Details on how to perform each of these steps vary according to the phenomena being studied.", "rank": 33, "start": 4506, "IsComparative": "0", "id": "st_33"}, {"end": 4769, "text": "A particularly important step in the process of deriving a valid scientific theory is the process of falsification: the process by which the theory predictions are tested.", "rank": 34, "start": 4598, "IsComparative": "1", "id": "st_34"}, {"end": 4836, "text": "As Karl Popper argued in The Logic of Scientific Discovery <140, p.", "rank": 35, "start": 4769, "IsComparative": "1", "id": "st_35"}, {"end": 4839, "text": "9>:", "rank": 36, "start": 4836, "IsComparative": "1", "id": "st_36"}]}, {"paragraph_info": {"end": 5744, "start": 4839, "text": "With the help of other statements, previously accepted, certain singular state- ments  which we may call predictions  are deduced from the theory; es- pecially predictions that are easily testable or applicable.From among these statements, those are selected which are not derivable from the current theory, and more especially those which the current theory contradicts.Next we seek a decision as regards these (and other) derived statements by comparing them with the results of practical applications and experiments.If this decision is positive, that is, if the singular conclusions turn out to be acceptable, or verified, then the theory has, for the time being, passed its test: we have found no reason to discard it.But if the decision is negative, or in other words, if the conclusions have been falsified, then their falsification also falsifies the theory from which they were logically deduced.", "rank": 7, "paragraph_comparative_number": 4, "entities": [], "id": "p_7"}, "sentences": [{"end": 5050, "text": "With the help of other statements, previously accepted, certain singular state- ments  which we may call predictions  are deduced from the theory; es- pecially predictions that are easily testable or applicable.", "rank": 37, "start": 4839, "IsComparative": "1", "id": "st_37"}, {"end": 5210, "text": "From among these statements, those are selected which are not derivable from the current theory, and more especially those which the current theory contradicts.", "rank": 38, "start": 5050, "IsComparative": "1", "id": "st_38"}, {"end": 5359, "text": "Next we seek a decision as regards these (and other) derived statements by comparing them with the results of practical applications and experiments.", "rank": 39, "start": 5210, "IsComparative": "0", "id": "st_39"}, {"end": 5562, "text": "If this decision is positive, that is, if the singular conclusions turn out to be acceptable, or verified, then the theory has, for the time being, passed its test: we have found no reason to discard it.", "rank": 40, "start": 5359, "IsComparative": "1", "id": "st_40"}, {"end": 5744, "text": "But if the decision is negative, or in other words, if the conclusions have been falsified, then their falsification also falsifies the theory from which they were logically deduced.", "rank": 41, "start": 5562, "IsComparative": "1", "id": "st_41"}]}, {"paragraph_info": {"end": 6968, "start": 5744, "text": "An example of testing risky prediction is the classic Eddingtons experiment of Einsteins theory of relativity <27>.Eddington conducted an experiment to measure the light deflection caused by the massive size of the Sun.During the eclipse of May 29th 1919, Eddington photographed the Hyades star cluster and measured the light deflected.At the time, Newtons law of gravity was the accepted theory; it predicted some shift in the position of the stars, as observed from Earth, whereas Einsteins theory of gravity predicted twice as much shift.Because Einsteins prediction contradicted current theory, it was a risky prediction.The eclipse was photographed, and the deviations were measured.At that time, two outcomes were possible: either the expected (predicted) deflection would not match the observed one  because no deflection is observed, or Newtons prediction was correct, or some other value is obtained  in which case the theory would be refuted; or, the predicted deflection would match the observations, in which case, nothing could be said about the correctness of the theory, aside from that it has not been proved wrong and has stood up to risky tests.The more a theory is tested, the more trustworthy it becomes.", "rank": 8, "paragraph_comparative_number": 2, "entities": [], "id": "p_8"}, "sentences": [{"end": 5859, "text": "An example of testing risky prediction is the classic Eddingtons experiment of Einsteins theory of relativity <27>.", "rank": 42, "start": 5744, "IsComparative": "1", "id": "st_42"}, {"end": 5963, "text": "Eddington conducted an experiment to measure the light deflection caused by the massive size of the Sun.", "rank": 43, "start": 5859, "IsComparative": "0", "id": "st_43"}, {"end": 6080, "text": "During the eclipse of May 29th 1919, Eddington photographed the Hyades star cluster and measured the light deflected.", "rank": 44, "start": 5963, "IsComparative": "0", "id": "st_44"}, {"end": 6285, "text": "At the time, Newtons law of gravity was the accepted theory; it predicted some shift in the position of the stars, as observed from Earth, whereas Einsteins theory of gravity predicted twice as much shift.", "rank": 45, "start": 6080, "IsComparative": "0", "id": "st_45"}, {"end": 6369, "text": "Because Einsteins prediction contradicted current theory, it was a risky prediction.", "rank": 46, "start": 6285, "IsComparative": "0", "id": "st_46"}, {"end": 6432, "text": "The eclipse was photographed, and the deviations were measured.", "rank": 47, "start": 6369, "IsComparative": "0", "id": "st_47"}, {"end": 6907, "text": "At that time, two outcomes were possible: either the expected (predicted) deflection would not match the observed one  because no deflection is observed, or Newtons prediction was correct, or some other value is obtained  in which case the theory would be refuted; or, the predicted deflection would match the observations, in which case, nothing could be said about the correctness of the theory, aside from that it has not been proved wrong and has stood up to risky tests.", "rank": 48, "start": 6432, "IsComparative": "1", "id": "st_48"}, {"end": 6968, "text": "The more a theory is tested, the more trustworthy it becomes.", "rank": 49, "start": 6907, "IsComparative": "0", "id": "st_49"}]}, {"paragraph_info": {"end": 8321, "start": 6968, "text": "The same idea of falsification can be applied to test the trustworthiness of an algorithm and its implementation.During the course of a scientific inquiry, scientists carefully perform each step in the scientific method to mitigate and control errors.For each step of the scientific method, there are multiple ways to account for these errors: by using sophis- ticated statistical methods; advanced mathematical models; high-precision equipments; redundancy; etc.The reason behind it is that the reliability of the conclusions depends on how each of the steps are performed.In the example of Eddingtons experiment, a series of precautions had to be made and several error sources were taken into account to show that Einsteins predictions were correct1.Since the scientific methodology is used to increase ones confidence in a particular statement, it can also be applied to the substeps involved in the formulation of a scientific theory, which, in turn, builds up ones confidence in the theory itself.There is a need for reliability of scientific software.The lack of such guarantees led the discipline of Computational Fluid Dynamics (CFD) to once be referred to as Colorful Fluid Dynamics <112>.Of course, the Computational Science & Engineering and Computer Science communities have already developed standard methodology for software verification.", "rank": 9, "paragraph_comparative_number": 6, "entities": [], "id": "p_9"}, "sentences": [{"end": 7081, "text": "The same idea of falsification can be applied to test the trustworthiness of an algorithm and its implementation.", "rank": 50, "start": 6968, "IsComparative": "1", "id": "st_50"}, {"end": 7219, "text": "During the course of a scientific inquiry, scientists carefully perform each step in the scientific method to mitigate and control errors.", "rank": 51, "start": 7081, "IsComparative": "1", "id": "st_51"}, {"end": 7431, "text": "For each step of the scientific method, there are multiple ways to account for these errors: by using sophis- ticated statistical methods; advanced mathematical models; high-precision equipments; redundancy; etc.", "rank": 52, "start": 7219, "IsComparative": "1", "id": "st_52"}, {"end": 7542, "text": "The reason behind it is that the reliability of the conclusions depends on how each of the steps are performed.", "rank": 53, "start": 7431, "IsComparative": "0", "id": "st_53"}, {"end": 7721, "text": "In the example of Eddingtons experiment, a series of precautions had to be made and several error sources were taken into account to show that Einsteins predictions were correct1.", "rank": 54, "start": 7542, "IsComparative": "1", "id": "st_54"}, {"end": 7971, "text": "Since the scientific methodology is used to increase ones confidence in a particular statement, it can also be applied to the substeps involved in the formulation of a scientific theory, which, in turn, builds up ones confidence in the theory itself.", "rank": 55, "start": 7721, "IsComparative": "0", "id": "st_55"}, {"end": 8026, "text": "There is a need for reliability of scientific software.", "rank": 56, "start": 7971, "IsComparative": "1", "id": "st_56"}, {"end": 8167, "text": "The lack of such guarantees led the discipline of Computational Fluid Dynamics (CFD) to once be referred to as Colorful Fluid Dynamics <112>.", "rank": 57, "start": 8026, "IsComparative": "1", "id": "st_57"}, {"end": 8321, "text": "Of course, the Computational Science & Engineering and Computer Science communities have already developed standard methodology for software verification.", "rank": 58, "start": 8167, "IsComparative": "0", "id": "st_58"}]}, {"paragraph_info": {"end": 8337, "start": 8321, "text": "1.2 Verification", "rank": 10, "paragraph_comparative_number": 0, "entities": [], "id": "p_10"}, "sentences": [{"end": 8337, "text": "1.2 Verification", "rank": 59, "start": 8321, "IsComparative": "0", "id": "st_59"}]}, {"paragraph_info": {"end": 9314, "start": 8337, "text": "The meaning of the word verification may vary according to the context in which it is used.When applied loosely, it refers to good coding practices (e.g., use of versioning system), software testing (e.g., unit/regression tests), and even the process of debugging a code.These practices are obviously valuable to help build a trustworthy software, but they are often ad hoc and have limited scope.In this dissertation, the word verification is used as in Computer Science (CS) and Computation Simulation (CS&E).In CS according to IEEE standards, verification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase <67>.In this context, the program specification is the condition imposed at the start phase and the verification process ideally should guarantee that the resulting implementation (i.e., final computer software) meets the specification exactly.In", "rank": 11, "paragraph_comparative_number": 3, "entities": [], "id": "p_11"}, "sentences": [{"end": 8428, "text": "The meaning of the word verification may vary according to the context in which it is used.", "rank": 60, "start": 8337, "IsComparative": "0", "id": "st_60"}, {"end": 8608, "text": "When applied loosely, it refers to good coding practices (e.g., use of versioning system), software testing (e.g., unit/regression tests), and even the process of debugging a code.", "rank": 61, "start": 8428, "IsComparative": "1", "id": "st_61"}, {"end": 8734, "text": "These practices are obviously valuable to help build a trustworthy software, but they are often ad hoc and have limited scope.", "rank": 62, "start": 8608, "IsComparative": "0", "id": "st_62"}, {"end": 8848, "text": "In this dissertation, the word verification is used as in Computer Science (CS) and Computation Simulation (CS&E).", "rank": 63, "start": 8734, "IsComparative": "0", "id": "st_63"}, {"end": 9073, "text": "In CS according to IEEE standards, verification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase <67>.", "rank": 64, "start": 8848, "IsComparative": "1", "id": "st_64"}, {"end": 9312, "text": "In this context, the program specification is the condition imposed at the start phase and the verification process ideally should guarantee that the resulting implementation (i.e., final computer software) meets the specification exactly.", "rank": 65, "start": 9073, "IsComparative": "0", "id": "st_65"}, {"end": 9314, "text": "In", "rank": 66, "start": 9312, "IsComparative": "1", "id": "st_66"}]}, {"paragraph_info": {"end": 11202, "start": 9314, "text": "1They started by sending off two expeditions.The first to Sobral, northern Brazil, and another to the island of Pr ncipe, northern of Sa o Tom e and Pr ncipe.Aside from equipment related to the telescope, backup lenses were packed along with all necessary equipment to account for the rotation of the Earth.The expedition at Pr ncipe, among other problems, had to deal with clouds and rain, thus they were able to retrieve only two usable photos.The expedition at Sobral, on the other hand, encountered better weather but had problems due to the rise of the temperature between the time the telescope was assembled and the time of the eclipse.Parts of the telescope expanded and as a result, the images were blurred.Another problem was related to the very small expected light deflection.Since photograph plates could expand and shrink with the temperature, deflection could be due to other factors other than light deflection, such as shrinkage.Other source of errors are involved.According to Coles <27>, at the time the results were published, they were met with some skepticism.For more details, see Coles <27>.the past few decades, several techniques have been developed to attain software verification, which include theorem provers <12>, model checking <25>, fuzzing <7, 56>, and others.This variety of techniques is due to the difficult task of testing a program (either a model or an implementation) which may contain millions of lines of code and an exponentially large state-space where a bug might be hidden.Because of this large number of paths, verification can be considered a process where one accumulates evidence that a code is correct <143>, rather than deriving a proof that the code is actually correct.These techniques have been successfully applied not only for verification of user-level computer code <5>, but also hardware <157> and operating system kernel <79>.", "rank": 12, "paragraph_comparative_number": 8, "entities": [], "id": "p_12"}, "sentences": [{"end": 9359, "text": "1They started by sending off two expeditions.", "rank": 67, "start": 9314, "IsComparative": "1", "id": "st_67"}, {"end": 9472, "text": "The first to Sobral, northern Brazil, and another to the island of Pr ncipe, northern of Sa o Tom e and Pr ncipe.", "rank": 68, "start": 9359, "IsComparative": "0", "id": "st_68"}, {"end": 9621, "text": "Aside from equipment related to the telescope, backup lenses were packed along with all necessary equipment to account for the rotation of the Earth.", "rank": 69, "start": 9472, "IsComparative": "1", "id": "st_69"}, {"end": 9760, "text": "The expedition at Pr ncipe, among other problems, had to deal with clouds and rain, thus they were able to retrieve only two usable photos.", "rank": 70, "start": 9621, "IsComparative": "1", "id": "st_70"}, {"end": 9957, "text": "The expedition at Sobral, on the other hand, encountered better weather but had problems due to the rise of the temperature between the time the telescope was assembled and the time of the eclipse.", "rank": 71, "start": 9760, "IsComparative": "1", "id": "st_71"}, {"end": 10030, "text": "Parts of the telescope expanded and as a result, the images were blurred.", "rank": 72, "start": 9957, "IsComparative": "0", "id": "st_72"}, {"end": 10102, "text": "Another problem was related to the very small expected light deflection.", "rank": 73, "start": 10030, "IsComparative": "0", "id": "st_73"}, {"end": 10260, "text": "Since photograph plates could expand and shrink with the temperature, deflection could be due to other factors other than light deflection, such as shrinkage.", "rank": 74, "start": 10102, "IsComparative": "1", "id": "st_74"}, {"end": 10296, "text": "Other source of errors are involved.", "rank": 75, "start": 10260, "IsComparative": "0", "id": "st_75"}, {"end": 10396, "text": "According to Coles <27>, at the time the results were published, they were met with some skepticism.", "rank": 76, "start": 10296, "IsComparative": "1", "id": "st_76"}, {"end": 10429, "text": "For more details, see Coles <27>.", "rank": 77, "start": 10396, "IsComparative": "1", "id": "st_77"}, {"end": 10608, "text": "the past few decades, several techniques have been developed to attain software verification, which include theorem provers <12>, model checking <25>, fuzzing <7, 56>, and others.", "rank": 78, "start": 10429, "IsComparative": "0", "id": "st_78"}, {"end": 10834, "text": "This variety of techniques is due to the difficult task of testing a program (either a model or an implementation) which may contain millions of lines of code and an exponentially large state-space where a bug might be hidden.", "rank": 79, "start": 10608, "IsComparative": "0", "id": "st_79"}, {"end": 11038, "text": "Because of this large number of paths, verification can be considered a process where one accumulates evidence that a code is correct <143>, rather than deriving a proof that the code is actually correct.", "rank": 80, "start": 10834, "IsComparative": "1", "id": "st_80"}, {"end": 11202, "text": "These techniques have been successfully applied not only for verification of user-level computer code <5>, but also hardware <157> and operating system kernel <79>.", "rank": 81, "start": 11038, "IsComparative": "0", "id": "st_81"}]}, {"paragraph_info": {"end": 12090, "start": 11202, "text": "Verification techniques developed in the CS&E community are focused in general on the numerical solution of partial differential equations (PDEs) that models a physical phenomena of interest.In this context, verification is defined as the process of determining if a computational model, and its corresponding numerical solution, can be used to represent the mathematical model of the event with sufficient accuracy <3>.This definition is closely related to the errors involved during discretization and implementation.They are of great importance to scientists because they can be used to assess which of the models, mathe- matical or computational, should be refined.A successful approach for code verification, known to be sensitive to code mistakes <143>, is the order of accuracy test  an evaluation of the implementation behavior when submitted to successive grid refinements <143>.", "rank": 13, "paragraph_comparative_number": 2, "entities": [], "id": "p_13"}, "sentences": [{"end": 11393, "text": "Verification techniques developed in the CS&E community are focused in general on the numerical solution of partial differential equations (PDEs) that models a physical phenomena of interest.", "rank": 82, "start": 11202, "IsComparative": "0", "id": "st_82"}, {"end": 11622, "text": "In this context, verification is defined as the process of determining if a computational model, and its corresponding numerical solution, can be used to represent the mathematical model of the event with sufficient accuracy <3>.", "rank": 83, "start": 11393, "IsComparative": "1", "id": "st_83"}, {"end": 11721, "text": "This definition is closely related to the errors involved during discretization and implementation.", "rank": 84, "start": 11622, "IsComparative": "0", "id": "st_84"}, {"end": 11871, "text": "They are of great importance to scientists because they can be used to assess which of the models, mathe- matical or computational, should be refined.", "rank": 85, "start": 11721, "IsComparative": "0", "id": "st_85"}, {"end": 12090, "text": "A successful approach for code verification, known to be sensitive to code mistakes <143>, is the order of accuracy test  an evaluation of the implementation behavior when submitted to successive grid refinements <143>.", "rank": 86, "start": 11871, "IsComparative": "1", "id": "st_86"}]}, {"paragraph_info": {"end": 12846, "start": 12090, "text": "The verification tools proposed by the CS and CS&E communities cover only part of the scientific pipeline.Given the importance of visualizations, not only numerical softwares have to be verified, but also visualization algorithms and implementations.Nevertheless, visual- ization has not fallen under the same rigorous scrutiny as other components of the pipeline like mathematical modeling and numerical simulation.Unlike traditional computational science and engineering areas, there is no commonly accepted framework for verifying the accuracy, reliability, and robustness of visualization tools.Furthermore, very few studies have focused on how the error originating from other components of the computational pipeline impacts visualization algorithms.", "rank": 14, "paragraph_comparative_number": 1, "entities": [], "id": "p_14"}, "sentences": [{"end": 12196, "text": "The verification tools proposed by the CS and CS&E communities cover only part of the scientific pipeline.", "rank": 87, "start": 12090, "IsComparative": "0", "id": "st_87"}, {"end": 12340, "text": "Given the importance of visualizations, not only numerical softwares have to be verified, but also visualization algorithms and implementations.", "rank": 88, "start": 12196, "IsComparative": "0", "id": "st_88"}, {"end": 12506, "text": "Nevertheless, visual- ization has not fallen under the same rigorous scrutiny as other components of the pipeline like mathematical modeling and numerical simulation.", "rank": 89, "start": 12340, "IsComparative": "0", "id": "st_89"}, {"end": 12689, "text": "Unlike traditional computational science and engineering areas, there is no commonly accepted framework for verifying the accuracy, reliability, and robustness of visualization tools.", "rank": 90, "start": 12506, "IsComparative": "1", "id": "st_90"}, {"end": 12846, "text": "Furthermore, very few studies have focused on how the error originating from other components of the computational pipeline impacts visualization algorithms.", "rank": 91, "start": 12689, "IsComparative": "0", "id": "st_91"}]}, {"paragraph_info": {"end": 13309, "start": 12846, "text": "While the lack of a well-established framework for verifying visualization tools has led to the development of a variety of analysis techniques <195, 174>, we believe visualization has achieved sufficient importance to warrant investigation of stricter verification methodologies.Several authors have already asserted its need <54, 55, 76>.This work presents a concrete step towards reducing the gap between best practices in simulation science and visualization.", "rank": 15, "paragraph_comparative_number": 3, "entities": [], "id": "p_15"}, "sentences": [{"end": 13126, "text": "While the lack of a well-established framework for verifying visualization tools has led to the development of a variety of analysis techniques <195, 174>, we believe visualization has achieved sufficient importance to warrant investigation of stricter verification methodologies.", "rank": 92, "start": 12846, "IsComparative": "1", "id": "st_92"}, {"end": 13186, "text": "Several authors have already asserted its need <54, 55, 76>.", "rank": 93, "start": 13126, "IsComparative": "1", "id": "st_93"}, {"end": 13309, "text": "This work presents a concrete step towards reducing the gap between best practices in simulation science and visualization.", "rank": 94, "start": 13186, "IsComparative": "1", "id": "st_94"}]}, {"paragraph_info": {"end": 13326, "start": 13309, "text": "1.3 Contributions", "rank": 16, "paragraph_comparative_number": 0, "entities": [], "id": "p_16"}, "sentences": [{"end": 13326, "text": "1.3 Contributions", "rank": 95, "start": 13309, "IsComparative": "0", "id": "st_95"}]}, {"paragraph_info": {"end": 14192, "start": 13326, "text": "We advocate that all visualization algorithms and implementation should be verified.Hence, the main contribution to this dissertation is to advance the theory and practice of verifying visualizations.We do so by extracting important mathematical properties of the algorithms under verification.Then, we verify whether the implementation honors that property by stress testing it.As in the case of falsification of scientific theories, a mismatch reveals a problem; in the case of visualization, the problem will lie in the implementation, algorithm, or verification process.On the other hand, if the implementation honors the property of interest for all performed tests, then nothing can be said about the correctness of the implementation and algorithm, except that it has stood severe stress tests.More specifically, our contribution can be summarized as follows:", "rank": 17, "paragraph_comparative_number": 4, "entities": [], "id": "p_17"}, "sentences": [{"end": 13410, "text": "We advocate that all visualization algorithms and implementation should be verified.", "rank": 96, "start": 13326, "IsComparative": "0", "id": "st_96"}, {"end": 13526, "text": "Hence, the main contribution to this dissertation is to advance the theory and practice of verifying visualizations.", "rank": 97, "start": 13410, "IsComparative": "1", "id": "st_97"}, {"end": 13620, "text": "We do so by extracting important mathematical properties of the algorithms under verification.", "rank": 98, "start": 13526, "IsComparative": "0", "id": "st_98"}, {"end": 13705, "text": "Then, we verify whether the implementation honors that property by stress testing it.", "rank": 99, "start": 13620, "IsComparative": "0", "id": "st_99"}, {"end": 13900, "text": "As in the case of falsification of scientific theories, a mismatch reveals a problem; in the case of visualization, the problem will lie in the implementation, algorithm, or verification process.", "rank": 100, "start": 13705, "IsComparative": "1", "id": "st_100"}, {"end": 14127, "text": "On the other hand, if the implementation honors the property of interest for all performed tests, then nothing can be said about the correctness of the implementation and algorithm, except that it has stood severe stress tests.", "rank": 101, "start": 13900, "IsComparative": "1", "id": "st_101"}, {"end": 14192, "text": "More specifically, our contribution can be summarized as follows:", "rank": 102, "start": 14127, "IsComparative": "1", "id": "st_102"}]}, {"paragraph_info": {"end": 14265, "start": 14192, "text": "1.Chapter 2: Verifying Geometry of Isosurface Extraction Algorithms <46>.", "rank": 18, "paragraph_comparative_number": 1, "entities": [], "id": "p_18"}, "sentences": [{"end": 14194, "text": "1.", "rank": 103, "start": 14192, "IsComparative": "1", "id": "st_103"}, {"end": 14265, "text": "Chapter 2: Verifying Geometry of Isosurface Extraction Algorithms <46>.", "rank": 104, "start": 14194, "IsComparative": "0", "id": "st_104"}]}, {"paragraph_info": {"end": 14513, "start": 14265, "text": "(a) We introduce a framework for the verification of visualization tools based on the Method of Manufactured Solutions, and show how to apply it for the verification of geometrical properties of isosurface extraction algorithms and implementations;", "rank": 19, "paragraph_comparative_number": 1, "entities": [], "id": "p_19"}, "sentences": [{"end": 14513, "text": "(a) We introduce a framework for the verification of visualization tools based on the Method of Manufactured Solutions, and show how to apply it for the verification of geometrical properties of isosurface extraction algorithms and implementations;", "rank": 105, "start": 14265, "IsComparative": "1", "id": "st_105"}]}, {"paragraph_info": {"end": 14708, "start": 14513, "text": "(b) We provide the required mathematical analysis for the implementation of the verification procedure.The important properties that should be honored are derived from this mathematical analysis;", "rank": 20, "paragraph_comparative_number": 0, "entities": [], "id": "p_20"}, "sentences": [{"end": 14616, "text": "(b) We provide the required mathematical analysis for the implementation of the verification procedure.", "rank": 106, "start": 14513, "IsComparative": "0", "id": "st_106"}, {"end": 14708, "text": "The important properties that should be honored are derived from this mathematical analysis;", "rank": 107, "start": 14616, "IsComparative": "0", "id": "st_107"}]}, {"paragraph_info": {"end": 15007, "start": 14708, "text": "(c) We show concrete results, and show how this verification procedure helped us to find and fix problems in both algorithm and implementation.Moreover, we show that it is not trivial to find solutions that are both geometrically accurate and honors additional properties (such as triangle quality);", "rank": 21, "paragraph_comparative_number": 2, "entities": [], "id": "p_21"}, "sentences": [{"end": 14851, "text": "(c) We show concrete results, and show how this verification procedure helped us to find and fix problems in both algorithm and implementation.", "rank": 108, "start": 14708, "IsComparative": "1", "id": "st_108"}, {"end": 15007, "text": "Moreover, we show that it is not trivial to find solutions that are both geometrically accurate and honors additional properties (such as triangle quality);", "rank": 109, "start": 14851, "IsComparative": "1", "id": "st_109"}]}, {"paragraph_info": {"end": 15115, "start": 15007, "text": "(d) As a by-product of the verification, we detail the behavior of several freely available implementations;", "rank": 22, "paragraph_comparative_number": 1, "entities": [], "id": "p_22"}, "sentences": [{"end": 15115, "text": "(d) As a by-product of the verification, we detail the behavior of several freely available implementations;", "rank": 110, "start": 15007, "IsComparative": "1", "id": "st_110"}]}, {"paragraph_info": {"end": 15188, "start": 15115, "text": "2.Chapter 3: Verifying Topology of Isosurface Extraction Algorithms <45>.", "rank": 23, "paragraph_comparative_number": 1, "entities": [], "id": "p_23"}, "sentences": [{"end": 15117, "text": "2.", "rank": 111, "start": 15115, "IsComparative": "1", "id": "st_111"}, {"end": 15188, "text": "Chapter 3: Verifying Topology of Isosurface Extraction Algorithms <45>.", "rank": 112, "start": 15117, "IsComparative": "0", "id": "st_112"}]}, {"paragraph_info": {"end": 15296, "start": 15188, "text": "(a) We introduce a framework for verification of topological properties of isosurface extraction algorithms;", "rank": 24, "paragraph_comparative_number": 0, "entities": [], "id": "p_24"}, "sentences": [{"end": 15296, "text": "(a) We introduce a framework for verification of topological properties of isosurface extraction algorithms;", "rank": 113, "start": 15188, "IsComparative": "0", "id": "st_113"}]}, {"paragraph_info": {"end": 15481, "start": 15296, "text": "(b) We derive a framework based on Digital Topology for the extraction of impor- tant invariants (topological properties) that should be honored by topologically correct implmentations;", "rank": 25, "paragraph_comparative_number": 0, "entities": [], "id": "p_25"}, "sentences": [{"end": 15481, "text": "(b) We derive a framework based on Digital Topology for the extraction of impor- tant invariants (topological properties) that should be honored by topologically correct implmentations;", "rank": 114, "start": 15296, "IsComparative": "0", "id": "st_114"}]}, {"paragraph_info": {"end": 15596, "start": 15481, "text": "(c) In addition, we derive a framework based on Stratified Morse Theory for the extraction of important invariants;", "rank": 26, "paragraph_comparative_number": 1, "entities": [], "id": "p_26"}, "sentences": [{"end": 15596, "text": "(c) In addition, we derive a framework based on Stratified Morse Theory for the extraction of important invariants;", "rank": 115, "start": 15481, "IsComparative": "1", "id": "st_115"}]}, {"paragraph_info": {"end": 15769, "start": 15596, "text": "(d) We detail the behavior of several freely and commercially available implementa- tions of isosurface extraction; We show that all but one implementation failed our tests;", "rank": 27, "paragraph_comparative_number": 1, "entities": [], "id": "p_27"}, "sentences": [{"end": 15769, "text": "(d) We detail the behavior of several freely and commercially available implementa- tions of isosurface extraction; We show that all but one implementation failed our tests;", "rank": 116, "start": 15596, "IsComparative": "1", "id": "st_116"}]}, {"paragraph_info": {"end": 15864, "start": 15769, "text": "3.Chapter 4: Practical Considerations on the Topological Correctness of Marching Cubes 33 <29>.", "rank": 28, "paragraph_comparative_number": 2, "entities": [], "id": "p_28"}, "sentences": [{"end": 15771, "text": "3.", "rank": 117, "start": 15769, "IsComparative": "1", "id": "st_117"}, {"end": 15864, "text": "Chapter 4: Practical Considerations on the Topological Correctness of Marching Cubes 33 <29>.", "rank": 118, "start": 15771, "IsComparative": "1", "id": "st_118"}]}, {"paragraph_info": {"end": 16065, "start": 15864, "text": "(a) We show that both the Marching Cubes 33 algorithm and implementation have problems that prevent its topological correctness.Moreover, one of the problems is traced back to its original publication;", "rank": 29, "paragraph_comparative_number": 2, "entities": [], "id": "p_29"}, "sentences": [{"end": 15992, "text": "(a) We show that both the Marching Cubes 33 algorithm and implementation have problems that prevent its topological correctness.", "rank": 119, "start": 15864, "IsComparative": "1", "id": "st_119"}, {"end": 16065, "text": "Moreover, one of the problems is traced back to its original publication;", "rank": 120, "start": 15992, "IsComparative": "1", "id": "st_120"}]}, {"paragraph_info": {"end": 16138, "start": 16065, "text": "(b) We propose a new and alternative ways to deal with the issues raised;", "rank": 30, "paragraph_comparative_number": 0, "entities": [], "id": "p_30"}, "sentences": [{"end": 16138, "text": "(b) We propose a new and alternative ways to deal with the issues raised;", "rank": 121, "start": 16065, "IsComparative": "0", "id": "st_121"}]}, {"paragraph_info": {"end": 16309, "start": 16138, "text": "(c) Building on recent efforts on executable papers, we provide new ways to interact with our work so as to improve understanding and reproducibility of the results shown;", "rank": 31, "paragraph_comparative_number": 1, "entities": [], "id": "p_31"}, "sentences": [{"end": 16309, "text": "(c) Building on recent efforts on executable papers, we provide new ways to interact with our work so as to improve understanding and reproducibility of the results shown;", "rank": 122, "start": 16138, "IsComparative": "1", "id": "st_122"}]}, {"paragraph_info": {"end": 16371, "start": 16309, "text": "4.Chapter 5: Verifying Direct Volume Rendering Algorithm <43>.", "rank": 32, "paragraph_comparative_number": 1, "entities": [], "id": "p_32"}, "sentences": [{"end": 16311, "text": "4.", "rank": 123, "start": 16309, "IsComparative": "1", "id": "st_123"}, {"end": 16371, "text": "Chapter 5: Verifying Direct Volume Rendering Algorithm <43>.", "rank": 124, "start": 16311, "IsComparative": "0", "id": "st_124"}]}, {"paragraph_info": {"end": 16468, "start": 16371, "text": "(a) We introduce a framework for verification of volume rendering algorithms and implementations;", "rank": 33, "paragraph_comparative_number": 0, "entities": [], "id": "p_33"}, "sentences": [{"end": 16468, "text": "(a) We introduce a framework for verification of volume rendering algorithms and implementations;", "rank": 125, "start": 16371, "IsComparative": "0", "id": "st_125"}]}, {"paragraph_info": {"end": 16591, "start": 16468, "text": "(b) We provide the error analysis of the standard volume rendering integral that is crucial for the verification procedure;", "rank": 34, "paragraph_comparative_number": 0, "entities": [], "id": "p_34"}, "sentences": [{"end": 16591, "text": "(b) We provide the error analysis of the standard volume rendering integral that is crucial for the verification procedure;", "rank": 126, "start": 16468, "IsComparative": "0", "id": "st_126"}]}, {"paragraph_info": {"end": 16798, "start": 16591, "text": "(c) We show how we used this information to find and fix problems in widely used volume rendering implementations.Moreover, we provide a first attempt to detect the sensitivity of the verification procedure;", "rank": 35, "paragraph_comparative_number": 0, "entities": [], "id": "p_35"}, "sentences": [{"end": 16705, "text": "(c) We show how we used this information to find and fix problems in widely used volume rendering implementations.", "rank": 127, "start": 16591, "IsComparative": "0", "id": "st_127"}, {"end": 16798, "text": "Moreover, we provide a first attempt to detect the sensitivity of the verification procedure;", "rank": 128, "start": 16705, "IsComparative": "0", "id": "st_128"}]}, {"paragraph_info": {"end": 16835, "start": 16798, "text": "5.Chapter 6: Flow Visualization <44>.", "rank": 36, "paragraph_comparative_number": 1, "entities": [], "id": "p_36"}, "sentences": [{"end": 16800, "text": "5.", "rank": 129, "start": 16798, "IsComparative": "1", "id": "st_129"}, {"end": 16835, "text": "Chapter 6: Flow Visualization <44>.", "rank": 130, "start": 16800, "IsComparative": "0", "id": "st_130"}]}, {"paragraph_info": {"end": 16923, "start": 16835, "text": "(a) We provide an overview of the some of the topics involved in reliable visualization.", "rank": 37, "paragraph_comparative_number": 0, "entities": [], "id": "p_37"}, "sentences": [{"end": 16923, "text": "(a) We provide an overview of the some of the topics involved in reliable visualization.", "rank": 131, "start": 16835, "IsComparative": "0", "id": "st_131"}]}, {"paragraph_info": {"end": 16975, "start": 16923, "text": "We focus on flow visualization and supporting tools.", "rank": 38, "paragraph_comparative_number": 0, "entities": [], "id": "p_38"}, "sentences": [{"end": 16975, "text": "We focus on flow visualization and supporting tools.", "rank": 132, "start": 16923, "IsComparative": "0", "id": "st_132"}]}, {"paragraph_info": {"end": 17124, "start": 16975, "text": "The goal of this dissertation is to provide another step towards creating a culture of verification inside the visualization and related communities.", "rank": 39, "paragraph_comparative_number": 1, "entities": [], "id": "p_39"}, "sentences": [{"end": 17124, "text": "The goal of this dissertation is to provide another step towards creating a culture of verification inside the visualization and related communities.", "rank": 133, "start": 16975, "IsComparative": "1", "id": "st_133"}]}, {"paragraph_info": {"end": 17188, "start": 17124, "text": "CHAPTER 2 VERIFYING GEOMETRY OF ISOSURFACE EXTRACTION ALGORITHMS", "rank": 40, "paragraph_comparative_number": 0, "entities": [], "id": "p_40"}, "sentences": [{"end": 17188, "text": "CHAPTER 2 VERIFYING GEOMETRY OF ISOSURFACE EXTRACTION ALGORITHMS", "rank": 134, "start": 17124, "IsComparative": "0", "id": "st_134"}]}, {"paragraph_info": {"end": 17587, "start": 17188, "text": "In this chapter, we are concerned with important properties of isosurface extraction algorithms.In particular, we will focus on geometrical properties; thus, the verification procedure developed in the forthcoming sections will be focused on the correctness of the geometry of the extracted surfaces.This is in contrast to topological properties of isosurfaces, which will be discussed in Chapter 3.", "rank": 41, "paragraph_comparative_number": 0, "entities": [], "id": "p_41"}, "sentences": [{"end": 17284, "text": "In this chapter, we are concerned with important properties of isosurface extraction algorithms.", "rank": 135, "start": 17188, "IsComparative": "0", "id": "st_135"}, {"end": 17488, "text": "In particular, we will focus on geometrical properties; thus, the verification procedure developed in the forthcoming sections will be focused on the correctness of the geometry of the extracted surfaces.", "rank": 136, "start": 17284, "IsComparative": "0", "id": "st_136"}, {"end": 17587, "text": "This is in contrast to topological properties of isosurfaces, which will be discussed in Chapter 3.", "rank": 137, "start": 17488, "IsComparative": "0", "id": "st_137"}]}, {"paragraph_info": {"end": 17603, "start": 17587, "text": "2.1 Related Work", "rank": 42, "paragraph_comparative_number": 0, "entities": [], "id": "p_42"}, "sentences": [{"end": 17603, "text": "2.1 Related Work", "rank": 138, "start": 17587, "IsComparative": "0", "id": "st_138"}]}, {"paragraph_info": {"end": 17972, "start": 17603, "text": "Isosurface extraction is a popular visualization technique, being a tool currently used in science, engineering, and applications.This popularity makes it a natural target for this first application of verification mechanisms in the context of visualization.This same popularity has also driven a large body of work comparing different isosurface extraction algorithms.", "rank": 43, "paragraph_comparative_number": 1, "entities": [], "id": "p_43"}, "sentences": [{"end": 17733, "text": "Isosurface extraction is a popular visualization technique, being a tool currently used in science, engineering, and applications.", "rank": 139, "start": 17603, "IsComparative": "0", "id": "st_139"}, {"end": 17861, "text": "This popularity makes it a natural target for this first application of verification mechanisms in the context of visualization.", "rank": 140, "start": 17733, "IsComparative": "1", "id": "st_140"}, {"end": 17972, "text": "This same popularity has also driven a large body of work comparing different isosurface extraction algorithms.", "rank": 141, "start": 17861, "IsComparative": "0", "id": "st_141"}]}, {"paragraph_info": {"end": 18966, "start": 17972, "text": "Previous researchers have examined topological issues <127, 94>, mesh quality <33, 153>, accuracy <131, 195>, and performance <165>.The influence of different reconstruction schemes and filters in scalar visualization has also been examined <16, 139>.In this chapter, we focus on techniques to verify the correctness of algorithms and their corresponding implementa- tions.In particular, we provide mathematical tools that other researchers and developers can use to increase their confidence in the correctness of their own isosurface extraction codes.A traditional way to test implementations in scientific visualization is to perform a visual inspection of the results of the Marschner-Lobb dataset <102>.In the context of isosurface extraction, researchers routinely use tools such as Metro <24> to quantitatively measure the distance between a single pair of surfaces.We argue that the methodology presented here is more effective and more explicit at elucidating a techniques limitations.", "rank": 44, "paragraph_comparative_number": 5, "entities": [], "id": "p_44"}, "sentences": [{"end": 18104, "text": "Previous researchers have examined topological issues <127, 94>, mesh quality <33, 153>, accuracy <131, 195>, and performance <165>.", "rank": 142, "start": 17972, "IsComparative": "0", "id": "st_142"}, {"end": 18223, "text": "The influence of different reconstruction schemes and filters in scalar visualization has also been examined <16, 139>.", "rank": 143, "start": 18104, "IsComparative": "1", "id": "st_143"}, {"end": 18345, "text": "In this chapter, we focus on techniques to verify the correctness of algorithms and their corresponding implementa- tions.", "rank": 144, "start": 18223, "IsComparative": "1", "id": "st_144"}, {"end": 18525, "text": "In particular, we provide mathematical tools that other researchers and developers can use to increase their confidence in the correctness of their own isosurface extraction codes.", "rank": 145, "start": 18345, "IsComparative": "1", "id": "st_145"}, {"end": 18680, "text": "A traditional way to test implementations in scientific visualization is to perform a visual inspection of the results of the Marschner-Lobb dataset <102>.", "rank": 146, "start": 18525, "IsComparative": "1", "id": "st_146"}, {"end": 18845, "text": "In the context of isosurface extraction, researchers routinely use tools such as Metro <24> to quantitatively measure the distance between a single pair of surfaces.", "rank": 147, "start": 18680, "IsComparative": "1", "id": "st_147"}, {"end": 18966, "text": "We argue that the methodology presented here is more effective and more explicit at elucidating a techniques limitations.", "rank": 148, "start": 18845, "IsComparative": "0", "id": "st_148"}]}, {"paragraph_info": {"end": 19136, "start": 18966, "text": "In particular, our proposal pays closer attention to the interplay between a theoretical convergence analysis and the experimental result of a sequence of approximations.", "rank": 45, "paragraph_comparative_number": 1, "entities": [], "id": "p_45"}, "sentences": [{"end": 19136, "text": "In particular, our proposal pays closer attention to the interplay between a theoretical convergence analysis and the experimental result of a sequence of approximations.", "rank": 149, "start": 18966, "IsComparative": "1", "id": "st_149"}]}, {"paragraph_info": {"end": 19520, "start": 19136, "text": "Globus and Uselton <55> and more recently, Kirby and Silva <76> have pointed out the need for verifying both visualization techniques and the corresponding software im- plementations.In this chapter, we provide concrete tools for the specific case of isosurface extraction.Although this is only one particular technique in visualization, we expect the general technique to generalize.", "rank": 46, "paragraph_comparative_number": 1, "entities": [], "id": "p_46"}, "sentences": [{"end": 19319, "text": "Globus and Uselton <55> and more recently, Kirby and Silva <76> have pointed out the need for verifying both visualization techniques and the corresponding software im- plementations.", "rank": 150, "start": 19136, "IsComparative": "1", "id": "st_150"}, {"end": 19409, "text": "In this chapter, we provide concrete tools for the specific case of isosurface extraction.", "rank": 151, "start": 19319, "IsComparative": "0", "id": "st_151"}, {"end": 19520, "text": "Although this is only one particular technique in visualization, we expect the general technique to generalize.", "rank": 152, "start": 19409, "IsComparative": "0", "id": "st_152"}]}, {"paragraph_info": {"end": 20280, "start": 19520, "text": "It is important to again stress that verification is a process: even when successfully applied to an algorithm and its implementation, one can only concretely claim that the implementation behaves correctly (in the sense of analyzed predicted behavior) for all test cases to which it has been applied.Because the test set, both in terms of model problems and analyzed properties, is open-ended and ever increasing, the verification process must continually be applied to previous and new algorithms as new test sets become available.This does not, however, preclude us from formulating a basic set of metrics against which isosurface extraction methods should be tested, as this is the starting point of the process.This is what we turn to in the next section.", "rank": 47, "paragraph_comparative_number": 3, "entities": [], "id": "p_47"}, "sentences": [{"end": 19821, "text": "It is important to again stress that verification is a process: even when successfully applied to an algorithm and its implementation, one can only concretely claim that the implementation behaves correctly (in the sense of analyzed predicted behavior) for all test cases to which it has been applied.", "rank": 153, "start": 19520, "IsComparative": "1", "id": "st_153"}, {"end": 20053, "text": "Because the test set, both in terms of model problems and analyzed properties, is open-ended and ever increasing, the verification process must continually be applied to previous and new algorithms as new test sets become available.", "rank": 154, "start": 19821, "IsComparative": "1", "id": "st_154"}, {"end": 20236, "text": "This does not, however, preclude us from formulating a basic set of metrics against which isosurface extraction methods should be tested, as this is the starting point of the process.", "rank": 155, "start": 20053, "IsComparative": "1", "id": "st_155"}, {"end": 20280, "text": "This is what we turn to in the next section.", "rank": 156, "start": 20236, "IsComparative": "0", "id": "st_156"}]}, {"paragraph_info": {"end": 20326, "start": 20280, "text": "2.2 Verifying Isosurface Extraction Algorithms", "rank": 48, "paragraph_comparative_number": 0, "entities": [], "id": "p_48"}, "sentences": [{"end": 20326, "text": "2.2 Verifying Isosurface Extraction Algorithms", "rank": 157, "start": 20280, "IsComparative": "0", "id": "st_157"}]}, {"paragraph_info": {"end": 20888, "start": 20326, "text": "In this section, we describe the technique we use for verifying isosurface extraction algorithms, namely the method of manufactured solutions (MMS).We illustrate a possible implementation of MMS in Algorithm 1 and Figure 2.1.This technique requires us to write down the expected behavior of particular features of interest of the object (or model prob- lem) being generated.In our case, we are generating triangular approximations of smooth isosurfaces, and the features of interest are geometric surface convergence, convergence of normals, area, and curvature.", "rank": 49, "paragraph_comparative_number": 3, "entities": [], "id": "p_49"}, "sentences": [{"end": 20474, "text": "In this section, we describe the technique we use for verifying isosurface extraction algorithms, namely the method of manufactured solutions (MMS).", "rank": 158, "start": 20326, "IsComparative": "1", "id": "st_158"}, {"end": 20551, "text": "We illustrate a possible implementation of MMS in Algorithm 1 and Figure 2.1.", "rank": 159, "start": 20474, "IsComparative": "1", "id": "st_159"}, {"end": 20700, "text": "This technique requires us to write down the expected behavior of particular features of interest of the object (or model prob- lem) being generated.", "rank": 160, "start": 20551, "IsComparative": "1", "id": "st_160"}, {"end": 20888, "text": "In our case, we are generating triangular approximations of smooth isosurfaces, and the features of interest are geometric surface convergence, convergence of normals, area, and curvature.", "rank": 161, "start": 20700, "IsComparative": "0", "id": "st_161"}]}, {"paragraph_info": {"end": 21603, "start": 20888, "text": "To use MMS, we first accomplish a mathematical analysis of the expected convergence rate of the features (or characteristics) of interest, known in the numerical literature as the formal order of accuracy of the characteristic.This analysis is done for solutions of the problem that can be conveniently described and analyzed (these are the manufactured solutions).Then, the code is executed with progressively refined versions of the data that are used in the generation or sampling of the manufactured solution.Finally, the empirical convergence rate is compared to the one predicted by the analysis.When the convergence rates are comparable, we increase our confidence in the algorithm.If the realizable behavior", "rank": 50, "paragraph_comparative_number": 2, "entities": [], "id": "p_50"}, "sentences": [{"end": 21115, "text": "To use MMS, we first accomplish a mathematical analysis of the expected convergence rate of the features (or characteristics) of interest, known in the numerical literature as the formal order of accuracy of the characteristic.", "rank": 162, "start": 20888, "IsComparative": "1", "id": "st_162"}, {"end": 21253, "text": "This analysis is done for solutions of the problem that can be conveniently described and analyzed (these are the manufactured solutions).", "rank": 163, "start": 21115, "IsComparative": "0", "id": "st_163"}, {"end": 21401, "text": "Then, the code is executed with progressively refined versions of the data that are used in the generation or sampling of the manufactured solution.", "rank": 164, "start": 21253, "IsComparative": "0", "id": "st_164"}, {"end": 21490, "text": "Finally, the empirical convergence rate is compared to the one predicted by the analysis.", "rank": 165, "start": 21401, "IsComparative": "0", "id": "st_165"}, {"end": 21577, "text": "When the convergence rates are comparable, we increase our confidence in the algorithm.", "rank": 166, "start": 21490, "IsComparative": "1", "id": "st_166"}, {"end": 21603, "text": "If the realizable behavior", "rank": 167, "start": 21577, "IsComparative": "0", "id": "st_167"}]}, {"paragraph_info": {"end": 22417, "start": 21603, "text": "In what follows, we will derive expected orders of accuracy for several features of surfaces produced by isosurface extraction codes.We keep our assumptions about the actual algorithms to a minimum to maximize the applicability of the arguments given.We essentially only assume that the maximum triangle size can be bounded above at any time, and use Taylor series arguments (under assumptions of smoothness) to derive convergence rates.It is important to point out that order of accuracy analysis of polyhedral surfaces has been studied by many researchers <110, 190, 191, 62>.In fact, the results presented below are in agreement with the ones reported in the literature.However, because we are considering isosurface extraction, some of our arguments benefit by being able to be condensed to simpler statements.", "rank": 51, "paragraph_comparative_number": 3, "entities": [], "id": "p_51"}, "sentences": [{"end": 21736, "text": "In what follows, we will derive expected orders of accuracy for several features of surfaces produced by isosurface extraction codes.", "rank": 168, "start": 21603, "IsComparative": "0", "id": "st_168"}, {"end": 21854, "text": "We keep our assumptions about the actual algorithms to a minimum to maximize the applicability of the arguments given.", "rank": 169, "start": 21736, "IsComparative": "1", "id": "st_169"}, {"end": 22040, "text": "We essentially only assume that the maximum triangle size can be bounded above at any time, and use Taylor series arguments (under assumptions of smoothness) to derive convergence rates.", "rank": 170, "start": 21854, "IsComparative": "1", "id": "st_170"}, {"end": 22181, "text": "It is important to point out that order of accuracy analysis of polyhedral surfaces has been studied by many researchers <110, 190, 191, 62>.", "rank": 171, "start": 22040, "IsComparative": "0", "id": "st_171"}, {"end": 22276, "text": "In fact, the results presented below are in agreement with the ones reported in the literature.", "rank": 172, "start": 22181, "IsComparative": "0", "id": "st_172"}, {"end": 22417, "text": "However, because we are considering isosurface extraction, some of our arguments benefit by being able to be condensed to simpler statements.", "rank": 173, "start": 22276, "IsComparative": "1", "id": "st_173"}]}, {"paragraph_info": {"end": 22453, "start": 22417, "text": "2.2.1 Convergence of Vertex Position", "rank": 52, "paragraph_comparative_number": 0, "entities": [], "id": "p_52"}, "sentences": [{"end": 22453, "text": "2.2.1 Convergence of Vertex Position", "rank": 174, "start": 22417, "IsComparative": "0", "id": "st_174"}]}, {"paragraph_info": {"end": 23483, "start": 22453, "text": "We start our analysis of isosurface extraction by studying the convergence of vertex positions.We analyze this convergence indirectly by relating the values of the scalar field at the vertex points and the distance between the vertices and the correct isosurface.Given a value  such that the exact isosurface S is defined by f(x,y,z) = f(v) = , the algebraic distance of v to S is defined as |f (v)  | <167>.Notice that algebraic distances only makes sense for implicit surfaces: it requires a scalar field.In addition, we restrict ourselves to regular isosurfaces, ones where for every point x in S, |f(x)| exists and is nonzero.Then, the geometric distance between v and S is approximated by |f(v)  |/|f(v)| <167>.We illustrate this relation in Figure 2.2.Since, by assumption, |f(x)| > k for some k > 0, and all x in S, convergence in algebraic distance implies convergence in geometric distance.Convergence in algebraic distance, however, is much more tractable mathematically, and this is the item to which we turn our focus.", "rank": 53, "paragraph_comparative_number": 6, "entities": [], "id": "p_53"}, "sentences": [{"end": 22548, "text": "We start our analysis of isosurface extraction by studying the convergence of vertex positions.", "rank": 175, "start": 22453, "IsComparative": "1", "id": "st_175"}, {"end": 22716, "text": "We analyze this convergence indirectly by relating the values of the scalar field at the vertex points and the distance between the vertices and the correct isosurface.", "rank": 176, "start": 22548, "IsComparative": "1", "id": "st_176"}, {"end": 22861, "text": "Given a value  such that the exact isosurface S is defined by f(x,y,z) = f(v) = , the algebraic distance of v to S is defined as |f (v)  | <167>.", "rank": 177, "start": 22716, "IsComparative": "0", "id": "st_177"}, {"end": 22960, "text": "Notice that algebraic distances only makes sense for implicit surfaces: it requires a scalar field.", "rank": 178, "start": 22861, "IsComparative": "1", "id": "st_178"}, {"end": 23083, "text": "In addition, we restrict ourselves to regular isosurfaces, ones where for every point x in S, |f(x)| exists and is nonzero.", "rank": 179, "start": 22960, "IsComparative": "1", "id": "st_179"}, {"end": 23169, "text": "Then, the geometric distance between v and S is approximated by |f(v)  |/|f(v)| <167>.", "rank": 180, "start": 23083, "IsComparative": "0", "id": "st_180"}, {"end": 23211, "text": "We illustrate this relation in Figure 2.2.", "rank": 181, "start": 23169, "IsComparative": "0", "id": "st_181"}, {"end": 23352, "text": "Since, by assumption, |f(x)| > k for some k > 0, and all x in S, convergence in algebraic distance implies convergence in geometric distance.", "rank": 182, "start": 23211, "IsComparative": "1", "id": "st_182"}, {"end": 23483, "text": "Convergence in algebraic distance, however, is much more tractable mathematically, and this is the item to which we turn our focus.", "rank": 183, "start": 23352, "IsComparative": "1", "id": "st_183"}]}, {"paragraph_info": {"end": 24095, "start": 23483, "text": "Many isosurface methods estimate vertex positions through linear interpolation along edgesofagrid.Letf :U R3 Rbetheasmoothrealfunctiondefinedinasubset U = <ax, bx>  <ay, by>  <az, bz>, where <ai, bi>, i  x, y, z are real intervals.We assume the intervals <ai,bi> have the same length and let ax = x0,...,xn = bx, ay = y0,...,yn = by, and az = z0,...,zn = bz be subdivisions for the intervals such that xi = x0 + ih, yi = y0 + ih, zi = z0 +ih, i = 0,...,n, where h is the grid size and cijk = <xi,xi+1><yj,yj+1><zk,zk+1> is a grid cell.Through a Taylor series expansion of f, one can evaluate f at a point p  cijk", "rank": 54, "paragraph_comparative_number": 1, "entities": [], "id": "p_54"}, "sentences": [{"end": 23581, "text": "Many isosurface methods estimate vertex positions through linear interpolation along edgesofagrid.", "rank": 184, "start": 23483, "IsComparative": "1", "id": "st_184"}, {"end": 23714, "text": "Letf :U R3 Rbetheasmoothrealfunctiondefinedinasubset U = <ax, bx>  <ay, by>  <az, bz>, where <ai, bi>, i  x, y, z are real intervals.", "rank": 185, "start": 23581, "IsComparative": "0", "id": "st_185"}, {"end": 24018, "text": "We assume the intervals <ai,bi> have the same length and let ax = x0,...,xn = bx, ay = y0,...,yn = by, and az = z0,...,zn = bz be subdivisions for the intervals such that xi = x0 + ih, yi = y0 + ih, zi = z0 +ih, i = 0,...,n, where h is the grid size and cijk = <xi,xi+1><yj,yj+1><zk,zk+1> is a grid cell.", "rank": 186, "start": 23714, "IsComparative": "0", "id": "st_186"}, {"end": 24095, "text": "Through a Taylor series expansion of f, one can evaluate f at a point p  cijk", "rank": 187, "start": 24018, "IsComparative": "0", "id": "st_187"}]}, {"paragraph_info": {"end": 24123, "start": 24095, "text": "2.2.2 Convergence of Normals", "rank": 55, "paragraph_comparative_number": 0, "entities": [], "id": "p_55"}, "sentences": [{"end": 24123, "text": "2.2.2 Convergence of Normals", "rank": 188, "start": 24095, "IsComparative": "0", "id": "st_188"}]}, {"paragraph_info": {"end": 24300, "start": 24123, "text": "Assume, generally, that the scalar field f (x, y, z) =  can be locally written as a graph of a function in two-variables g(x(u,v),y(u,v)) =   f(x(u,v),y(u,v),zk), as illustrated", "rank": 56, "paragraph_comparative_number": 0, "entities": [], "id": "p_56"}, "sentences": [{"end": 24300, "text": "Assume, generally, that the scalar field f (x, y, z) =  can be locally written as a graph of a function in two-variables g(x(u,v),y(u,v)) =   f(x(u,v),y(u,v),zk), as illustrated", "rank": 189, "start": 24123, "IsComparative": "0", "id": "st_189"}]}, {"paragraph_info": {"end": 24325, "start": 24300, "text": "2.2.3 Convergence of Area", "rank": 57, "paragraph_comparative_number": 0, "entities": [], "id": "p_57"}, "sentences": [{"end": 24325, "text": "2.2.3 Convergence of Area", "rank": 190, "start": 24300, "IsComparative": "0", "id": "st_190"}]}, {"paragraph_info": {"end": 24696, "start": 24325, "text": "Currently, much less is known about convergence in area, compared to convergence of vertices or normals.To illustrate the difficulty involved in approximating lengths and areas, consider the sequence of approximations to a straight line shown in Figure 2.4.Even though the function sequence converges uniformly to the line, the length of the approximation stays constant.", "rank": 58, "paragraph_comparative_number": 1, "entities": [], "id": "p_58"}, "sentences": [{"end": 24429, "text": "Currently, much less is known about convergence in area, compared to convergence of vertices or normals.", "rank": 191, "start": 24325, "IsComparative": "0", "id": "st_191"}, {"end": 24582, "text": "To illustrate the difficulty involved in approximating lengths and areas, consider the sequence of approximations to a straight line shown in Figure 2.4.", "rank": 192, "start": 24429, "IsComparative": "0", "id": "st_192"}, {"end": 24696, "text": "Even though the function sequence converges uniformly to the line, the length of the approximation stays constant.", "rank": 193, "start": 24582, "IsComparative": "1", "id": "st_193"}]}, {"paragraph_info": {"end": 25290, "start": 24696, "text": "To the best of our knowledge, the only relevant results establish convergence in area given convergence in vertex positions and convergence in normals, such as in Hildebrandt et al.<62>.However, the authors only establish asymptotic convergence, with no order of accuracy associated with it.The argument is more mathematically involved than space allows here, so we refer the reader to that paper.Currently, this means that the only information the observed order of accuracy provides to us is that if we expect convergence in normals, we should also expect convergence in area, and vice-versa.", "rank": 59, "paragraph_comparative_number": 4, "entities": [], "id": "p_59"}, "sentences": [{"end": 24877, "text": "To the best of our knowledge, the only relevant results establish convergence in area given convergence in vertex positions and convergence in normals, such as in Hildebrandt et al.", "rank": 194, "start": 24696, "IsComparative": "1", "id": "st_194"}, {"end": 24882, "text": "<62>.", "rank": 195, "start": 24877, "IsComparative": "1", "id": "st_195"}, {"end": 24987, "text": "However, the authors only establish asymptotic convergence, with no order of accuracy associated with it.", "rank": 196, "start": 24882, "IsComparative": "1", "id": "st_196"}, {"end": 25093, "text": "The argument is more mathematically involved than space allows here, so we refer the reader to that paper.", "rank": 197, "start": 24987, "IsComparative": "0", "id": "st_197"}, {"end": 25290, "text": "Currently, this means that the only information the observed order of accuracy provides to us is that if we expect convergence in normals, we should also expect convergence in area, and vice-versa.", "rank": 198, "start": 25093, "IsComparative": "1", "id": "st_198"}]}, {"paragraph_info": {"end": 25320, "start": 25290, "text": "2.2.4 Convergence of Curvature", "rank": 60, "paragraph_comparative_number": 0, "entities": [], "id": "p_60"}, "sentences": [{"end": 25320, "text": "2.2.4 Convergence of Curvature", "rank": 199, "start": 25290, "IsComparative": "0", "id": "st_199"}]}, {"paragraph_info": {"end": 25404, "start": 25320, "text": "The following formula gives an estimate of the curvature at a vertex p: K(p)= 2 ii+1", "rank": 61, "paragraph_comparative_number": 1, "entities": [], "id": "p_61"}, "sentences": [{"end": 25404, "text": "The following formula gives an estimate of the curvature at a vertex p: K(p)= 2 ii+1", "rank": 200, "start": 25320, "IsComparative": "1", "id": "st_200"}]}, {"paragraph_info": {"end": 25562, "start": 25404, "text": "Subsequently, Xu <190> presented a very particular distribution of vertices around p under which the curvature estimated by Equation (2.9) has accuracy O(h2).", "rank": 62, "paragraph_comparative_number": 0, "entities": [], "id": "p_62"}, "sentences": [{"end": 25562, "text": "Subsequently, Xu <190> presented a very particular distribution of vertices around p under which the curvature estimated by Equation (2.9) has accuracy O(h2).", "rank": 201, "start": 25404, "IsComparative": "0", "id": "st_201"}]}, {"paragraph_info": {"end": 26624, "start": 25562, "text": "Curvature discretization schemes other than the one given in Equation (2.9) such as the quadratic-fit and spherical-image method (see Meek and Walton <110> for details) also demand particular vertex distributions to ensure convergence.In our context of keeping the analysis applicable for many isosurfacing algorithms, this means we cannot use the lack of observed curvature convergence as an indication of problematic behavior.Based on the results mentioned above, one should actually expect curvature not to converge for most isosurface extraction algorithms.More generally, this indicates a weakness of MMS, namely that some features of interest (such as curvature) will not have sufficient theoretical order of accuracy to be used in numerical measurements.Notice, in addition, that if we had not written down the theoretical model for curvature convergence, we might have expected some sort of curvature approximation.Even a negative result such as the one presented in this section can increase the confidence in the results generated by an implementation.", "rank": 63, "paragraph_comparative_number": 1, "entities": [], "id": "p_63"}, "sentences": [{"end": 25797, "text": "Curvature discretization schemes other than the one given in Equation (2.9) such as the quadratic-fit and spherical-image method (see Meek and Walton <110> for details) also demand particular vertex distributions to ensure convergence.", "rank": 202, "start": 25562, "IsComparative": "0", "id": "st_202"}, {"end": 25990, "text": "In our context of keeping the analysis applicable for many isosurfacing algorithms, this means we cannot use the lack of observed curvature convergence as an indication of problematic behavior.", "rank": 203, "start": 25797, "IsComparative": "1", "id": "st_203"}, {"end": 26123, "text": "Based on the results mentioned above, one should actually expect curvature not to converge for most isosurface extraction algorithms.", "rank": 204, "start": 25990, "IsComparative": "0", "id": "st_204"}, {"end": 26323, "text": "More generally, this indicates a weakness of MMS, namely that some features of interest (such as curvature) will not have sufficient theoretical order of accuracy to be used in numerical measurements.", "rank": 205, "start": 26123, "IsComparative": "0", "id": "st_205"}, {"end": 26485, "text": "Notice, in addition, that if we had not written down the theoretical model for curvature convergence, we might have expected some sort of curvature approximation.", "rank": 206, "start": 26323, "IsComparative": "0", "id": "st_206"}, {"end": 26624, "text": "Even a negative result such as the one presented in this section can increase the confidence in the results generated by an implementation.", "rank": 207, "start": 26485, "IsComparative": "0", "id": "st_207"}]}, {"paragraph_info": {"end": 26648, "start": 26624, "text": "2.3 Experimental Results", "rank": 64, "paragraph_comparative_number": 0, "entities": [], "id": "p_64"}, "sentences": [{"end": 26648, "text": "2.3 Experimental Results", "rank": 208, "start": 26624, "IsComparative": "0", "id": "st_208"}]}, {"paragraph_info": {"end": 27129, "start": 26648, "text": "In this section, we present the results of applying the afore-described methodology.We use the framework to verify six different isosurface extraction codes, namely: VTK Marching Cubes <100>, SnapMC <141>, Macet <33>, Dual Contouring <73>, Afront <153>, and DelIso <32>.All these implementations are open source and/or publicly available.Before presenting the actual results of subjecting these implementations to the verification process, we briefly review their salient features.", "rank": 65, "paragraph_comparative_number": 2, "entities": [], "id": "p_65"}, "sentences": [{"end": 26732, "text": "In this section, we present the results of applying the afore-described methodology.", "rank": 209, "start": 26648, "IsComparative": "0", "id": "st_209"}, {"end": 26918, "text": "We use the framework to verify six different isosurface extraction codes, namely: VTK Marching Cubes <100>, SnapMC <141>, Macet <33>, Dual Contouring <73>, Afront <153>, and DelIso <32>.", "rank": 210, "start": 26732, "IsComparative": "1", "id": "st_210"}, {"end": 26986, "text": "All these implementations are open source and/or publicly available.", "rank": 211, "start": 26918, "IsComparative": "0", "id": "st_211"}, {"end": 27129, "text": "Before presenting the actual results of subjecting these implementations to the verification process, we briefly review their salient features.", "rank": 212, "start": 26986, "IsComparative": "1", "id": "st_212"}]}, {"paragraph_info": {"end": 27153, "start": 27129, "text": "2.3.1 VTK Marching Cubes", "rank": 66, "paragraph_comparative_number": 0, "entities": [], "id": "p_66"}, "sentences": [{"end": 27153, "text": "2.3.1 VTK Marching Cubes", "rank": 213, "start": 27129, "IsComparative": "0", "id": "st_213"}]}, {"paragraph_info": {"end": 27831, "start": 27153, "text": "Marching Cubes <100> (MC) is arguably the most popular isosurface extraction algo- rithm.It reduces the problem of generating an isosurface triangulation to a finite set of cases by considering the signs of how the isosurface intersects each cell of a regular background grid.As there are only 256 different types of intersections between the isosurface and a regular Cartesian 3D cell, a template of triangles is set to each case, making the implementation quite simple through a look-up table.The vertices of the triangles lie on the edges of the cubic cells, and they are computed by linearly interpolating the implicit function values stored at the corners of the grid cell.", "rank": 67, "paragraph_comparative_number": 1, "entities": [], "id": "p_67"}, "sentences": [{"end": 27242, "text": "Marching Cubes <100> (MC) is arguably the most popular isosurface extraction algo- rithm.", "rank": 214, "start": 27153, "IsComparative": "0", "id": "st_214"}, {"end": 27429, "text": "It reduces the problem of generating an isosurface triangulation to a finite set of cases by considering the signs of how the isosurface intersects each cell of a regular background grid.", "rank": 215, "start": 27242, "IsComparative": "1", "id": "st_215"}, {"end": 27648, "text": "As there are only 256 different types of intersections between the isosurface and a regular Cartesian 3D cell, a template of triangles is set to each case, making the implementation quite simple through a look-up table.", "rank": 216, "start": 27429, "IsComparative": "0", "id": "st_216"}, {"end": 27831, "text": "The vertices of the triangles lie on the edges of the cubic cells, and they are computed by linearly interpolating the implicit function values stored at the corners of the grid cell.", "rank": 217, "start": 27648, "IsComparative": "0", "id": "st_217"}]}, {"paragraph_info": {"end": 27843, "start": 27831, "text": "2.3.2 SnapMC", "rank": 68, "paragraph_comparative_number": 0, "entities": [], "id": "p_68"}, "sentences": [{"end": 27843, "text": "2.3.2 SnapMC", "rank": 218, "start": 27831, "IsComparative": "0", "id": "st_218"}]}, {"paragraph_info": {"end": 28458, "start": 27843, "text": "SnapMC <141> is a recently proposed algorithm that extends the original Marching Cubes look-up table to cases where the isosurface goes exactly through the corners of the back- ground grid.The new look-up table is automatically built by an adaptation of the convex hull scheme proposed by Bhaniramka et al.<6>.Even though the traditional Marching Cubes algorithm can easily handle these cases by some kind of symbolic perturbation, SnapMC perturbs the scalar field to avoid edge intersections close to grid corners.In particular, it changes the values on the grid so that the surface is snapped to the grid corners.", "rank": 69, "paragraph_comparative_number": 4, "entities": [], "id": "p_69"}, "sentences": [{"end": 28032, "text": "SnapMC <141> is a recently proposed algorithm that extends the original Marching Cubes look-up table to cases where the isosurface goes exactly through the corners of the back- ground grid.", "rank": 219, "start": 27843, "IsComparative": "1", "id": "st_219"}, {"end": 28149, "text": "The new look-up table is automatically built by an adaptation of the convex hull scheme proposed by Bhaniramka et al.", "rank": 220, "start": 28032, "IsComparative": "0", "id": "st_220"}, {"end": 28153, "text": "<6>.", "rank": 221, "start": 28149, "IsComparative": "1", "id": "st_221"}, {"end": 28358, "text": "Even though the traditional Marching Cubes algorithm can easily handle these cases by some kind of symbolic perturbation, SnapMC perturbs the scalar field to avoid edge intersections close to grid corners.", "rank": 222, "start": 28153, "IsComparative": "1", "id": "st_222"}, {"end": 28458, "text": "In particular, it changes the values on the grid so that the surface is snapped to the grid corners.", "rank": 223, "start": 28358, "IsComparative": "1", "id": "st_223"}]}, {"paragraph_info": {"end": 28469, "start": 28458, "text": "2.3.3 Macet", "rank": 70, "paragraph_comparative_number": 0, "entities": [], "id": "p_70"}, "sentences": [{"end": 28469, "text": "2.3.3 Macet", "rank": 224, "start": 28458, "IsComparative": "0", "id": "st_224"}]}, {"paragraph_info": {"end": 29001, "start": 28469, "text": "Macet <33> is another variant of Marching Cubes that tries to improve the shape of the triangles in a mesh.Unlike SnapMC, it perturbs the active edges of Marching Cubes cases by moving the vertices before the triangulation step.The motivation behind Macet is that poorly-shaped triangles tend to be generated when the intersection between the isosurface and a grid cell is approximately parallel to an edge of the grid cell.Therefore, some corners of the background grid are displaced so as to avoid the parallel-like intersections.", "rank": 71, "paragraph_comparative_number": 3, "entities": [], "id": "p_71"}, "sentences": [{"end": 28576, "text": "Macet <33> is another variant of Marching Cubes that tries to improve the shape of the triangles in a mesh.", "rank": 225, "start": 28469, "IsComparative": "1", "id": "st_225"}, {"end": 28697, "text": "Unlike SnapMC, it perturbs the active edges of Marching Cubes cases by moving the vertices before the triangulation step.", "rank": 226, "start": 28576, "IsComparative": "1", "id": "st_226"}, {"end": 28893, "text": "The motivation behind Macet is that poorly-shaped triangles tend to be generated when the intersection between the isosurface and a grid cell is approximately parallel to an edge of the grid cell.", "rank": 227, "start": 28697, "IsComparative": "1", "id": "st_227"}, {"end": 29001, "text": "Therefore, some corners of the background grid are displaced so as to avoid the parallel-like intersections.", "rank": 228, "start": 28893, "IsComparative": "0", "id": "st_228"}]}, {"paragraph_info": {"end": 29022, "start": 29001, "text": "2.3.4 Dual Contouring", "rank": 72, "paragraph_comparative_number": 0, "entities": [], "id": "p_72"}, "sentences": [{"end": 29022, "text": "2.3.4 Dual Contouring", "rank": 229, "start": 29001, "IsComparative": "0", "id": "st_229"}]}, {"paragraph_info": {"end": 29712, "start": 29022, "text": "Dual Contouring <73> is a feature-preserving isosurfacing method to extract crack-free surfaces from both uniform and adaptive octree grids.This technique can be seen as a combination of Extended Marching Cubes <81> and SurfaceNets <53> as it makes use of Hermite data and quadratic error function minimization to position the vertices of the surface mesh (as Extended Marching Cubes) and the dual topology to connect such vertices (as SurfaceNets).Dual Contouring tends to generate better quality triangles than Marching Cubes while still being very effective in representing sharp features, rendering this implicit polygonalization method a good alternative to the popular Marching Cubes.", "rank": 73, "paragraph_comparative_number": 3, "entities": [], "id": "p_73"}, "sentences": [{"end": 29162, "text": "Dual Contouring <73> is a feature-preserving isosurfacing method to extract crack-free surfaces from both uniform and adaptive octree grids.", "rank": 230, "start": 29022, "IsComparative": "1", "id": "st_230"}, {"end": 29471, "text": "This technique can be seen as a combination of Extended Marching Cubes <81> and SurfaceNets <53> as it makes use of Hermite data and quadratic error function minimization to position the vertices of the surface mesh (as Extended Marching Cubes) and the dual topology to connect such vertices (as SurfaceNets).", "rank": 231, "start": 29162, "IsComparative": "1", "id": "st_231"}, {"end": 29712, "text": "Dual Contouring tends to generate better quality triangles than Marching Cubes while still being very effective in representing sharp features, rendering this implicit polygonalization method a good alternative to the popular Marching Cubes.", "rank": 232, "start": 29471, "IsComparative": "1", "id": "st_232"}]}, {"paragraph_info": {"end": 29724, "start": 29712, "text": "2.3.5 Afront", "rank": 74, "paragraph_comparative_number": 0, "entities": [], "id": "p_74"}, "sentences": [{"end": 29724, "text": "2.3.5 Afront", "rank": 233, "start": 29712, "IsComparative": "0", "id": "st_233"}]}, {"paragraph_info": {"end": 30548, "start": 29724, "text": "Afront <153> is an advancing-front method for surface extraction.Although we focus on applying Afront to isosurface extraction, it can also be used for remeshing and triangulating point-set surfaces.The outstanding feature of Afront is that it generates triangles adapted to the local details of a surface, namely its maximum absolute curvature.In this sense, Afront is fundamentally different from the other algorithms we analyze.In lieu of grid refinement, we will use its  parameter to control triangulation size.Because the manufactured solution we use is a sphere, reducing  by half is roughly equivalent to reducing the maximum triangle size by half.A full analysis of Afront (and, in particular, the influence of the other main parameter ) warrants further investigation, but is beyond the scope of this dissertation.", "rank": 75, "paragraph_comparative_number": 5, "entities": [], "id": "p_75"}, "sentences": [{"end": 29789, "text": "Afront <153> is an advancing-front method for surface extraction.", "rank": 234, "start": 29724, "IsComparative": "1", "id": "st_234"}, {"end": 29923, "text": "Although we focus on applying Afront to isosurface extraction, it can also be used for remeshing and triangulating point-set surfaces.", "rank": 235, "start": 29789, "IsComparative": "1", "id": "st_235"}, {"end": 30069, "text": "The outstanding feature of Afront is that it generates triangles adapted to the local details of a surface, namely its maximum absolute curvature.", "rank": 236, "start": 29923, "IsComparative": "1", "id": "st_236"}, {"end": 30155, "text": "In this sense, Afront is fundamentally different from the other algorithms we analyze.", "rank": 237, "start": 30069, "IsComparative": "0", "id": "st_237"}, {"end": 30240, "text": "In lieu of grid refinement, we will use its  parameter to control triangulation size.", "rank": 238, "start": 30155, "IsComparative": "1", "id": "st_238"}, {"end": 30380, "text": "Because the manufactured solution we use is a sphere, reducing  by half is roughly equivalent to reducing the maximum triangle size by half.", "rank": 239, "start": 30240, "IsComparative": "0", "id": "st_239"}, {"end": 30548, "text": "A full analysis of Afront (and, in particular, the influence of the other main parameter ) warrants further investigation, but is beyond the scope of this dissertation.", "rank": 240, "start": 30380, "IsComparative": "1", "id": "st_240"}]}, {"paragraph_info": {"end": 30560, "start": 30548, "text": "2.3.6 DelIso", "rank": 76, "paragraph_comparative_number": 0, "entities": [], "id": "p_76"}, "sentences": [{"end": 30560, "text": "2.3.6 DelIso", "rank": 241, "start": 30548, "IsComparative": "0", "id": "st_241"}]}, {"paragraph_info": {"end": 30803, "start": 30560, "text": "DelIso <32> is a Delaunay-based approach for isosurfacing.It computes the restricted Delaunay triangulation from a 3D Voronoi Diagram.We run our tests on a customized version of DelIso 16 bit, and our examples use the default set of parameter.", "rank": 77, "paragraph_comparative_number": 2, "entities": [], "id": "p_77"}, "sentences": [{"end": 30618, "text": "DelIso <32> is a Delaunay-based approach for isosurfacing.", "rank": 242, "start": 30560, "IsComparative": "1", "id": "st_242"}, {"end": 30694, "text": "It computes the restricted Delaunay triangulation from a 3D Voronoi Diagram.", "rank": 243, "start": 30618, "IsComparative": "0", "id": "st_243"}, {"end": 30803, "text": "We run our tests on a customized version of DelIso 16 bit, and our examples use the default set of parameter.", "rank": 244, "start": 30694, "IsComparative": "1", "id": "st_244"}]}, {"paragraph_info": {"end": 31028, "start": 30803, "text": "In what follows, we present the results of applying the verification process to these algorithms.We will describe the manufactured solutions we use and their observed conver- gence rate on the isosurface extraction algorithm.", "rank": 78, "paragraph_comparative_number": 1, "entities": [], "id": "p_78"}, "sentences": [{"end": 30900, "text": "In what follows, we present the results of applying the verification process to these algorithms.", "rank": 245, "start": 30803, "IsComparative": "0", "id": "st_245"}, {"end": 31028, "text": "We will describe the manufactured solutions we use and their observed conver- gence rate on the isosurface extraction algorithm.", "rank": 246, "start": 30900, "IsComparative": "1", "id": "st_246"}]}, {"paragraph_info": {"end": 31060, "start": 31028, "text": "2.3.7 Observed Order of Accuracy", "rank": 79, "paragraph_comparative_number": 0, "entities": [], "id": "p_79"}, "sentences": [{"end": 31060, "text": "2.3.7 Observed Order of Accuracy", "rank": 247, "start": 31028, "IsComparative": "0", "id": "st_247"}]}, {"paragraph_info": {"end": 31451, "start": 31060, "text": "We start by investigating the behavior of the algorithms under the manufactured solution given by the scalar field f(x,y,z) = x2 + y2 + z2  1 and isosurface f(x,y,z) = 0 in the domain D = <4, 4>3.Let S k be a simplicial complex that approximates S for a given discretization parameter k (cell size h for marching cubes-based methods, accuracy  for Afront, and maximum edge size  for DelIso).", "rank": 80, "paragraph_comparative_number": 0, "entities": [], "id": "p_80"}, "sentences": [{"end": 31256, "text": "We start by investigating the behavior of the algorithms under the manufactured solution given by the scalar field f(x,y,z) = x2 + y2 + z2  1 and isosurface f(x,y,z) = 0 in the domain D = <4, 4>3.", "rank": 248, "start": 31060, "IsComparative": "0", "id": "st_248"}, {"end": 31451, "text": "Let S k be a simplicial complex that approximates S for a given discretization parameter k (cell size h for marching cubes-based methods, accuracy  for Afront, and maximum edge size  for DelIso).", "rank": 249, "start": 31256, "IsComparative": "0", "id": "st_249"}]}, {"paragraph_info": {"end": 32295, "start": 31451, "text": "The order of accuracy for VTK Marching Cubes, SnapMC, Macet, and Dual Contouring depends on the cell size h.We run our tests with grid refinement hi+1 = hi/2 and initial condition h1.For Afront, the order of accuracy depends on parameter , thus the refinement is given by i+1 = i/2 with initial condition 1.Our customized version of DelIso has an additional parameter  that controls the largest edge on the output mesh.In this case, the refinement formula is i+1 = i/2.In the particular case of SnapMC, we set the snap parameter  to its maximum value ( = 1/2).Even though the manufactured solution we selected is about as simple as can be imagined, comparing the formal order of accuracy with the observed one was enough to suggest bugs in two implementations.The observed order of accuracy of the examined properties is presented on Table 2.1.", "rank": 81, "paragraph_comparative_number": 3, "entities": [], "id": "p_81"}, "sentences": [{"end": 31559, "text": "The order of accuracy for VTK Marching Cubes, SnapMC, Macet, and Dual Contouring depends on the cell size h.", "rank": 250, "start": 31451, "IsComparative": "0", "id": "st_250"}, {"end": 31634, "text": "We run our tests with grid refinement hi+1 = hi/2 and initial condition h1.", "rank": 251, "start": 31559, "IsComparative": "0", "id": "st_251"}, {"end": 31758, "text": "For Afront, the order of accuracy depends on parameter , thus the refinement is given by i+1 = i/2 with initial condition 1.", "rank": 252, "start": 31634, "IsComparative": "0", "id": "st_252"}, {"end": 31870, "text": "Our customized version of DelIso has an additional parameter  that controls the largest edge on the output mesh.", "rank": 253, "start": 31758, "IsComparative": "1", "id": "st_253"}, {"end": 31920, "text": "In this case, the refinement formula is i+1 = i/2.", "rank": 254, "start": 31870, "IsComparative": "0", "id": "st_254"}, {"end": 32011, "text": "In the particular case of SnapMC, we set the snap parameter  to its maximum value ( = 1/2).", "rank": 255, "start": 31920, "IsComparative": "1", "id": "st_255"}, {"end": 32211, "text": "Even though the manufactured solution we selected is about as simple as can be imagined, comparing the formal order of accuracy with the observed one was enough to suggest bugs in two implementations.", "rank": 256, "start": 32011, "IsComparative": "1", "id": "st_256"}, {"end": 32295, "text": "The observed order of accuracy of the examined properties is presented on Table 2.1.", "rank": 257, "start": 32211, "IsComparative": "0", "id": "st_257"}]}, {"paragraph_info": {"end": 32321, "start": 32295, "text": "2.3.7.1 Algebraic distance", "rank": 82, "paragraph_comparative_number": 0, "entities": [], "id": "p_82"}, "sentences": [{"end": 32321, "text": "2.3.7.1 Algebraic distance", "rank": 258, "start": 32295, "IsComparative": "0", "id": "st_258"}]}, {"paragraph_info": {"end": 32494, "start": 32321, "text": "Section 2.2.1 shows that one expects second-order convergence for function value on vertices if linear interpolation is used.We define the following approximation error on L", "rank": 83, "paragraph_comparative_number": 0, "entities": [], "id": "p_83"}, "sentences": [{"end": 32446, "text": "Section 2.2.1 shows that one expects second-order convergence for function value on vertices if linear interpolation is used.", "rank": 259, "start": 32321, "IsComparative": "0", "id": "st_259"}, {"end": 32494, "text": "We define the following approximation error on L", "rank": 260, "start": 32446, "IsComparative": "0", "id": "st_260"}]}, {"paragraph_info": {"end": 32509, "start": 32494, "text": "2.3.7.2 Normals", "rank": 84, "paragraph_comparative_number": 0, "entities": [], "id": "p_84"}, "sentences": [{"end": 32509, "text": "2.3.7.2 Normals", "rank": 261, "start": 32494, "IsComparative": "0", "id": "st_261"}]}, {"paragraph_info": {"end": 33099, "start": 32509, "text": "Section 2.2.2 shows that one expects first-order of accuracy for normal computations.We define the following approximation error using L norm: where j is the angle between the normal of the triangle j and the normal of the point in S closest to the centroid of j. As shown in Figure 2.5(b), VTK Marching Cubes, Afront, SnapMC, and DelIso have good observed order of accuracy above 0.8.However, only VTK Marching Cubes and DelIso present close proximity to linear.Macet and Dual Contouring once again do not present a consistent order.Figure 2.6(b) shows the results after fixing both codes.", "rank": 85, "paragraph_comparative_number": 2, "entities": [], "id": "p_85"}, "sentences": [{"end": 32594, "text": "Section 2.2.2 shows that one expects first-order of accuracy for normal computations.", "rank": 262, "start": 32509, "IsComparative": "1", "id": "st_262"}, {"end": 32894, "text": "We define the following approximation error using L norm: where j is the angle between the normal of the triangle j and the normal of the point in S closest to the centroid of j. As shown in Figure 2.5(b), VTK Marching Cubes, Afront, SnapMC, and DelIso have good observed order of accuracy above 0.8.", "rank": 263, "start": 32594, "IsComparative": "1", "id": "st_263"}, {"end": 32972, "text": "However, only VTK Marching Cubes and DelIso present close proximity to linear.", "rank": 264, "start": 32894, "IsComparative": "0", "id": "st_264"}, {"end": 33043, "text": "Macet and Dual Contouring once again do not present a consistent order.", "rank": 265, "start": 32972, "IsComparative": "0", "id": "st_265"}, {"end": 33099, "text": "Figure 2.6(b) shows the results after fixing both codes.", "rank": 266, "start": 33043, "IsComparative": "0", "id": "st_266"}]}, {"paragraph_info": {"end": 33111, "start": 33099, "text": "2.3.7.3 Area", "rank": 86, "paragraph_comparative_number": 0, "entities": [], "id": "p_86"}, "sentences": [{"end": 33111, "text": "2.3.7.3 Area", "rank": 267, "start": 33099, "IsComparative": "0", "id": "st_267"}]}, {"paragraph_info": {"end": 33887, "start": 33111, "text": "Although there is no formal order of accuracy for area, one expects some convergence for it (Section 2.2.3).We define the following approximation error: where A is the area function of a continuous or piecewise-linear surface.The results are shown in Figure 2.5(c).VTK Marching Cubes, Afront, and DelIso present second-order of accuracy, as shown in Figure 2.5(c).SnapMC accuracy is slightly better than quadratic due to poor approximation for large h.The error dropped faster than quadratic when the grid was refined for the first time.Macet and Dual Contouring exhibit once again unexpected behavior.Unlike the previous time, the curves now seem to diverge when h is too small.Once the bug is fixed, the convergence curves changes, and they become quadratic (Figure 2.6(c)).", "rank": 87, "paragraph_comparative_number": 2, "entities": [], "id": "p_87"}, "sentences": [{"end": 33219, "text": "Although there is no formal order of accuracy for area, one expects some convergence for it (Section 2.2.3).", "rank": 268, "start": 33111, "IsComparative": "1", "id": "st_268"}, {"end": 33337, "text": "We define the following approximation error: where A is the area function of a continuous or piecewise-linear surface.", "rank": 269, "start": 33219, "IsComparative": "0", "id": "st_269"}, {"end": 33376, "text": "The results are shown in Figure 2.5(c).", "rank": 270, "start": 33337, "IsComparative": "0", "id": "st_270"}, {"end": 33475, "text": "VTK Marching Cubes, Afront, and DelIso present second-order of accuracy, as shown in Figure 2.5(c).", "rank": 271, "start": 33376, "IsComparative": "0", "id": "st_271"}, {"end": 33563, "text": "SnapMC accuracy is slightly better than quadratic due to poor approximation for large h.", "rank": 272, "start": 33475, "IsComparative": "1", "id": "st_272"}, {"end": 33648, "text": "The error dropped faster than quadratic when the grid was refined for the first time.", "rank": 273, "start": 33563, "IsComparative": "0", "id": "st_273"}, {"end": 33713, "text": "Macet and Dual Contouring exhibit once again unexpected behavior.", "rank": 274, "start": 33648, "IsComparative": "0", "id": "st_274"}, {"end": 33790, "text": "Unlike the previous time, the curves now seem to diverge when h is too small.", "rank": 275, "start": 33713, "IsComparative": "0", "id": "st_275"}, {"end": 33887, "text": "Once the bug is fixed, the convergence curves changes, and they become quadratic (Figure 2.6(c)).", "rank": 276, "start": 33790, "IsComparative": "0", "id": "st_276"}]}, {"paragraph_info": {"end": 33904, "start": 33887, "text": "2.3.7.4 Curvature", "rank": 88, "paragraph_comparative_number": 0, "entities": [], "id": "p_88"}, "sentences": [{"end": 33904, "text": "2.3.7.4 Curvature", "rank": 277, "start": 33887, "IsComparative": "0", "id": "st_277"}]}, {"paragraph_info": {"end": 34623, "start": 33904, "text": "Section 2.2.4 shows that one expects zero-th order of accuracy for curvature computation.We define the approximation error using L norm: where K(v) is the Gaussian curvature at v  S and K (v) is the Gaussian curvature at v  S .In this particular case where S is a sphere, K(v) = 1 for every v  S.The results are shown in Figure 2.5(d).DelIso, Afront, and SnapMC are close to zeroth-order accuracy.The curvature order of accuracy for VTK Marching Cubes, on the other hand, diverges significantly.This unexpected behavior might deserve further investigation which we leave for future work.Although the curves shown in Figure 2.5(d) for Macet and Dual Contouring diverge, they change after fixing the code (Figure 2.6(d)).", "rank": 89, "paragraph_comparative_number": 1, "entities": [], "id": "p_89"}, "sentences": [{"end": 33993, "text": "Section 2.2.4 shows that one expects zero-th order of accuracy for curvature computation.", "rank": 278, "start": 33904, "IsComparative": "1", "id": "st_278"}, {"end": 34131, "text": "We define the approximation error using L norm: where K(v) is the Gaussian curvature at v  S and K (v) is the Gaussian curvature at v  S .", "rank": 279, "start": 33993, "IsComparative": "0", "id": "st_279"}, {"end": 34200, "text": "In this particular case where S is a sphere, K(v) = 1 for every v  S.", "rank": 280, "start": 34131, "IsComparative": "0", "id": "st_280"}, {"end": 34239, "text": "The results are shown in Figure 2.5(d).", "rank": 281, "start": 34200, "IsComparative": "0", "id": "st_281"}, {"end": 34301, "text": "DelIso, Afront, and SnapMC are close to zeroth-order accuracy.", "rank": 282, "start": 34239, "IsComparative": "0", "id": "st_282"}, {"end": 34399, "text": "The curvature order of accuracy for VTK Marching Cubes, on the other hand, diverges significantly.", "rank": 283, "start": 34301, "IsComparative": "0", "id": "st_283"}, {"end": 34491, "text": "This unexpected behavior might deserve further investigation which we leave for future work.", "rank": 284, "start": 34399, "IsComparative": "0", "id": "st_284"}, {"end": 34623, "text": "Although the curves shown in Figure 2.5(d) for Macet and Dual Contouring diverge, they change after fixing the code (Figure 2.6(d)).", "rank": 285, "start": 34491, "IsComparative": "0", "id": "st_285"}]}, {"paragraph_info": {"end": 34642, "start": 34623, "text": "2.3.8 Detected Bugs", "rank": 90, "paragraph_comparative_number": 0, "entities": [], "id": "p_90"}, "sentences": [{"end": 34642, "text": "2.3.8 Detected Bugs", "rank": 286, "start": 34623, "IsComparative": "0", "id": "st_286"}]}, {"paragraph_info": {"end": 35410, "start": 34642, "text": "We were able to find and fix bugs in two of the implementations under verification, namely, Macet and Dual Contouring, using as manufactured solution a sphere centered at origin with radius 1.The new result curves are shown in Figure 2.6.The observed order of accuracy for Dual Contouring is quite satisfactory for all manufactured solution.In particular, the normal order of accuracy has the best rate among the methods.Macet improved for its results for area.On the other hand, it still has some issues related to normals, which perhaps indicates a need for more tests and verification.The new order of accuracy for algebraic distance (Figure 2.6(a)) does not tell us much about the correctness of the code because of the zero-th order of accuracy (same for Afront).", "rank": 91, "paragraph_comparative_number": 5, "entities": [], "id": "p_91"}, "sentences": [{"end": 34834, "text": "We were able to find and fix bugs in two of the implementations under verification, namely, Macet and Dual Contouring, using as manufactured solution a sphere centered at origin with radius 1.", "rank": 287, "start": 34642, "IsComparative": "1", "id": "st_287"}, {"end": 34880, "text": "The new result curves are shown in Figure 2.6.", "rank": 288, "start": 34834, "IsComparative": "0", "id": "st_288"}, {"end": 34983, "text": "The observed order of accuracy for Dual Contouring is quite satisfactory for all manufactured solution.", "rank": 289, "start": 34880, "IsComparative": "0", "id": "st_289"}, {"end": 35063, "text": "In particular, the normal order of accuracy has the best rate among the methods.", "rank": 290, "start": 34983, "IsComparative": "1", "id": "st_290"}, {"end": 35103, "text": "Macet improved for its results for area.", "rank": 291, "start": 35063, "IsComparative": "1", "id": "st_291"}, {"end": 35230, "text": "On the other hand, it still has some issues related to normals, which perhaps indicates a need for more tests and verification.", "rank": 292, "start": 35103, "IsComparative": "1", "id": "st_292"}, {"end": 35410, "text": "The new order of accuracy for algebraic distance (Figure 2.6(a)) does not tell us much about the correctness of the code because of the zero-th order of accuracy (same for Afront).", "rank": 293, "start": 35230, "IsComparative": "1", "id": "st_293"}]}, {"paragraph_info": {"end": 35922, "start": 35410, "text": "The zero-th order of accuracy might happen if the formal order of accuracy is zero-th order, in which case the observed order matches the formal order.It might also happen due to a poor choice for manufactured solution.If it is not complex enough, the implementation being tested may approximate exactly the solution and therefore there is no error within the approximation although another error source (truncation error, for instance) may show up.The next section presents a detailed discussion concerning MMS.", "rank": 92, "paragraph_comparative_number": 1, "entities": [], "id": "p_92"}, "sentences": [{"end": 35561, "text": "The zero-th order of accuracy might happen if the formal order of accuracy is zero-th order, in which case the observed order matches the formal order.", "rank": 294, "start": 35410, "IsComparative": "0", "id": "st_294"}, {"end": 35629, "text": "It might also happen due to a poor choice for manufactured solution.", "rank": 295, "start": 35561, "IsComparative": "1", "id": "st_295"}, {"end": 35859, "text": "If it is not complex enough, the implementation being tested may approximate exactly the solution and therefore there is no error within the approximation although another error source (truncation error, for instance) may show up.", "rank": 296, "start": 35629, "IsComparative": "0", "id": "st_296"}, {"end": 35922, "text": "The next section presents a detailed discussion concerning MMS.", "rank": 297, "start": 35859, "IsComparative": "0", "id": "st_297"}]}, {"paragraph_info": {"end": 36551, "start": 35922, "text": "Although we managed to fix the Macet convergence problem, we were not able to do so in a way that preserves triangle quality.Two were the problems we found in the source code, and we proposed two solutions for one of them.Table 2.2 shows that we could not find any combination that both fixed the convergence problem and preserved the triangle quality simultaneously.This sort of behavior raises the question if there is a theoretical problem that prevents both from being satisfied simultaneously, or it is just a matter of finding a better algorithmic fix.In both cases, further study and subsequent tests must be accomplished.", "rank": 93, "paragraph_comparative_number": 3, "entities": [], "id": "p_93"}, "sentences": [{"end": 36047, "text": "Although we managed to fix the Macet convergence problem, we were not able to do so in a way that preserves triangle quality.", "rank": 298, "start": 35922, "IsComparative": "0", "id": "st_298"}, {"end": 36144, "text": "Two were the problems we found in the source code, and we proposed two solutions for one of them.", "rank": 299, "start": 36047, "IsComparative": "1", "id": "st_299"}, {"end": 36289, "text": "Table 2.2 shows that we could not find any combination that both fixed the convergence problem and preserved the triangle quality simultaneously.", "rank": 300, "start": 36144, "IsComparative": "1", "id": "st_300"}, {"end": 36480, "text": "This sort of behavior raises the question if there is a theoretical problem that prevents both from being satisfied simultaneously, or it is just a matter of finding a better algorithmic fix.", "rank": 301, "start": 36289, "IsComparative": "1", "id": "st_301"}, {"end": 36551, "text": "In both cases, further study and subsequent tests must be accomplished.", "rank": 302, "start": 36480, "IsComparative": "0", "id": "st_302"}]}, {"paragraph_info": {"end": 36565, "start": 36551, "text": "2.4 Discussion", "rank": 94, "paragraph_comparative_number": 0, "entities": [], "id": "p_94"}, "sentences": [{"end": 36565, "text": "2.4 Discussion", "rank": 303, "start": 36551, "IsComparative": "0", "id": "st_303"}]}, {"paragraph_info": {"end": 37035, "start": 36565, "text": "As we have shown, MMS is an effective means of diagnosing problems within the algorithms and implementations of isosurface extraction algorithms.In this work, we have considered the two  algorithm and implementation  as one unit as one cannot always distinguish between the two if only limited information (source code and algorithmic details) is available.In this section, we present a more thorough discussion of the use of MMS, particularly for isosurface extraction.", "rank": 95, "paragraph_comparative_number": 1, "entities": [], "id": "p_95"}, "sentences": [{"end": 36710, "text": "As we have shown, MMS is an effective means of diagnosing problems within the algorithms and implementations of isosurface extraction algorithms.", "rank": 304, "start": 36565, "IsComparative": "0", "id": "st_304"}, {"end": 36922, "text": "In this work, we have considered the two  algorithm and implementation  as one unit as one cannot always distinguish between the two if only limited information (source code and algorithmic details) is available.", "rank": 305, "start": 36710, "IsComparative": "0", "id": "st_305"}, {"end": 37035, "text": "In this section, we present a more thorough discussion of the use of MMS, particularly for isosurface extraction.", "rank": 306, "start": 36922, "IsComparative": "1", "id": "st_306"}]}, {"paragraph_info": {"end": 37077, "start": 37035, "text": "2.4.1 On the Implementation and Use of MMS", "rank": 96, "paragraph_comparative_number": 0, "entities": [], "id": "p_96"}, "sentences": [{"end": 37077, "text": "2.4.1 On the Implementation and Use of MMS", "rank": 307, "start": 37035, "IsComparative": "0", "id": "st_307"}]}, {"paragraph_info": {"end": 38957, "start": 37077, "text": "One of the primary advantages of verifying simulation codes using MMS is that it is a nonintrusive method.MMS treats the code being verified as a blackbox, and so can be easily integrated into an existing test suite with little to no impact.However, MMS does not see the implementation, and so provides little direct information about where a particular bug might be when there is a discrepancy between the formal and observed orders of accuracy.In our experience, there are three main places where mistakes can happen: (1) in the design and construction of the manufactured solution, (2) in the coding of the algorithm being tested, and (3) in the evaluation and interpretation of the results.Mistakes on the evaluation of results have two flavors: misinterpretation or poor formal order of accuracy.The first heavily depends on testers and experts experience and ability to judge what a good result is.For example, should the normal observed order of accuracy for Afront and Macet on Figure 2.5(b) be considered linear (p = 0.80 and p = 0.75, respectively)?The latter depends on a rigorous formal order of accuracy analysis of the algorithm considering all sorts of errors; even round-off errors may be significant.In fact, we spent more time on writing out rigorously the analysis of the formal order of accuracy and on searching for possible sources of error than on the tests themselves.This again highlights the fact that verification using MMS is a process: it is typical to go back to the white board and refine formal analyses before arriving at conclusive answers.Although the formal order of accuracy analysis might be a painful process, the literature has many results that can be promptly used.As a consequence, if one wishes to writes his own MC technique, for instance, his only concern is to write a test which exploits the results available within the literature.", "rank": 97, "paragraph_comparative_number": 5, "entities": [], "id": "p_97"}, "sentences": [{"end": 37183, "text": "One of the primary advantages of verifying simulation codes using MMS is that it is a nonintrusive method.", "rank": 308, "start": 37077, "IsComparative": "0", "id": "st_308"}, {"end": 37318, "text": "MMS treats the code being verified as a blackbox, and so can be easily integrated into an existing test suite with little to no impact.", "rank": 309, "start": 37183, "IsComparative": "0", "id": "st_309"}, {"end": 37523, "text": "However, MMS does not see the implementation, and so provides little direct information about where a particular bug might be when there is a discrepancy between the formal and observed orders of accuracy.", "rank": 310, "start": 37318, "IsComparative": "0", "id": "st_310"}, {"end": 37771, "text": "In our experience, there are three main places where mistakes can happen: (1) in the design and construction of the manufactured solution, (2) in the coding of the algorithm being tested, and (3) in the evaluation and interpretation of the results.", "rank": 311, "start": 37523, "IsComparative": "1", "id": "st_311"}, {"end": 37878, "text": "Mistakes on the evaluation of results have two flavors: misinterpretation or poor formal order of accuracy.", "rank": 312, "start": 37771, "IsComparative": "1", "id": "st_312"}, {"end": 37981, "text": "The first heavily depends on testers and experts experience and ability to judge what a good result is.", "rank": 313, "start": 37878, "IsComparative": "0", "id": "st_313"}, {"end": 38136, "text": "For example, should the normal observed order of accuracy for Afront and Macet on Figure 2.5(b) be considered linear (p = 0.80 and p = 0.75, respectively)?", "rank": 314, "start": 37981, "IsComparative": "0", "id": "st_314"}, {"end": 38294, "text": "The latter depends on a rigorous formal order of accuracy analysis of the algorithm considering all sorts of errors; even round-off errors may be significant.", "rank": 315, "start": 38136, "IsComparative": "0", "id": "st_315"}, {"end": 38469, "text": "In fact, we spent more time on writing out rigorously the analysis of the formal order of accuracy and on searching for possible sources of error than on the tests themselves.", "rank": 316, "start": 38294, "IsComparative": "1", "id": "st_316"}, {"end": 38651, "text": "This again highlights the fact that verification using MMS is a process: it is typical to go back to the white board and refine formal analyses before arriving at conclusive answers.", "rank": 317, "start": 38469, "IsComparative": "1", "id": "st_317"}, {"end": 38784, "text": "Although the formal order of accuracy analysis might be a painful process, the literature has many results that can be promptly used.", "rank": 318, "start": 38651, "IsComparative": "0", "id": "st_318"}, {"end": 38957, "text": "As a consequence, if one wishes to writes his own MC technique, for instance, his only concern is to write a test which exploits the results available within the literature.", "rank": 319, "start": 38784, "IsComparative": "1", "id": "st_319"}]}, {"paragraph_info": {"end": 39009, "start": 38957, "text": "2.4.2 On the Complexity of the Manufactured Solution", "rank": 98, "paragraph_comparative_number": 0, "entities": [], "id": "p_98"}, "sentences": [{"end": 39009, "text": "2.4.2 On the Complexity of the Manufactured Solution", "rank": 320, "start": 38957, "IsComparative": "0", "id": "st_320"}]}, {"paragraph_info": {"end": 39779, "start": 39009, "text": "The complexity of the manufactured solution can have a large influence on the effec- tiveness of verification.Suppose one chooses the manufactured solution to be f(x,y,z) = x+y+k, k constant, instead of a sphere.Since MC-based techniques use linear interpolation, one expects the approximation to be exact regardless of any discretization parameter h, i.e., p = 0 (notice that the evaluated error might be nonzero, implying there is some other error source that does not depend on h).Since such a function f is extremely simple, it might not trigger bugs that would otherwise reduce the observed order of accuracy.In our experiments, the (problematic) implementation of Dual Contouring achieved the formal order of accuracy for this particularly simple function (p = 0).", "rank": 99, "paragraph_comparative_number": 2, "entities": [], "id": "p_99"}, "sentences": [{"end": 39119, "text": "The complexity of the manufactured solution can have a large influence on the effec- tiveness of verification.", "rank": 321, "start": 39009, "IsComparative": "0", "id": "st_321"}, {"end": 39221, "text": "Suppose one chooses the manufactured solution to be f(x,y,z) = x+y+k, k constant, instead of a sphere.", "rank": 322, "start": 39119, "IsComparative": "0", "id": "st_322"}, {"end": 39493, "text": "Since MC-based techniques use linear interpolation, one expects the approximation to be exact regardless of any discretization parameter h, i.e., p = 0 (notice that the evaluated error might be nonzero, implying there is some other error source that does not depend on h).", "rank": 323, "start": 39221, "IsComparative": "1", "id": "st_323"}, {"end": 39623, "text": "Since such a function f is extremely simple, it might not trigger bugs that would otherwise reduce the observed order of accuracy.", "rank": 324, "start": 39493, "IsComparative": "0", "id": "st_324"}, {"end": 39779, "text": "In our experiments, the (problematic) implementation of Dual Contouring achieved the formal order of accuracy for this particularly simple function (p = 0).", "rank": 325, "start": 39623, "IsComparative": "1", "id": "st_325"}]}, {"paragraph_info": {"end": 40530, "start": 39779, "text": "Another example on the influence of manufactured solution arose with in our exami- nation of Afront.Because Afront uses Catmull-Rom splines, some simple isosurfaces will converge to within numerical error for very rough volumes, and the numerically observed order of accuracy will be much lower than expected.With an implicit function whose isosurfaces are spheres, we observed zero-th order of accuracy for Afront for algebraic distance.With a modified implicit function that included transcendental functions, MMS reveals that Afront does not have the expected convergence rate on the full interval, as shown in Figure 2.7.Notice that Macet has similar behavior.Additional tests are needed to determine the source of this behavior within both codes.", "rank": 100, "paragraph_comparative_number": 4, "entities": [], "id": "p_100"}, "sentences": [{"end": 39879, "text": "Another example on the influence of manufactured solution arose with in our exami- nation of Afront.", "rank": 326, "start": 39779, "IsComparative": "1", "id": "st_326"}, {"end": 40088, "text": "Because Afront uses Catmull-Rom splines, some simple isosurfaces will converge to within numerical error for very rough volumes, and the numerically observed order of accuracy will be much lower than expected.", "rank": 327, "start": 39879, "IsComparative": "1", "id": "st_327"}, {"end": 40217, "text": "With an implicit function whose isosurfaces are spheres, we observed zero-th order of accuracy for Afront for algebraic distance.", "rank": 328, "start": 40088, "IsComparative": "1", "id": "st_328"}, {"end": 40404, "text": "With a modified implicit function that included transcendental functions, MMS reveals that Afront does not have the expected convergence rate on the full interval, as shown in Figure 2.7.", "rank": 329, "start": 40217, "IsComparative": "0", "id": "st_329"}, {"end": 40443, "text": "Notice that Macet has similar behavior.", "rank": 330, "start": 40404, "IsComparative": "0", "id": "st_330"}, {"end": 40530, "text": "Additional tests are needed to determine the source of this behavior within both codes.", "rank": 331, "start": 40443, "IsComparative": "1", "id": "st_331"}]}, {"paragraph_info": {"end": 40560, "start": 40530, "text": "2.4.3 On the Order of Accuracy", "rank": 101, "paragraph_comparative_number": 0, "entities": [], "id": "p_101"}, "sentences": [{"end": 40560, "text": "2.4.3 On the Order of Accuracy", "rank": 332, "start": 40530, "IsComparative": "0", "id": "st_332"}]}, {"paragraph_info": {"end": 41407, "start": 40560, "text": "In this chapter, we have chosen to make our formal analysis as generic as possible to accommodate as many implementations under verification as possible.Although we are able to evaluate many codes using the same manufactured solution, when using MMS for a particular code, it is best to exploit as much detail about the algorithm as necessary.If the goal is to design a manufactured solution for verifying Marching Cubes-based techniques, the manufactured solution should exercise all possible cases.Additionally, particular aspects of the manufactured solutions can be incorporated into the formal analysis.For example, the analysis for Afront becomes much more complicated if curvatures are not constant over the surface (in that case, its additional parameter  comes into play <153>, and accurately bounding the triangle size is not practical).", "rank": 102, "paragraph_comparative_number": 4, "entities": [], "id": "p_102"}, "sentences": [{"end": 40713, "text": "In this chapter, we have chosen to make our formal analysis as generic as possible to accommodate as many implementations under verification as possible.", "rank": 333, "start": 40560, "IsComparative": "1", "id": "st_333"}, {"end": 40903, "text": "Although we are able to evaluate many codes using the same manufactured solution, when using MMS for a particular code, it is best to exploit as much detail about the algorithm as necessary.", "rank": 334, "start": 40713, "IsComparative": "1", "id": "st_334"}, {"end": 41060, "text": "If the goal is to design a manufactured solution for verifying Marching Cubes-based techniques, the manufactured solution should exercise all possible cases.", "rank": 335, "start": 40903, "IsComparative": "1", "id": "st_335"}, {"end": 41168, "text": "Additionally, particular aspects of the manufactured solutions can be incorporated into the formal analysis.", "rank": 336, "start": 41060, "IsComparative": "0", "id": "st_336"}, {"end": 41407, "text": "For example, the analysis for Afront becomes much more complicated if curvatures are not constant over the surface (in that case, its additional parameter  comes into play <153>, and accurately bounding the triangle size is not practical).", "rank": 337, "start": 41168, "IsComparative": "1", "id": "st_337"}]}, {"paragraph_info": {"end": 41867, "start": 41407, "text": "The errors in Section 2.3.7 were measured at different locations on the mesh.Vertex convergence and Gaussian curvature were measured on triangle vertices, while normals were measured on the triangle centroid.More importantly, measurements performed at different locations may have different orders of accuracy.For example, Macet has cubic formal order of accuracy on vertices due to the spline approximation but quadratic formal order of accuracy on centroids.", "rank": 103, "paragraph_comparative_number": 0, "entities": [], "id": "p_103"}, "sentences": [{"end": 41484, "text": "The errors in Section 2.3.7 were measured at different locations on the mesh.", "rank": 338, "start": 41407, "IsComparative": "0", "id": "st_338"}, {"end": 41615, "text": "Vertex convergence and Gaussian curvature were measured on triangle vertices, while normals were measured on the triangle centroid.", "rank": 339, "start": 41484, "IsComparative": "0", "id": "st_339"}, {"end": 41717, "text": "More importantly, measurements performed at different locations may have different orders of accuracy.", "rank": 340, "start": 41615, "IsComparative": "0", "id": "st_340"}, {"end": 41867, "text": "For example, Macet has cubic formal order of accuracy on vertices due to the spline approximation but quadratic formal order of accuracy on centroids.", "rank": 341, "start": 41717, "IsComparative": "0", "id": "st_341"}]}, {"paragraph_info": {"end": 42214, "start": 41867, "text": "In Section 2.2, we define the error using a pessimistic L norm.This makes MMS a very sensitive technique.In fact, it can detect subtle off-by-one mistakes in grid sizes and interactions between node-centric and cell-centric reconstructions, even for simple manufactured solutions.In these cases, it is important not to infer incorrect conclusions.", "rank": 104, "paragraph_comparative_number": 1, "entities": [], "id": "p_104"}, "sentences": [{"end": 41930, "text": "In Section 2.2, we define the error using a pessimistic L norm.", "rank": 342, "start": 41867, "IsComparative": "0", "id": "st_342"}, {"end": 41972, "text": "This makes MMS a very sensitive technique.", "rank": 343, "start": 41930, "IsComparative": "0", "id": "st_343"}, {"end": 42147, "text": "In fact, it can detect subtle off-by-one mistakes in grid sizes and interactions between node-centric and cell-centric reconstructions, even for simple manufactured solutions.", "rank": 344, "start": 41972, "IsComparative": "0", "id": "st_344"}, {"end": 42214, "text": "In these cases, it is important not to infer incorrect conclusions.", "rank": 345, "start": 42147, "IsComparative": "1", "id": "st_345"}]}, {"paragraph_info": {"end": 42679, "start": 42214, "text": "The numerical estimates for MMS should be performed on as wide a range of parameter values as possible.In our tests, we used h  (0.001,1.0) and observed that both faulty implementations performed appropriately for large values of h. Just as the implementations might only enter the asymptotic regime and achieve the formal convergences for small values of h, it might be that (as we have experienced) bugs only manifest themselves on sufficiently small values of h.", "rank": 105, "paragraph_comparative_number": 0, "entities": [], "id": "p_105"}, "sentences": [{"end": 42317, "text": "The numerical estimates for MMS should be performed on as wide a range of parameter values as possible.", "rank": 346, "start": 42214, "IsComparative": "0", "id": "st_346"}, {"end": 42679, "text": "In our tests, we used h  (0.001,1.0) and observed that both faulty implementations performed appropriately for large values of h. Just as the implementations might only enter the asymptotic regime and achieve the formal convergences for small values of h, it might be that (as we have experienced) bugs only manifest themselves on sufficiently small values of h.", "rank": 347, "start": 42317, "IsComparative": "0", "id": "st_347"}]}, {"paragraph_info": {"end": 42715, "start": 42679, "text": "2.4.4 On the Limitations of the Test", "rank": 106, "paragraph_comparative_number": 0, "entities": [], "id": "p_106"}, "sentences": [{"end": 42715, "text": "2.4.4 On the Limitations of the Test", "rank": 348, "start": 42679, "IsComparative": "0", "id": "st_348"}]}, {"paragraph_info": {"end": 43138, "start": 42715, "text": "MMS does not cover every aspect of verification for isosurface extraction.For example, an important aspect we do not know how to test with MMS is the topological correctness of an extracted mesh.This is challenging because there does not seem to be a good measure of convergence for topological properties such as the Euler characteristic or Betti numbers.A proper study of these issues is a natural avenue for future work.", "rank": 107, "paragraph_comparative_number": 2, "entities": [], "id": "p_107"}, "sentences": [{"end": 42789, "text": "MMS does not cover every aspect of verification for isosurface extraction.", "rank": 349, "start": 42715, "IsComparative": "0", "id": "st_349"}, {"end": 42910, "text": "For example, an important aspect we do not know how to test with MMS is the topological correctness of an extracted mesh.", "rank": 350, "start": 42789, "IsComparative": "0", "id": "st_350"}, {"end": 43071, "text": "This is challenging because there does not seem to be a good measure of convergence for topological properties such as the Euler characteristic or Betti numbers.", "rank": 351, "start": 42910, "IsComparative": "1", "id": "st_351"}, {"end": 43138, "text": "A proper study of these issues is a natural avenue for future work.", "rank": 352, "start": 43071, "IsComparative": "1", "id": "st_352"}]}, {"paragraph_info": {"end": 43152, "start": 43138, "text": "2.5 Conclusion", "rank": 108, "paragraph_comparative_number": 0, "entities": [], "id": "p_108"}, "sentences": [{"end": 43152, "text": "2.5 Conclusion", "rank": 353, "start": 43138, "IsComparative": "0", "id": "st_353"}]}, {"paragraph_info": {"end": 43816, "start": 43152, "text": "Using a simple manufactured solution, we were able to reveal bugs that prevented the convergence of some mesh properties of two publicly available isosurfacing codes.In particular, the by-products of the verification process, namely a continuous refinement of mathematical analysis of the algorithms behavior and a numerical comparison of the results of the implementation against a known solution are valuable in their own right, and should be published together with new algorithms.In the next chapter, we present a natural extension of the verification of geometrical properties of isosurfaces, namely, the verification of topological properties of isosurfaces.", "rank": 109, "paragraph_comparative_number": 2, "entities": [], "id": "p_109"}, "sentences": [{"end": 43318, "text": "Using a simple manufactured solution, we were able to reveal bugs that prevented the convergence of some mesh properties of two publicly available isosurfacing codes.", "rank": 354, "start": 43152, "IsComparative": "1", "id": "st_354"}, {"end": 43636, "text": "In particular, the by-products of the verification process, namely a continuous refinement of mathematical analysis of the algorithms behavior and a numerical comparison of the results of the implementation against a known solution are valuable in their own right, and should be published together with new algorithms.", "rank": 355, "start": 43318, "IsComparative": "1", "id": "st_355"}, {"end": 43816, "text": "In the next chapter, we present a natural extension of the verification of geometrical properties of isosurfaces, namely, the verification of topological properties of isosurfaces.", "rank": 356, "start": 43636, "IsComparative": "0", "id": "st_356"}]}, {"paragraph_info": {"end": 43880, "start": 43816, "text": "CHAPTER 3 VERIFYING TOPOLOGY OF ISOSURFACE EXTRACTION ALGORITHMS", "rank": 110, "paragraph_comparative_number": 0, "entities": [], "id": "p_110"}, "sentences": [{"end": 43880, "text": "CHAPTER 3 VERIFYING TOPOLOGY OF ISOSURFACE EXTRACTION ALGORITHMS", "rank": 357, "start": 43816, "IsComparative": "0", "id": "st_357"}]}, {"paragraph_info": {"end": 44611, "start": 43880, "text": "Visualization is an important aspect of current large-scale data analysis.As the users of scientific software are not typically visualization experts, they might not be aware of limitations and properties of the underlying algorithms and visualization techniques.As visualization researchers and practitioners, it is our responsibility to ensure that these limitations and properties are clearly stated and studied.Moreover, we should provide mechanisms which attest to the correctness of visualization systems.Unfortunately, the accuracy, reliability, and robustness of visualization algorithms and their implementations have not in general fallen under such scrutiny as have other components of the scientific computing pipeline.", "rank": 111, "paragraph_comparative_number": 3, "entities": [], "id": "p_111"}, "sentences": [{"end": 43954, "text": "Visualization is an important aspect of current large-scale data analysis.", "rank": 358, "start": 43880, "IsComparative": "0", "id": "st_358"}, {"end": 44143, "text": "As the users of scientific software are not typically visualization experts, they might not be aware of limitations and properties of the underlying algorithms and visualization techniques.", "rank": 359, "start": 43954, "IsComparative": "0", "id": "st_359"}, {"end": 44295, "text": "As visualization researchers and practitioners, it is our responsibility to ensure that these limitations and properties are clearly stated and studied.", "rank": 360, "start": 44143, "IsComparative": "1", "id": "st_360"}, {"end": 44391, "text": "Moreover, we should provide mechanisms which attest to the correctness of visualization systems.", "rank": 361, "start": 44295, "IsComparative": "1", "id": "st_361"}, {"end": 44611, "text": "Unfortunately, the accuracy, reliability, and robustness of visualization algorithms and their implementations have not in general fallen under such scrutiny as have other components of the scientific computing pipeline.", "rank": 362, "start": 44391, "IsComparative": "1", "id": "st_362"}]}, {"paragraph_info": {"end": 45288, "start": 44611, "text": "We strive for verification tools which are both simple and effective.Simple verification methods are less likely to have bugs themselves, and effective methods make it difficult for bugs to hide.Alas, the mathematical properties of an algorithm and its implementation are both constructs of fallible human beings, and so perfection is an unattainable goal; there will always be the next bug.Verification is, fundamentally, a process, and when it finds problems with an algorithm or its implementation, we can only claim that the new implementation behaves more correctly than the old one.Nevertheless, the verification process clarifies how the implementations fail or succeed.", "rank": 112, "paragraph_comparative_number": 3, "entities": [], "id": "p_112"}, "sentences": [{"end": 44680, "text": "We strive for verification tools which are both simple and effective.", "rank": 363, "start": 44611, "IsComparative": "1", "id": "st_363"}, {"end": 44806, "text": "Simple verification methods are less likely to have bugs themselves, and effective methods make it difficult for bugs to hide.", "rank": 364, "start": 44680, "IsComparative": "1", "id": "st_364"}, {"end": 45002, "text": "Alas, the mathematical properties of an algorithm and its implementation are both constructs of fallible human beings, and so perfection is an unattainable goal; there will always be the next bug.", "rank": 365, "start": 44806, "IsComparative": "0", "id": "st_365"}, {"end": 45199, "text": "Verification is, fundamentally, a process, and when it finds problems with an algorithm or its implementation, we can only claim that the new implementation behaves more correctly than the old one.", "rank": 366, "start": 45002, "IsComparative": "1", "id": "st_366"}, {"end": 45288, "text": "Nevertheless, the verification process clarifies how the implementations fail or succeed.", "rank": 367, "start": 45199, "IsComparative": "0", "id": "st_367"}]}, {"paragraph_info": {"end": 45928, "start": 45288, "text": "In this chapter, we investigate isosurfacing algorithms and implementations and focus on their topological properties.For brevity, we will use the general phrase isosurfacing when we refer to both isosurfacing algorithms and their implementations.As a simple example, the topology of the output of isosurface codes should match that of the level set of the scalar field (as discussed in Section 3.2).Broadly speaking, we use the method of manufactured solutions (MMS) to check these properties.By manufacturing a model whose known behavior should be reproduced by the techniques under analysis, MMS can check whether they meet expectations.", "rank": 113, "paragraph_comparative_number": 3, "entities": [], "id": "p_113"}, "sentences": [{"end": 45406, "text": "In this chapter, we investigate isosurfacing algorithms and implementations and focus on their topological properties.", "rank": 368, "start": 45288, "IsComparative": "1", "id": "st_368"}, {"end": 45535, "text": "For brevity, we will use the general phrase isosurfacing when we refer to both isosurfacing algorithms and their implementations.", "rank": 369, "start": 45406, "IsComparative": "1", "id": "st_369"}, {"end": 45688, "text": "As a simple example, the topology of the output of isosurface codes should match that of the level set of the scalar field (as discussed in Section 3.2).", "rank": 370, "start": 45535, "IsComparative": "0", "id": "st_370"}, {"end": 45782, "text": "Broadly speaking, we use the method of manufactured solutions (MMS) to check these properties.", "rank": 371, "start": 45688, "IsComparative": "1", "id": "st_371"}, {"end": 45928, "text": "By manufacturing a model whose known behavior should be reproduced by the techniques under analysis, MMS can check whether they meet expectations.", "rank": 372, "start": 45782, "IsComparative": "0", "id": "st_372"}]}, {"paragraph_info": {"end": 46181, "start": 45928, "text": "An important contribution of this work is the selection of significant topological char- acteristics that can be verified by software methods.We use results from two fields in computational topology, namely, digital topology and stratified Morse theory.", "rank": 114, "paragraph_comparative_number": 2, "entities": [], "id": "p_114"}, "sentences": [{"end": 46070, "text": "An important contribution of this work is the selection of significant topological char- acteristics that can be verified by software methods.", "rank": 373, "start": 45928, "IsComparative": "1", "id": "st_373"}, {"end": 46181, "text": "We use results from two fields in computational topology, namely, digital topology and stratified Morse theory.", "rank": 374, "start": 46070, "IsComparative": "1", "id": "st_374"}]}, {"paragraph_info": {"end": 46254, "start": 46181, "text": "In summary, the main contributions of this work can be stated as follows:", "rank": 115, "paragraph_comparative_number": 0, "entities": [], "id": "p_115"}, "sentences": [{"end": 46254, "text": "In summary, the main contributions of this work can be stated as follows:", "rank": 375, "start": 46181, "IsComparative": "0", "id": "st_375"}]}, {"paragraph_info": {"end": 46423, "start": 46254, "text": "1.In the spirit of verifiable visualization, we introduce a methodology for checking topological properties of publicly and commercially available isosurfacing software.", "rank": 116, "paragraph_comparative_number": 2, "entities": [], "id": "p_116"}, "sentences": [{"end": 46256, "text": "1.", "rank": 376, "start": 46254, "IsComparative": "1", "id": "st_376"}, {"end": 46423, "text": "In the spirit of verifiable visualization, we introduce a methodology for checking topological properties of publicly and commercially available isosurfacing software.", "rank": 377, "start": 46256, "IsComparative": "1", "id": "st_377"}]}, {"paragraph_info": {"end": 46563, "start": 46423, "text": "2.We show how to adapt techniques from digital topology to yield simple and effective verification tools for isosurfaces without boundaries.", "rank": 117, "paragraph_comparative_number": 2, "entities": [], "id": "p_117"}, "sentences": [{"end": 46425, "text": "2.", "rank": 378, "start": 46423, "IsComparative": "1", "id": "st_378"}, {"end": 46563, "text": "We show how to adapt techniques from digital topology to yield simple and effective verification tools for isosurfaces without boundaries.", "rank": 379, "start": 46425, "IsComparative": "1", "id": "st_379"}]}, {"paragraph_info": {"end": 46817, "start": 46563, "text": "3.We introduce a simple technique to compute the Euler characteristic of a level set of a trilinearly interpolated scalar field.The technique relies on stratified Morse theory and allows us to verify topological properties of isosurfaces with boundaries.", "rank": 118, "paragraph_comparative_number": 2, "entities": [], "id": "p_118"}, "sentences": [{"end": 46565, "text": "3.", "rank": 380, "start": 46563, "IsComparative": "1", "id": "st_380"}, {"end": 46691, "text": "We introduce a simple technique to compute the Euler characteristic of a level set of a trilinearly interpolated scalar field.", "rank": 381, "start": 46565, "IsComparative": "0", "id": "st_381"}, {"end": 46817, "text": "The technique relies on stratified Morse theory and allows us to verify topological properties of isosurfaces with boundaries.", "rank": 382, "start": 46691, "IsComparative": "1", "id": "st_382"}]}, {"paragraph_info": {"end": 46989, "start": 46817, "text": "4.We propose a mechanism to manufacture isosurfaces with nontrivial topological prop- erties, showing that this simple mechanism effectively stresses isosurfacing programs.", "rank": 119, "paragraph_comparative_number": 2, "entities": [], "id": "p_119"}, "sentences": [{"end": 46819, "text": "4.", "rank": 383, "start": 46817, "IsComparative": "1", "id": "st_383"}, {"end": 46989, "text": "We propose a mechanism to manufacture isosurfaces with nontrivial topological prop- erties, showing that this simple mechanism effectively stresses isosurfacing programs.", "rank": 384, "start": 46819, "IsComparative": "1", "id": "st_384"}]}, {"paragraph_info": {"end": 47075, "start": 46989, "text": "As input, we also assume a piecewise trilinear scalar field defined on a regular grid.", "rank": 120, "paragraph_comparative_number": 0, "entities": [], "id": "p_120"}, "sentences": [{"end": 47075, "text": "As input, we also assume a piecewise trilinear scalar field defined on a regular grid.", "rank": 385, "start": 46989, "IsComparative": "0", "id": "st_385"}]}, {"paragraph_info": {"end": 47488, "start": 47075, "text": "The verification process produces a comprehensive record of the desired properties of the implementations, along with an objective assessment of whether these properties are sat- isfied.This record improves the applicability of the technique and increases the value of visualization.We present a set of results obtained using our method, and we report errors in two publicly-available isosurface extraction codes.", "rank": 121, "paragraph_comparative_number": 1, "entities": [], "id": "p_121"}, "sentences": [{"end": 47261, "text": "The verification process produces a comprehensive record of the desired properties of the implementations, along with an objective assessment of whether these properties are sat- isfied.", "rank": 386, "start": 47075, "IsComparative": "0", "id": "st_386"}, {"end": 47358, "text": "This record improves the applicability of the technique and increases the value of visualization.", "rank": 387, "start": 47261, "IsComparative": "0", "id": "st_387"}, {"end": 47488, "text": "We present a set of results obtained using our method, and we report errors in two publicly-available isosurface extraction codes.", "rank": 388, "start": 47358, "IsComparative": "1", "id": "st_388"}]}, {"paragraph_info": {"end": 47504, "start": 47488, "text": "3.1 Related Work", "rank": 122, "paragraph_comparative_number": 0, "entities": [], "id": "p_122"}, "sentences": [{"end": 47504, "text": "3.1 Related Work", "rank": 389, "start": 47488, "IsComparative": "0", "id": "st_389"}]}, {"paragraph_info": {"end": 47796, "start": 47504, "text": "The literature that evaluates isosurface extraction techniques is enormous, with works ranging from mesh quality <33, 153, 141>, to performance <165> and accuracy analysis <131, 195>.In this section, we focus on methods that deal with topological issues that naturally appear in isosurfacing.", "rank": 123, "paragraph_comparative_number": 1, "entities": [], "id": "p_123"}, "sentences": [{"end": 47687, "text": "The literature that evaluates isosurface extraction techniques is enormous, with works ranging from mesh quality <33, 153, 141>, to performance <165> and accuracy analysis <131, 195>.", "rank": 390, "start": 47504, "IsComparative": "1", "id": "st_390"}, {"end": 47796, "text": "In this section, we focus on methods that deal with topological issues that naturally appear in isosurfacing.", "rank": 391, "start": 47687, "IsComparative": "0", "id": "st_391"}]}, {"paragraph_info": {"end": 47829, "start": 47796, "text": "3.1.1 Topology-aware Isosurfacing", "rank": 124, "paragraph_comparative_number": 0, "entities": [], "id": "p_124"}, "sentences": [{"end": 47829, "text": "3.1.1 Topology-aware Isosurfacing", "rank": 392, "start": 47796, "IsComparative": "0", "id": "st_392"}]}, {"paragraph_info": {"end": 48187, "start": 47829, "text": "Arguably the most popular isosurface extraction technique, Marching Cubes <100> (MC) processes one grid cell at a time and uses the signs of each grid node (whether the scalar field at the node is above or below the isovalue) to fit a triangular mesh that approximates the isosurface within the cell.As no information besides the signs is taken into account,", "rank": 125, "paragraph_comparative_number": 1, "entities": [], "id": "p_125"}, "sentences": [{"end": 48129, "text": "Arguably the most popular isosurface extraction technique, Marching Cubes <100> (MC) processes one grid cell at a time and uses the signs of each grid node (whether the scalar field at the node is above or below the isovalue) to fit a triangular mesh that approximates the isosurface within the cell.", "rank": 393, "start": 47829, "IsComparative": "1", "id": "st_393"}, {"end": 48187, "text": "As no information besides the signs is taken into account,", "rank": 394, "start": 48129, "IsComparative": "0", "id": "st_394"}]}, {"paragraph_info": {"end": 48932, "start": 48187, "text": "Marching Cubes cannot guarantee any topological equivalence between the triangulated mesh and the original isosurface.In fact, the original Marching Cubes algorithm would produce surfaces with cracks, caused by alternating vertex signs along a face bound- ary, which lead to contradicting triangulations in neighboring cells <126>.Disambiguation mechanisms can ensure crack-free surfaces, and many schemes have been proposed, such as the one by Montani et al.<117>, domain tetrahedralization <16>, preferred polarity <8>, gradient-based method <180>, and feature-based schemes <64>.The survey of Newman and Yi has a comprehensive account <124>.Although disambiguation prevents cracks in the output, it does not guarantee topological equivalence.", "rank": 126, "paragraph_comparative_number": 3, "entities": [], "id": "p_126"}, "sentences": [{"end": 48305, "text": "Marching Cubes cannot guarantee any topological equivalence between the triangulated mesh and the original isosurface.", "rank": 395, "start": 48187, "IsComparative": "1", "id": "st_395"}, {"end": 48518, "text": "In fact, the original Marching Cubes algorithm would produce surfaces with cracks, caused by alternating vertex signs along a face bound- ary, which lead to contradicting triangulations in neighboring cells <126>.", "rank": 396, "start": 48305, "IsComparative": "1", "id": "st_396"}, {"end": 48646, "text": "Disambiguation mechanisms can ensure crack-free surfaces, and many schemes have been proposed, such as the one by Montani et al.", "rank": 397, "start": 48518, "IsComparative": "0", "id": "st_397"}, {"end": 48769, "text": "<117>, domain tetrahedralization <16>, preferred polarity <8>, gradient-based method <180>, and feature-based schemes <64>.", "rank": 398, "start": 48646, "IsComparative": "1", "id": "st_398"}, {"end": 48831, "text": "The survey of Newman and Yi has a comprehensive account <124>.", "rank": 399, "start": 48769, "IsComparative": "0", "id": "st_399"}, {"end": 48932, "text": "Although disambiguation prevents cracks in the output, it does not guarantee topological equivalence.", "rank": 400, "start": 48831, "IsComparative": "0", "id": "st_400"}]}, {"paragraph_info": {"end": 50323, "start": 48932, "text": "Topological equivalence between the resulting triangle mesh and the isosurface can only be achieved with additional information about the underlying scalar field.Since function values on grid nodes are typically the only information provided, a reconstruc- tion kernel is assumed, of which trilinear reconstruction on regular hexahedral grids is most popular <125>.Nielson and Hamann, for example, use saddle points of the bilinear interpolant on grid cell faces <126>.Their method cannot always reproduce the topology of trilinear interpolation because there remain ambiguities internal to a grid cell: pairs of nonhomeomorphic isosurfaces could be homeomorphic when restricted to the grid cell faces.This problem has been recognized by Natarajan <122> and Chernyaev <21>, leading to new classification and triangulation schemes.This line of work has inspired many other topology-aware triangulation methods, such as the reconstruction technique of Cignoni et al.<22>.Subsequent work by Lopes and Brodlie <98> and Lewiner et al.<94> has finally provided triangulation patterns covering all possible topological configurations of trilinear functions, implicitly promising a crack-free surface.The topology of the level sets generated by trilinear interpolation has been recently studied by Carr and Snoeyink <17>, and Carr and Max <15>.A discussion about these can be found in Section 3.3.2.", "rank": 127, "paragraph_comparative_number": 7, "entities": [], "id": "p_127"}, "sentences": [{"end": 49094, "text": "Topological equivalence between the resulting triangle mesh and the isosurface can only be achieved with additional information about the underlying scalar field.", "rank": 401, "start": 48932, "IsComparative": "0", "id": "st_401"}, {"end": 49297, "text": "Since function values on grid nodes are typically the only information provided, a reconstruc- tion kernel is assumed, of which trilinear reconstruction on regular hexahedral grids is most popular <125>.", "rank": 402, "start": 49094, "IsComparative": "0", "id": "st_402"}, {"end": 49401, "text": "Nielson and Hamann, for example, use saddle points of the bilinear interpolant on grid cell faces <126>.", "rank": 403, "start": 49297, "IsComparative": "1", "id": "st_403"}, {"end": 49634, "text": "Their method cannot always reproduce the topology of trilinear interpolation because there remain ambiguities internal to a grid cell: pairs of nonhomeomorphic isosurfaces could be homeomorphic when restricted to the grid cell faces.", "rank": 404, "start": 49401, "IsComparative": "1", "id": "st_404"}, {"end": 49762, "text": "This problem has been recognized by Natarajan <122> and Chernyaev <21>, leading to new classification and triangulation schemes.", "rank": 405, "start": 49634, "IsComparative": "1", "id": "st_405"}, {"end": 49896, "text": "This line of work has inspired many other topology-aware triangulation methods, such as the reconstruction technique of Cignoni et al.", "rank": 406, "start": 49762, "IsComparative": "1", "id": "st_406"}, {"end": 49901, "text": "<22>.", "rank": 407, "start": 49896, "IsComparative": "1", "id": "st_407"}, {"end": 49961, "text": "Subsequent work by Lopes and Brodlie <98> and Lewiner et al.", "rank": 408, "start": 49901, "IsComparative": "1", "id": "st_408"}, {"end": 50125, "text": "<94> has finally provided triangulation patterns covering all possible topological configurations of trilinear functions, implicitly promising a crack-free surface.", "rank": 409, "start": 49961, "IsComparative": "0", "id": "st_409"}, {"end": 50268, "text": "The topology of the level sets generated by trilinear interpolation has been recently studied by Carr and Snoeyink <17>, and Carr and Max <15>.", "rank": 410, "start": 50125, "IsComparative": "1", "id": "st_410"}, {"end": 50323, "text": "A discussion about these can be found in Section 3.3.2.", "rank": 411, "start": 50268, "IsComparative": "0", "id": "st_411"}]}, {"paragraph_info": {"end": 50353, "start": 50323, "text": "3.1.2 Verifiable Visualization", "rank": 128, "paragraph_comparative_number": 0, "entities": [], "id": "p_128"}, "sentences": [{"end": 50353, "text": "3.1.2 Verifiable Visualization", "rank": 412, "start": 50323, "IsComparative": "0", "id": "st_412"}]}, {"paragraph_info": {"end": 51399, "start": 50353, "text": "Many of the false steps in the route from the original MC algorithm to the recent homeomorphic solutions could have been avoided with a systematic procedure to verify the algorithms and the corresponding implementations.Although the lack of verification of visualization techniques and the corresponding software implementations has been a long-term concern of the visualization community <55, 76>, concrete proposals on verification are relatively recent.Etiene et al.<46> were among the first in scientific visualization to propose a practical verification framework for geometrical properties of isosurfacing.Their work is based on the method of manufactured solutions (MMS), a popular approach for assessing numerical software <3>.We are interested in topological properties of isosurfacing, and we also use MMS as a verification mechanism.As we will show in Section 3.5, our proposed technique discovered problems in popular software, supporting our assertion about the value of a broader culture of verification in scientific visualization.", "rank": 129, "paragraph_comparative_number": 4, "entities": [], "id": "p_129"}, "sentences": [{"end": 50573, "text": "Many of the false steps in the route from the original MC algorithm to the recent homeomorphic solutions could have been avoided with a systematic procedure to verify the algorithms and the corresponding implementations.", "rank": 413, "start": 50353, "IsComparative": "0", "id": "st_413"}, {"end": 50809, "text": "Although the lack of verification of visualization techniques and the corresponding software implementations has been a long-term concern of the visualization community <55, 76>, concrete proposals on verification are relatively recent.", "rank": 414, "start": 50573, "IsComparative": "1", "id": "st_414"}, {"end": 50822, "text": "Etiene et al.", "rank": 415, "start": 50809, "IsComparative": "0", "id": "st_415"}, {"end": 50965, "text": "<46> were among the first in scientific visualization to propose a practical verification framework for geometrical properties of isosurfacing.", "rank": 416, "start": 50822, "IsComparative": "1", "id": "st_416"}, {"end": 51088, "text": "Their work is based on the method of manufactured solutions (MMS), a popular approach for assessing numerical software <3>.", "rank": 417, "start": 50965, "IsComparative": "1", "id": "st_417"}, {"end": 51197, "text": "We are interested in topological properties of isosurfacing, and we also use MMS as a verification mechanism.", "rank": 418, "start": 51088, "IsComparative": "0", "id": "st_418"}, {"end": 51399, "text": "As we will show in Section 3.5, our proposed technique discovered problems in popular software, supporting our assertion about the value of a broader culture of verification in scientific visualization.", "rank": 419, "start": 51197, "IsComparative": "1", "id": "st_419"}]}, {"paragraph_info": {"end": 52258, "start": 51399, "text": "There have been significant theoretical investigations in computational topology dealing with, for example, isosurface invariants, persistence, and stability <26, 36>.This body of work is concerned with how to define and compute topological properties of computational objects.We instead develop methods that stress topological properties of isosurfacing.These goals are complementary.Computational topology tools for data analysis might offer new properties which can be used for verification purposes, and verification tools can assess the correctness of the computational topology implementations.Although the mechanism we propose to compute topological invariants for piecewise smooth scalar fields is, to the best of our knowledge, novel (see Section 3.3.2), our primary goal is to present a method that developers can adapt to assess their own software.", "rank": 130, "paragraph_comparative_number": 0, "entities": [], "id": "p_130"}, "sentences": [{"end": 51566, "text": "There have been significant theoretical investigations in computational topology dealing with, for example, isosurface invariants, persistence, and stability <26, 36>.", "rank": 420, "start": 51399, "IsComparative": "0", "id": "st_420"}, {"end": 51676, "text": "This body of work is concerned with how to define and compute topological properties of computational objects.", "rank": 421, "start": 51566, "IsComparative": "0", "id": "st_421"}, {"end": 51754, "text": "We instead develop methods that stress topological properties of isosurfacing.", "rank": 422, "start": 51676, "IsComparative": "0", "id": "st_422"}, {"end": 51784, "text": "These goals are complementary.", "rank": 423, "start": 51754, "IsComparative": "0", "id": "st_423"}, {"end": 51999, "text": "Computational topology tools for data analysis might offer new properties which can be used for verification purposes, and verification tools can assess the correctness of the computational topology implementations.", "rank": 424, "start": 51784, "IsComparative": "0", "id": "st_424"}, {"end": 52258, "text": "Although the mechanism we propose to compute topological invariants for piecewise smooth scalar fields is, to the best of our knowledge, novel (see Section 3.3.2), our primary goal is to present a method that developers can adapt to assess their own software.", "rank": 425, "start": 51999, "IsComparative": "0", "id": "st_425"}]}, {"paragraph_info": {"end": 52291, "start": 52258, "text": "3.2 Verifying Isosurface Topology", "rank": 131, "paragraph_comparative_number": 0, "entities": [], "id": "p_131"}, "sentences": [{"end": 52291, "text": "3.2 Verifying Isosurface Topology", "rank": 426, "start": 52258, "IsComparative": "0", "id": "st_426"}]}, {"paragraph_info": {"end": 53197, "start": 52291, "text": "We now discuss strategies for verifying topological properties of isosurfacing techniques.We start by observing that simply stating the desired properties of the implementation is valuable.Consider a typical implementation of Marching Cubes.How would you debug it?Without a small set of desired properties, we are mostly limited to inspecting the output by explicitly exercising every case in the case table.The fifteen cases might not seem daunting, but what if we suspect a bug in symmetry reduction?We now have 256 cases to check.Even worse, what if the bug is in a combination of separate cases along neighboring cells?The verification would grow to be at least as complicated as the original algorithm, and we would just as likely make a mistake during the verification as we would in the implementation.Therefore, we need properties that are simple to state, easy to check, and good at catching bugs.", "rank": 132, "paragraph_comparative_number": 7, "entities": [], "id": "p_132"}, "sentences": [{"end": 52381, "text": "We now discuss strategies for verifying topological properties of isosurfacing techniques.", "rank": 427, "start": 52291, "IsComparative": "1", "id": "st_427"}, {"end": 52480, "text": "We start by observing that simply stating the desired properties of the implementation is valuable.", "rank": 428, "start": 52381, "IsComparative": "0", "id": "st_428"}, {"end": 52532, "text": "Consider a typical implementation of Marching Cubes.", "rank": 429, "start": 52480, "IsComparative": "1", "id": "st_429"}, {"end": 52555, "text": "How would you debug it?", "rank": 430, "start": 52532, "IsComparative": "1", "id": "st_430"}, {"end": 52699, "text": "Without a small set of desired properties, we are mostly limited to inspecting the output by explicitly exercising every case in the case table.", "rank": 431, "start": 52555, "IsComparative": "1", "id": "st_431"}, {"end": 52793, "text": "The fifteen cases might not seem daunting, but what if we suspect a bug in symmetry reduction?", "rank": 432, "start": 52699, "IsComparative": "0", "id": "st_432"}, {"end": 52824, "text": "We now have 256 cases to check.", "rank": 433, "start": 52793, "IsComparative": "1", "id": "st_433"}, {"end": 52914, "text": "Even worse, what if the bug is in a combination of separate cases along neighboring cells?", "rank": 434, "start": 52824, "IsComparative": "1", "id": "st_434"}, {"end": 53100, "text": "The verification would grow to be at least as complicated as the original algorithm, and we would just as likely make a mistake during the verification as we would in the implementation.", "rank": 435, "start": 52914, "IsComparative": "0", "id": "st_435"}, {"end": 53197, "text": "Therefore, we need properties that are simple to state, easy to check, and good at catching bugs.", "rank": 436, "start": 53100, "IsComparative": "1", "id": "st_436"}]}, {"paragraph_info": {"end": 53217, "start": 53197, "text": "3.2.1 Simple Example", "rank": 133, "paragraph_comparative_number": 0, "entities": [], "id": "p_133"}, "sentences": [{"end": 53217, "text": "3.2.1 Simple Example", "rank": 437, "start": 53197, "IsComparative": "0", "id": "st_437"}]}, {"paragraph_info": {"end": 55387, "start": 53217, "text": "Although the previously mentioned problem with Marching Cubes <100> is well-known, it is not immediately clear what topological properties fail to hold.For example, the output of Marching Cubes cannot contain boundary curves is not one such property, for two reasons.First, some valid surfaces generated by Marching Cubes  such as with the simple 23 case  do contain boundaries.Second, many incorrect outputs might not contain any boundaries at all.The following might appear to be a good candidate property: given a positive vertex v0 and a negative vertex v1, any path through the scalar field should intersect the isosurface an odd number of times.This property does capture the fact that the triangle mesh should separate interior vertices from exterior vertices and seems to isolate the problem with the cracks.Checking this property, on the other hand, and even stating it precisely, is problematic.Geometrical algorithms for intersection tests are notoriously brittle; for example, some paths might intersect the isosurface in degenerate ways.A more promising approach comes from noticing that any such separating isosurface has to be a piecewise-linear manifold, whose boundary must be a subset of the boundary of the grid.This directly suggests that the output of Marching Cubes must be a piecewise- linear (PL) manifold whose boundaries are contained in the boundary of the grid.This property is simple to state and easy to test: the link of every interior vertex in a PL manifold is topologically a circle, and the link of every boundary vertex is a line.The term consistency has been used to describe problems with some algorithms <124>.In this work, we say that the output of an algorithm is consistent if it obeys the PL manifold property above.By generating arbitrary grids and extracting isosurfaces with arbitrary isovalues, the inconsistency of the original case table becomes mechanically checkable and instantly apparent.Some modifications to the basic Marching Cubes table, such as using Nielson and Hamanns asymptotic decider <126>, result in consistent implementations, and the outputs pass the PL manifold checks (as we will show in Section 3.5).", "rank": 134, "paragraph_comparative_number": 8, "entities": [], "id": "p_134"}, "sentences": [{"end": 53369, "text": "Although the previously mentioned problem with Marching Cubes <100> is well-known, it is not immediately clear what topological properties fail to hold.", "rank": 438, "start": 53217, "IsComparative": "1", "id": "st_438"}, {"end": 53484, "text": "For example, the output of Marching Cubes cannot contain boundary curves is not one such property, for two reasons.", "rank": 439, "start": 53369, "IsComparative": "1", "id": "st_439"}, {"end": 53595, "text": "First, some valid surfaces generated by Marching Cubes  such as with the simple 23 case  do contain boundaries.", "rank": 440, "start": 53484, "IsComparative": "1", "id": "st_440"}, {"end": 53666, "text": "Second, many incorrect outputs might not contain any boundaries at all.", "rank": 441, "start": 53595, "IsComparative": "1", "id": "st_441"}, {"end": 53868, "text": "The following might appear to be a good candidate property: given a positive vertex v0 and a negative vertex v1, any path through the scalar field should intersect the isosurface an odd number of times.", "rank": 442, "start": 53666, "IsComparative": "1", "id": "st_442"}, {"end": 54033, "text": "This property does capture the fact that the triangle mesh should separate interior vertices from exterior vertices and seems to isolate the problem with the cracks.", "rank": 443, "start": 53868, "IsComparative": "0", "id": "st_443"}, {"end": 54122, "text": "Checking this property, on the other hand, and even stating it precisely, is problematic.", "rank": 444, "start": 54033, "IsComparative": "0", "id": "st_444"}, {"end": 54267, "text": "Geometrical algorithms for intersection tests are notoriously brittle; for example, some paths might intersect the isosurface in degenerate ways.", "rank": 445, "start": 54122, "IsComparative": "0", "id": "st_445"}, {"end": 54448, "text": "A more promising approach comes from noticing that any such separating isosurface has to be a piecewise-linear manifold, whose boundary must be a subset of the boundary of the grid.", "rank": 446, "start": 54267, "IsComparative": "1", "id": "st_446"}, {"end": 54606, "text": "This directly suggests that the output of Marching Cubes must be a piecewise- linear (PL) manifold whose boundaries are contained in the boundary of the grid.", "rank": 447, "start": 54448, "IsComparative": "0", "id": "st_447"}, {"end": 54783, "text": "This property is simple to state and easy to test: the link of every interior vertex in a PL manifold is topologically a circle, and the link of every boundary vertex is a line.", "rank": 448, "start": 54606, "IsComparative": "1", "id": "st_448"}, {"end": 54866, "text": "The term consistency has been used to describe problems with some algorithms <124>.", "rank": 449, "start": 54783, "IsComparative": "0", "id": "st_449"}, {"end": 54976, "text": "In this work, we say that the output of an algorithm is consistent if it obeys the PL manifold property above.", "rank": 450, "start": 54866, "IsComparative": "0", "id": "st_450"}, {"end": 55158, "text": "By generating arbitrary grids and extracting isosurfaces with arbitrary isovalues, the inconsistency of the original case table becomes mechanically checkable and instantly apparent.", "rank": 451, "start": 54976, "IsComparative": "0", "id": "st_451"}, {"end": 55387, "text": "Some modifications to the basic Marching Cubes table, such as using Nielson and Hamanns asymptotic decider <126>, result in consistent implementations, and the outputs pass the PL manifold checks (as we will show in Section 3.5).", "rank": 452, "start": 55158, "IsComparative": "1", "id": "st_452"}]}, {"paragraph_info": {"end": 56402, "start": 55387, "text": "The example we have presented above is a complete instance of the method of manufac- tured solutions.We identify a property that the results should obey, run the implementa- tions on inputs, and test whether the resulting outputs respect the properties.In the next sections, we develop a verification method for algorithms to reproduce the topology of the level sets of trilinear interpolation <21, 98, 125>, thus completely eliminating any ambiguity.In this work, we say the output is correct if it is homeomorphic to the corresponding level set of the scalar field.This correctness property is simple to state, but developing effective verification schemes that are powerful and simple to implement is more involved.We will turn to invariants of topological spaces, in particular to Betti numbers and the Euler characteristic, their relative strengths and weaknesses, and discuss how to robustly check their values.Figure 3.1 shows our pipeline to assess topological correctness and also the chapter organization.", "rank": 135, "paragraph_comparative_number": 4, "entities": [], "id": "p_135"}, "sentences": [{"end": 55488, "text": "The example we have presented above is a complete instance of the method of manufac- tured solutions.", "rank": 453, "start": 55387, "IsComparative": "1", "id": "st_453"}, {"end": 55640, "text": "We identify a property that the results should obey, run the implementa- tions on inputs, and test whether the resulting outputs respect the properties.", "rank": 454, "start": 55488, "IsComparative": "0", "id": "st_454"}, {"end": 55838, "text": "In the next sections, we develop a verification method for algorithms to reproduce the topology of the level sets of trilinear interpolation <21, 98, 125>, thus completely eliminating any ambiguity.", "rank": 455, "start": 55640, "IsComparative": "0", "id": "st_455"}, {"end": 55954, "text": "In this work, we say the output is correct if it is homeomorphic to the corresponding level set of the scalar field.", "rank": 456, "start": 55838, "IsComparative": "0", "id": "st_456"}, {"end": 56105, "text": "This correctness property is simple to state, but developing effective verification schemes that are powerful and simple to implement is more involved.", "rank": 457, "start": 55954, "IsComparative": "1", "id": "st_457"}, {"end": 56304, "text": "We will turn to invariants of topological spaces, in particular to Betti numbers and the Euler characteristic, their relative strengths and weaknesses, and discuss how to robustly check their values.", "rank": 458, "start": 56105, "IsComparative": "1", "id": "st_458"}, {"end": 56402, "text": "Figure 3.1 shows our pipeline to assess topological correctness and also the chapter organization.", "rank": 459, "start": 56304, "IsComparative": "1", "id": "st_459"}]}, {"paragraph_info": {"end": 56424, "start": 56402, "text": "3.3 Mathematical Tools", "rank": 136, "paragraph_comparative_number": 0, "entities": [], "id": "p_136"}, "sentences": [{"end": 56424, "text": "3.3 Mathematical Tools", "rank": 460, "start": 56402, "IsComparative": "0", "id": "st_460"}]}, {"paragraph_info": {"end": 56824, "start": 56424, "text": "This section describes the mathematical machinery used to derive the topology verifi- cation tools.More specifically, we provide a summary of the results we need from digital topology and stratified Morse theory.A detailed discussion on digital topology can be found in the work by Stelldinger et al.<164>, and Goresky and MacPherson give a comprehensive presentation of stratified Morse theory <57>.", "rank": 137, "paragraph_comparative_number": 3, "entities": [], "id": "p_137"}, "sentences": [{"end": 56523, "text": "This section describes the mathematical machinery used to derive the topology verifi- cation tools.", "rank": 461, "start": 56424, "IsComparative": "1", "id": "st_461"}, {"end": 56636, "text": "More specifically, we provide a summary of the results we need from digital topology and stratified Morse theory.", "rank": 462, "start": 56523, "IsComparative": "0", "id": "st_462"}, {"end": 56724, "text": "A detailed discussion on digital topology can be found in the work by Stelldinger et al.", "rank": 463, "start": 56636, "IsComparative": "1", "id": "st_463"}, {"end": 56824, "text": "<164>, and Goresky and MacPherson give a comprehensive presentation of stratified Morse theory <57>.", "rank": 464, "start": 56724, "IsComparative": "1", "id": "st_464"}]}, {"paragraph_info": {"end": 57237, "start": 56824, "text": "In Section 3.3.1, we describe a method, based on digital topology, that operates on manifold surfaces without boundaries and determines the Euler characteristic and Betti numbers of the level sets.A more general setting of surfaces with boundaries is handled with tools derived from stratified Morse theory, detailed in Section 3.3.2.The latter method can only determine the Euler characteristic of the level set.", "rank": 138, "paragraph_comparative_number": 0, "entities": [], "id": "p_138"}, "sentences": [{"end": 57021, "text": "In Section 3.3.1, we describe a method, based on digital topology, that operates on manifold surfaces without boundaries and determines the Euler characteristic and Betti numbers of the level sets.", "rank": 465, "start": 56824, "IsComparative": "0", "id": "st_465"}, {"end": 57158, "text": "A more general setting of surfaces with boundaries is handled with tools derived from stratified Morse theory, detailed in Section 3.3.2.", "rank": 466, "start": 57021, "IsComparative": "0", "id": "st_466"}, {"end": 57237, "text": "The latter method can only determine the Euler characteristic of the level set.", "rank": 467, "start": 57158, "IsComparative": "0", "id": "st_467"}]}, {"paragraph_info": {"end": 58354, "start": 57237, "text": "Let us start by recalling the definition and some properties of the Euler characteristic, which we denote by .For a compact 2-manifold M, (M) = V  E + F , where V , E, and F are the number of vertices, edges, and faces of any finite cell decomposition of M. If M is a connected orientable 2-manifold without boundary, (M) = 2  2g(M), where g(M) is the genus of M. The Euler characteristic may also be written as (M) =  ni=0(1)ii, where i are the Betti numbers: the rank of the i-th homology group of M. Intuitively, for 2-manifolds, 0, 1, and 2 correspond to the number of connected components, holes, and voids (regions of the space enclosed by the surface), respectively.If M has many distinct connected components, that is, M =  ni=1 Mi and Mi   Mj =  for i = j, then (M) =  ni (Mi).More details about Betti numbers, the Euler characteristic, and homology groups can be found in Edelsbrunner and Harers text <36>.The Euler characteristic and the Betti numbers are topological invariants: two homeomorphic topological spaces will have the same Euler characteristic and Betti numbers whenever these are well-defined.", "rank": 139, "paragraph_comparative_number": 0, "entities": [], "id": "p_139"}, "sentences": [{"end": 57347, "text": "Let us start by recalling the definition and some properties of the Euler characteristic, which we denote by .", "rank": 468, "start": 57237, "IsComparative": "0", "id": "st_468"}, {"end": 57910, "text": "For a compact 2-manifold M, (M) = V  E + F , where V , E, and F are the number of vertices, edges, and faces of any finite cell decomposition of M. If M is a connected orientable 2-manifold without boundary, (M) = 2  2g(M), where g(M) is the genus of M. The Euler characteristic may also be written as (M) =  ni=0(1)ii, where i are the Betti numbers: the rank of the i-th homology group of M. Intuitively, for 2-manifolds, 0, 1, and 2 correspond to the number of connected components, holes, and voids (regions of the space enclosed by the surface), respectively.", "rank": 469, "start": 57347, "IsComparative": "0", "id": "st_469"}, {"end": 58023, "text": "If M has many distinct connected components, that is, M =  ni=1 Mi and Mi   Mj =  for i = j, then (M) =  ni (Mi).", "rank": 470, "start": 57910, "IsComparative": "0", "id": "st_470"}, {"end": 58153, "text": "More details about Betti numbers, the Euler characteristic, and homology groups can be found in Edelsbrunner and Harers text <36>.", "rank": 471, "start": 58023, "IsComparative": "0", "id": "st_471"}, {"end": 58354, "text": "The Euler characteristic and the Betti numbers are topological invariants: two homeomorphic topological spaces will have the same Euler characteristic and Betti numbers whenever these are well-defined.", "rank": 472, "start": 58153, "IsComparative": "0", "id": "st_472"}]}, {"paragraph_info": {"end": 58376, "start": 58354, "text": "3.3.1 Digital Topology", "rank": 140, "paragraph_comparative_number": 0, "entities": [], "id": "p_140"}, "sentences": [{"end": 58376, "text": "3.3.1 Digital Topology", "rank": 473, "start": 58354, "IsComparative": "0", "id": "st_473"}]}, {"paragraph_info": {"end": 58916, "start": 58376, "text": "Let G be an n  n  n cubic regular grid with a scalar e(s) assigned to each vertex s of G and t : R3  R be the piecewise trilinear interpolation function in G, that is, t(x) = ti(x), where ti is the trilinear interpolant in the cubic cell ci containing x.Given a scalar value , the set of points satisfying t(x) =  is called the isosurface  of t. In what follows, t(x) =  will be considered a compact, orientable 2-manifold without boundary.We say that a cubic cell ci of G is unambiguous if the following two conditions hold simultaneously:", "rank": 141, "paragraph_comparative_number": 1, "entities": [], "id": "p_141"}, "sentences": [{"end": 58630, "text": "Let G be an n  n  n cubic regular grid with a scalar e(s) assigned to each vertex s of G and t : R3  R be the piecewise trilinear interpolation function in G, that is, t(x) = ti(x), where ti is the trilinear interpolant in the cubic cell ci containing x.", "rank": 474, "start": 58376, "IsComparative": "0", "id": "st_474"}, {"end": 58816, "text": "Given a scalar value , the set of points satisfying t(x) =  is called the isosurface  of t. In what follows, t(x) =  will be considered a compact, orientable 2-manifold without boundary.", "rank": 475, "start": 58630, "IsComparative": "0", "id": "st_475"}, {"end": 58916, "text": "We say that a cubic cell ci of G is unambiguous if the following two conditions hold simultaneously:", "rank": 476, "start": 58816, "IsComparative": "1", "id": "st_476"}]}, {"paragraph_info": {"end": 59120, "start": 58916, "text": "1. any two vertices sa and sb in ci for which e(sa) <  and e(sb) <  are connected by negative edges, i. e., a sequence of edges sas1,s1s2,...,sksb in ci whose vertices satisfy e(si) <  for i = 1,...,k and", "rank": 142, "paragraph_comparative_number": 1, "entities": [], "id": "p_142"}, "sentences": [{"end": 59120, "text": "1. any two vertices sa and sb in ci for which e(sa) <  and e(sb) <  are connected by negative edges, i. e., a sequence of edges sas1,s1s2,...,sksb in ci whose vertices satisfy e(si) <  for i = 1,...,k and", "rank": 477, "start": 58916, "IsComparative": "1", "id": "st_477"}]}, {"paragraph_info": {"end": 59324, "start": 59120, "text": "2. any two vertices sc and sd in ci for which e(sc) >  and e(sd) >  are connected by positive edges, i. e., a sequence of edges scs1, s1s2, ..., slsd in ci whose vertices satisfy e(si) >  for i = 1,...,l.", "rank": 143, "paragraph_comparative_number": 2, "entities": [], "id": "p_143"}, "sentences": [{"end": 59261, "text": "2. any two vertices sc and sd in ci for which e(sc) >  and e(sd) >  are connected by positive edges, i. e., a sequence of edges scs1, s1s2, .", "rank": 478, "start": 59120, "IsComparative": "1", "id": "st_478"}, {"end": 59262, "text": ".", "rank": 479, "start": 59261, "IsComparative": "0", "id": "st_479"}, {"end": 59263, "text": ".", "rank": 480, "start": 59262, "IsComparative": "0", "id": "st_480"}, {"end": 59324, "text": ", slsd in ci whose vertices satisfy e(si) >  for i = 1,...,l.", "rank": 481, "start": 59263, "IsComparative": "1", "id": "st_481"}]}, {"paragraph_info": {"end": 59600, "start": 59324, "text": "In other words, a cell is unambiguous if all positive vertices form a single connected com- ponent via the positive edges and, conversely, all negative vertices form a single connected component by negative edges <180>.If either property fails to hold, ci is called ambiguous.", "rank": 144, "paragraph_comparative_number": 0, "entities": [], "id": "p_144"}, "sentences": [{"end": 59543, "text": "In other words, a cell is unambiguous if all positive vertices form a single connected com- ponent via the positive edges and, conversely, all negative vertices form a single connected component by negative edges <180>.", "rank": 482, "start": 59324, "IsComparative": "0", "id": "st_482"}, {"end": 59600, "text": "If either property fails to hold, ci is called ambiguous.", "rank": 483, "start": 59543, "IsComparative": "0", "id": "st_483"}]}, {"paragraph_info": {"end": 59663, "start": 59600, "text": "The top row in Figure 3.2 shows all possible unambiguous cases.", "rank": 145, "paragraph_comparative_number": 1, "entities": [], "id": "p_145"}, "sentences": [{"end": 59663, "text": "The top row in Figure 3.2 shows all possible unambiguous cases.", "rank": 484, "start": 59600, "IsComparative": "1", "id": "st_484"}]}, {"paragraph_info": {"end": 60419, "start": 59663, "text": "The geometric dual of G is called the voxel grid associated with G, denoted by VG.More specifically, each vertex s of G has a corresponding voxel vs in VG , each edge of G corresponds to a face in VG (and vice versa), and each cubic cell in G corresponds to a vertex in VG, as illustrated in Figure 3.3.Each voxel vs can also be seen as the Voronoi cell associated with s. Scalars defined in the vertices of G can naturally be extended to voxels, thus ensuring a single scalar value e(vs) to each voxel vs in VG defined as e(s) = e(vs).As we shall show, the voxel grid structure plays an important role when using digital topology to compute topological invariants of a given isosurface.Before showing that relation, though, we need a few more definitions.", "rank": 146, "paragraph_comparative_number": 2, "entities": [], "id": "p_146"}, "sentences": [{"end": 59745, "text": "The geometric dual of G is called the voxel grid associated with G, denoted by VG.", "rank": 485, "start": 59663, "IsComparative": "0", "id": "st_485"}, {"end": 59966, "text": "More specifically, each vertex s of G has a corresponding voxel vs in VG , each edge of G corresponds to a face in VG (and vice versa), and each cubic cell in G corresponds to a vertex in VG, as illustrated in Figure 3.3.", "rank": 486, "start": 59745, "IsComparative": "1", "id": "st_486"}, {"end": 60199, "text": "Each voxel vs can also be seen as the Voronoi cell associated with s. Scalars defined in the vertices of G can naturally be extended to voxels, thus ensuring a single scalar value e(vs) to each voxel vs in VG defined as e(s) = e(vs).", "rank": 487, "start": 59966, "IsComparative": "0", "id": "st_487"}, {"end": 60350, "text": "As we shall show, the voxel grid structure plays an important role when using digital topology to compute topological invariants of a given isosurface.", "rank": 488, "start": 60199, "IsComparative": "0", "id": "st_488"}, {"end": 60419, "text": "Before showing that relation, though, we need a few more definitions.", "rank": 489, "start": 60350, "IsComparative": "1", "id": "st_489"}]}, {"paragraph_info": {"end": 60773, "start": 60419, "text": "Denote by G the (2n  1)  (2n  1)  (2n  1) regular grid obtained from a refinement of G. Vertices of G can be grouped in four distinct sets, denoted by O, F, E, C.The set O contains the vertices of G that are also vertices of G.The sets F and E contain the vertices of G lying on the center of faces and edges of the voxel grid VG, respectively.Finally, C", "rank": 147, "paragraph_comparative_number": 0, "entities": [], "id": "p_147"}, "sentences": [{"end": 60581, "text": "Denote by G the (2n  1)  (2n  1)  (2n  1) regular grid obtained from a refinement of G. Vertices of G can be grouped in four distinct sets, denoted by O, F, E, C.", "rank": 490, "start": 60419, "IsComparative": "0", "id": "st_490"}, {"end": 60646, "text": "The set O contains the vertices of G that are also vertices of G.", "rank": 491, "start": 60581, "IsComparative": "0", "id": "st_491"}, {"end": 60763, "text": "The sets F and E contain the vertices of G lying on the center of faces and edges of the voxel grid VG, respectively.", "rank": 492, "start": 60646, "IsComparative": "0", "id": "st_492"}, {"end": 60773, "text": "Finally, C", "rank": 493, "start": 60763, "IsComparative": "0", "id": "st_493"}]}, {"paragraph_info": {"end": 61795, "start": 60773, "text": "Since t is trilinear, no level-set of t can intersect an edge more than once.Hence, if ci is not ambiguous, ti is exactly one of the cases 1 to 7 in the top row of Figure 3.2 <98>, either a topological disk or the empty set.Each case in the top row of Figure 3.2 is the unambiguous input for the MI algorithm to produce the voxel reconstruction shown in the middle row, where the boundaries of each of these voxel reconstructions are shown in the bottom row.By inspection, we can verify that the boundary of the digital reconstruction Oi (bottom row of Figure 3.2) is also a disk for all possible unambiguous cases and complement cases.Hence, for each i, the 2-manifolds Oi and ti are homeomorphic.Then, for each i, both Oi and ti cut the same set of edges and faces of ci.Again, we can verify this for all possible i by inspecting the top and bottom rows in Figure 3.2, respectively.Finally, we apply the Pasting Lemma <120> across neighboring surfaces Oi and Oj in order to establish the homeomorphism between O and t. 2", "rank": 148, "paragraph_comparative_number": 3, "entities": [], "id": "p_148"}, "sentences": [{"end": 60850, "text": "Since t is trilinear, no level-set of t can intersect an edge more than once.", "rank": 494, "start": 60773, "IsComparative": "0", "id": "st_494"}, {"end": 60997, "text": "Hence, if ci is not ambiguous, ti is exactly one of the cases 1 to 7 in the top row of Figure 3.2 <98>, either a topological disk or the empty set.", "rank": 495, "start": 60850, "IsComparative": "0", "id": "st_495"}, {"end": 61231, "text": "Each case in the top row of Figure 3.2 is the unambiguous input for the MI algorithm to produce the voxel reconstruction shown in the middle row, where the boundaries of each of these voxel reconstructions are shown in the bottom row.", "rank": 496, "start": 60997, "IsComparative": "0", "id": "st_496"}, {"end": 61409, "text": "By inspection, we can verify that the boundary of the digital reconstruction Oi (bottom row of Figure 3.2) is also a disk for all possible unambiguous cases and complement cases.", "rank": 497, "start": 61231, "IsComparative": "1", "id": "st_497"}, {"end": 61471, "text": "Hence, for each i, the 2-manifolds Oi and ti are homeomorphic.", "rank": 498, "start": 61409, "IsComparative": "0", "id": "st_498"}, {"end": 61546, "text": "Then, for each i, both Oi and ti cut the same set of edges and faces of ci.", "rank": 499, "start": 61471, "IsComparative": "1", "id": "st_499"}, {"end": 61657, "text": "Again, we can verify this for all possible i by inspecting the top and bottom rows in Figure 3.2, respectively.", "rank": 500, "start": 61546, "IsComparative": "0", "id": "st_500"}, {"end": 61795, "text": "Finally, we apply the Pasting Lemma <120> across neighboring surfaces Oi and Oj in order to establish the homeomorphism between O and t. 2", "rank": 501, "start": 61657, "IsComparative": "1", "id": "st_501"}]}, {"paragraph_info": {"end": 62168, "start": 61795, "text": "This proof provides a main ingredient for the verification method in Section 3.4.Cru- cially, we will show how to manufacture a complex solution that unambiguously crosses every cubic cell of the grid.Since we have shown the conditions for which the digital surfaces and the level sets are homeomorphic, any topological invariant will have to be the same for both surfaces.", "rank": 149, "paragraph_comparative_number": 1, "entities": [], "id": "p_149"}, "sentences": [{"end": 61876, "text": "This proof provides a main ingredient for the verification method in Section 3.4.", "rank": 502, "start": 61795, "IsComparative": "0", "id": "st_502"}, {"end": 61996, "text": "Cru- cially, we will show how to manufacture a complex solution that unambiguously crosses every cubic cell of the grid.", "rank": 503, "start": 61876, "IsComparative": "1", "id": "st_503"}, {"end": 62168, "text": "Since we have shown the conditions for which the digital surfaces and the level sets are homeomorphic, any topological invariant will have to be the same for both surfaces.", "rank": 504, "start": 61996, "IsComparative": "0", "id": "st_504"}]}, {"paragraph_info": {"end": 62197, "start": 62168, "text": "3.3.2 Stratified Morse Theory", "rank": 150, "paragraph_comparative_number": 0, "entities": [], "id": "p_150"}, "sentences": [{"end": 62197, "text": "3.3.2 Stratified Morse Theory", "rank": 505, "start": 62168, "IsComparative": "0", "id": "st_505"}]}, {"paragraph_info": {"end": 62797, "start": 62197, "text": "The mathematical developments presented above allow us to compute the Betti numbers of any isosurface of the piecewise trilinear interpolant.However, they require isosurfaces without boundaries.In this section, we provide a mechanism to compute the Euler charac- teristic of any regular isosurface of the piecewise trilinear interpolant through an analysis based on critical points, which can be used to verify properties of isosurfaces with boundary components.We will use some basic machinery from stratified Morse theory (SMT), following the presentation of Goresky and MacPhersons monograph <57>.", "rank": 151, "paragraph_comparative_number": 1, "entities": [], "id": "p_151"}, "sentences": [{"end": 62338, "text": "The mathematical developments presented above allow us to compute the Betti numbers of any isosurface of the piecewise trilinear interpolant.", "rank": 506, "start": 62197, "IsComparative": "0", "id": "st_506"}, {"end": 62391, "text": "However, they require isosurfaces without boundaries.", "rank": 507, "start": 62338, "IsComparative": "0", "id": "st_507"}, {"end": 62659, "text": "In this section, we provide a mechanism to compute the Euler charac- teristic of any regular isosurface of the piecewise trilinear interpolant through an analysis based on critical points, which can be used to verify properties of isosurfaces with boundary components.", "rank": 508, "start": 62391, "IsComparative": "0", "id": "st_508"}, {"end": 62797, "text": "We will use some basic machinery from stratified Morse theory (SMT), following the presentation of Goresky and MacPhersons monograph <57>.", "rank": 509, "start": 62659, "IsComparative": "1", "id": "st_509"}]}, {"paragraph_info": {"end": 63448, "start": 62797, "text": "Let f for now be a smooth function with isolated critical points p, where f(p) = 0.From classical Morse theory, the topology of two isosurfaces f(x) =  and f(x) = + differs only if the interval <,  + > contains a critical value (f (p) is a critical value iff p is a critical point).Moreover, if p is a small neighborhood around p and L(p) and L+(p) are the subset of points on the boundary of p satisfying f(x) < f(p) and f(x) > f(p), respectively, then the topological change from the isosurface f(x) = f(p) to f(x) = f(p)+ is characterized by removing L(p) and attaching L+(p).Thus, changes in the Euler characteristic, denoted by (p), are given by:", "rank": 152, "paragraph_comparative_number": 2, "entities": [], "id": "p_152"}, "sentences": [{"end": 62880, "text": "Let f for now be a smooth function with isolated critical points p, where f(p) = 0.", "rank": 510, "start": 62797, "IsComparative": "0", "id": "st_510"}, {"end": 63079, "text": "From classical Morse theory, the topology of two isosurfaces f(x) =  and f(x) = + differs only if the interval <,  + > contains a critical value (f (p) is a critical value iff p is a critical point).", "rank": 511, "start": 62880, "IsComparative": "1", "id": "st_511"}, {"end": 63376, "text": "Moreover, if p is a small neighborhood around p and L(p) and L+(p) are the subset of points on the boundary of p satisfying f(x) < f(p) and f(x) > f(p), respectively, then the topological change from the isosurface f(x) = f(p) to f(x) = f(p)+ is characterized by removing L(p) and attaching L+(p).", "rank": 512, "start": 63079, "IsComparative": "1", "id": "st_512"}, {"end": 63448, "text": "Thus, changes in the Euler characteristic, denoted by (p), are given by:", "rank": 513, "start": 63376, "IsComparative": "0", "id": "st_513"}]}, {"paragraph_info": {"end": 63624, "start": 63448, "text": "For a smooth function f, the number of negative eigenvalues of the Hessian matrix de- termines the index of a critical point p, and the four cases give the following values for", "rank": 153, "paragraph_comparative_number": 1, "entities": [], "id": "p_153"}, "sentences": [{"end": 63624, "text": "For a smooth function f, the number of negative eigenvalues of the Hessian matrix de- termines the index of a critical point p, and the four cases give the following values for", "rank": 514, "start": 63448, "IsComparative": "1", "id": "st_514"}]}, {"paragraph_info": {"end": 64711, "start": 63624, "text": "The above formulation is straightforward but unfortunately cannot be directly applied to functions appearing in either piecewise trilinear interpolations or isosurfaces with boundary, both of which appear in some of the isosurfacing algorithms with guaranteed topology.Trilinear interpolants are not smooth across the faces of grid cells, so the gradient is not well- defined there.Identifying the critical points using smooth Morse theory is then problematic.Although arguments based on smooth Morse theory have appeared in the literature <183>, there are complications.For example, the scalar field in a node of the regular grid might not have any partial derivatives.Although one can still argue about the intuitive concepts of minima and maxima around a nondifferentiable point, configurations such as saddles are more problematic, since their topological behavior is different depending on whether they are on the boundary of the domain.It is important, then, to have a mathematical tool which makes predictions regardless of the types of configurations, and SMT is one such theory.", "rank": 154, "paragraph_comparative_number": 1, "entities": [], "id": "p_154"}, "sentences": [{"end": 63893, "text": "The above formulation is straightforward but unfortunately cannot be directly applied to functions appearing in either piecewise trilinear interpolations or isosurfaces with boundary, both of which appear in some of the isosurfacing algorithms with guaranteed topology.", "rank": 515, "start": 63624, "IsComparative": "0", "id": "st_515"}, {"end": 64006, "text": "Trilinear interpolants are not smooth across the faces of grid cells, so the gradient is not well- defined there.", "rank": 516, "start": 63893, "IsComparative": "0", "id": "st_516"}, {"end": 64084, "text": "Identifying the critical points using smooth Morse theory is then problematic.", "rank": 517, "start": 64006, "IsComparative": "0", "id": "st_517"}, {"end": 64195, "text": "Although arguments based on smooth Morse theory have appeared in the literature <183>, there are complications.", "rank": 518, "start": 64084, "IsComparative": "0", "id": "st_518"}, {"end": 64294, "text": "For example, the scalar field in a node of the regular grid might not have any partial derivatives.", "rank": 519, "start": 64195, "IsComparative": "1", "id": "st_519"}, {"end": 64566, "text": "Although one can still argue about the intuitive concepts of minima and maxima around a nondifferentiable point, configurations such as saddles are more problematic, since their topological behavior is different depending on whether they are on the boundary of the domain.", "rank": 520, "start": 64294, "IsComparative": "0", "id": "st_520"}, {"end": 64711, "text": "It is important, then, to have a mathematical tool which makes predictions regardless of the types of configurations, and SMT is one such theory.", "rank": 521, "start": 64566, "IsComparative": "0", "id": "st_521"}]}, {"paragraph_info": {"end": 65548, "start": 64711, "text": "Intuitively, a stratification is a partition of a piecewise-smooth manifold such that each subset, called a stratum, is either a set of discrete points or has a smooth structure.In a regular grid with cubic cells, the stratification we propose will be formed by four sets (the strata), each one a (possibly disconnected) manifold.The vertex set contains all vertices of the grid.The edge set contains all edge interiors, the face set contains all face interiors, and the cell set contains all cube interiors.We illustrate the concept for the 2D case in Figure 3.4.The important property of the strata is that the level sets of f restricted to each stratum are smooth (or lack any differential structure, as in the vertex-set).In SMT, one applies standard Morse theory on each stratum, and then combines the partial results appropriately.", "rank": 155, "paragraph_comparative_number": 2, "entities": [], "id": "p_155"}, "sentences": [{"end": 64889, "text": "Intuitively, a stratification is a partition of a piecewise-smooth manifold such that each subset, called a stratum, is either a set of discrete points or has a smooth structure.", "rank": 522, "start": 64711, "IsComparative": "1", "id": "st_522"}, {"end": 65041, "text": "In a regular grid with cubic cells, the stratification we propose will be formed by four sets (the strata), each one a (possibly disconnected) manifold.", "rank": 523, "start": 64889, "IsComparative": "1", "id": "st_523"}, {"end": 65090, "text": "The vertex set contains all vertices of the grid.", "rank": 524, "start": 65041, "IsComparative": "0", "id": "st_524"}, {"end": 65219, "text": "The edge set contains all edge interiors, the face set contains all face interiors, and the cell set contains all cube interiors.", "rank": 525, "start": 65090, "IsComparative": "0", "id": "st_525"}, {"end": 65275, "text": "We illustrate the concept for the 2D case in Figure 3.4.", "rank": 526, "start": 65219, "IsComparative": "0", "id": "st_526"}, {"end": 65437, "text": "The important property of the strata is that the level sets of f restricted to each stratum are smooth (or lack any differential structure, as in the vertex-set).", "rank": 527, "start": 65275, "IsComparative": "0", "id": "st_527"}, {"end": 65548, "text": "In SMT, one applies standard Morse theory on each stratum, and then combines the partial results appropriately.", "rank": 528, "start": 65437, "IsComparative": "0", "id": "st_528"}]}, {"paragraph_info": {"end": 66326, "start": 65548, "text": "The set of points with zero gradient (computed on each stratum), which SMT assumes to be isolated, are called the critical points of the stratified Morse function.In addition, every point in the vertex set is considered critical as well.One major difference between SMT and the smooth theory is that some critical points do not actually change the topology of the level sets.This is why considering all grid vertices as critical does not introduce any practical problems: most grid vertices of typical scalar fields will be virtual critical points, i.e., points which do not change the Euler characteristic of the surface.Carr and Snoeyink use a related concept (which they call potential critical points) in their state-machine description of the topology of interpolants <17>.", "rank": 156, "paragraph_comparative_number": 1, "entities": [], "id": "p_156"}, "sentences": [{"end": 65711, "text": "The set of points with zero gradient (computed on each stratum), which SMT assumes to be isolated, are called the critical points of the stratified Morse function.", "rank": 529, "start": 65548, "IsComparative": "0", "id": "st_529"}, {"end": 65785, "text": "In addition, every point in the vertex set is considered critical as well.", "rank": 530, "start": 65711, "IsComparative": "0", "id": "st_530"}, {"end": 65923, "text": "One major difference between SMT and the smooth theory is that some critical points do not actually change the topology of the level sets.", "rank": 531, "start": 65785, "IsComparative": "0", "id": "st_531"}, {"end": 66170, "text": "This is why considering all grid vertices as critical does not introduce any practical problems: most grid vertices of typical scalar fields will be virtual critical points, i.e., points which do not change the Euler characteristic of the surface.", "rank": 532, "start": 65923, "IsComparative": "0", "id": "st_532"}, {"end": 66326, "text": "Carr and Snoeyink use a related concept (which they call potential critical points) in their state-machine description of the topology of interpolants <17>.", "rank": 533, "start": 66170, "IsComparative": "1", "id": "st_533"}]}, {"paragraph_info": {"end": 67556, "start": 66326, "text": "Let M be the stratified grid described above.It can be shown that if p is a point in a d-dimensional stratum of M, it is always possible to find a (3d)-dimensional submanifold of M (which might straddle many strata) that meets transversely the stratum containing p, and whose intersection consists of only p (one way to think of this (3  d)-manifold is as a topological orthogonal complement).In this context, we can define a small neighborhood T(p) in the strata containing p and the lower tangential link TL(p) as the set of points in the boundary of T(p) with scalar values less than that in p (see Figure 3.5).Similarly, we can define the upper tangential link TL+(p) as the set of points in the boundary of T(p) with scalar value higher than that at p.Lower normal NL(p) and upper normal NL+(p) links are analogous notions, but the lower and upper links are taken to be subsets of N(p), itself a subset of the (3  d)-dimensional submanifold transverse to the stratum of p going through p.The definitions above are needed in order to define the lower stratified link and upper stratified link, as follows: given T(p), TL(p), N(p) and NL(p), the lower stratified Morse link (and similarly for upper stratified link) is given by", "rank": 157, "paragraph_comparative_number": 2, "entities": [], "id": "p_157"}, "sentences": [{"end": 66371, "text": "Let M be the stratified grid described above.", "rank": 534, "start": 66326, "IsComparative": "0", "id": "st_534"}, {"end": 66719, "text": "It can be shown that if p is a point in a d-dimensional stratum of M, it is always possible to find a (3d)-dimensional submanifold of M (which might straddle many strata) that meets transversely the stratum containing p, and whose intersection consists of only p (one way to think of this (3  d)-manifold is as a topological orthogonal complement).", "rank": 535, "start": 66371, "IsComparative": "1", "id": "st_535"}, {"end": 66940, "text": "In this context, we can define a small neighborhood T(p) in the strata containing p and the lower tangential link TL(p) as the set of points in the boundary of T(p) with scalar values less than that in p (see Figure 3.5).", "rank": 536, "start": 66719, "IsComparative": "1", "id": "st_536"}, {"end": 67083, "text": "Similarly, we can define the upper tangential link TL+(p) as the set of points in the boundary of T(p) with scalar value higher than that at p.", "rank": 537, "start": 66940, "IsComparative": "0", "id": "st_537"}, {"end": 67319, "text": "Lower normal NL(p) and upper normal NL+(p) links are analogous notions, but the lower and upper links are taken to be subsets of N(p), itself a subset of the (3  d)-dimensional submanifold transverse to the stratum of p going through p.", "rank": 538, "start": 67083, "IsComparative": "0", "id": "st_538"}, {"end": 67556, "text": "The definitions above are needed in order to define the lower stratified link and upper stratified link, as follows: given T(p), TL(p), N(p) and NL(p), the lower stratified Morse link (and similarly for upper stratified link) is given by", "rank": 539, "start": 67319, "IsComparative": "0", "id": "st_539"}]}, {"paragraph_info": {"end": 67597, "start": 67556, "text": "L(p) = (T(p)  NL(p))  (N(p)  TL(p)).(3.2)", "rank": 158, "paragraph_comparative_number": 1, "entities": [], "id": "p_158"}, "sentences": [{"end": 67592, "text": "L(p) = (T(p)  NL(p))  (N(p)  TL(p)).", "rank": 540, "start": 67556, "IsComparative": "0", "id": "st_540"}, {"end": 67597, "text": "(3.2)", "rank": 541, "start": 67592, "IsComparative": "1", "id": "st_541"}]}, {"paragraph_info": {"end": 68020, "start": 67597, "text": "These definitions allow us to classify critical points even in the nonsmooth scenario.They let us compute topological changes with the same methodology used in the smooth case.In other words, when a scalar value  crosses a critical value p in a critical point p, the topological change in the isosurface is characterized by removing L(p) and attaching L+(p), affecting the Euler characteristic as defined in Equation (3.1).", "rank": 159, "paragraph_comparative_number": 1, "entities": [], "id": "p_159"}, "sentences": [{"end": 67683, "text": "These definitions allow us to classify critical points even in the nonsmooth scenario.", "rank": 542, "start": 67597, "IsComparative": "1", "id": "st_542"}, {"end": 67773, "text": "They let us compute topological changes with the same methodology used in the smooth case.", "rank": 543, "start": 67683, "IsComparative": "0", "id": "st_543"}, {"end": 68020, "text": "In other words, when a scalar value  crosses a critical value p in a critical point p, the topological change in the isosurface is characterized by removing L(p) and attaching L+(p), affecting the Euler characteristic as defined in Equation (3.1).", "rank": 544, "start": 67773, "IsComparative": "0", "id": "st_544"}]}, {"paragraph_info": {"end": 68187, "start": 68020, "text": "The remaining problem is how to determine (L(p)) and (L+(p)).Recalling that (AB) = (A)+(B)(AB), (AB) = (A)(B), and (T) = (N) = 1 (we are omitting the point p) we have:", "rank": 160, "paragraph_comparative_number": 0, "entities": [], "id": "p_160"}, "sentences": [{"end": 68081, "text": "The remaining problem is how to determine (L(p)) and (L+(p)).", "rank": 545, "start": 68020, "IsComparative": "0", "id": "st_545"}, {"end": 68187, "text": "Recalling that (AB) = (A)+(B)(AB), (AB) = (A)(B), and (T) = (N) = 1 (we are omitting the point p) we have:", "rank": 546, "start": 68081, "IsComparative": "0", "id": "st_546"}]}, {"paragraph_info": {"end": 68650, "start": 68187, "text": "The same result is valid for (L+), if we replace the superscript  by + in Equa- tion (3.4).If TL or TL+ are one-dimensional, then we are done.If not, then we can recursively apply the same equation to TL and TL+ and look at progressively lower-dimensional strata until we reach T(p) and N(p) given by 1-disks.The lower and upper links for these 1-disks will always be discrete spaces with zero, one, or two points, for which  is simply the cardinality of the set.", "rank": 161, "paragraph_comparative_number": 1, "entities": [], "id": "p_161"}, "sentences": [{"end": 68278, "text": "The same result is valid for (L+), if we replace the superscript  by + in Equa- tion (3.4).", "rank": 547, "start": 68187, "IsComparative": "0", "id": "st_547"}, {"end": 68329, "text": "If TL or TL+ are one-dimensional, then we are done.", "rank": 548, "start": 68278, "IsComparative": "0", "id": "st_548"}, {"end": 68496, "text": "If not, then we can recursively apply the same equation to TL and TL+ and look at progressively lower-dimensional strata until we reach T(p) and N(p) given by 1-disks.", "rank": 549, "start": 68329, "IsComparative": "0", "id": "st_549"}, {"end": 68650, "text": "The lower and upper links for these 1-disks will always be discrete spaces with zero, one, or two points, for which  is simply the cardinality of the set.", "rank": 550, "start": 68496, "IsComparative": "1", "id": "st_550"}]}, {"paragraph_info": {"end": 69640, "start": 68650, "text": "In some cases, the Euler characteristic of the lower and upper link might be equal.Then, (L(p)) = (L+(p)), and (p) = 0.These cases correspond to the virtual critical points mentioned above.Critical points in the interior of cubic cells are handled by the smooth theory, since in that case the normal Morse data are 0-dimensional.This implies that the link will be an empty set with Euler characteristic zero.So, by Equation (3.4), (L) = (TL).Because the restriction of the scalar field to a grid edge is a linear function, no critical point can appear there.As a result, the new cases are critical points occurring at vertices or in the interior of faces of the grid.For a critical point p in a vertex, stratification can be carried out recursively, using the edges of the cubes meeting in p as tangential and normal submanifolds.Denoting by nl1,nl2,nl3 the number of vertices adjacent to p with scalar value less than that of p in each Cartesian coordinate direction, Equation (3.4) gives:", "rank": 162, "paragraph_comparative_number": 3, "entities": [], "id": "p_162"}, "sentences": [{"end": 68733, "text": "In some cases, the Euler characteristic of the lower and upper link might be equal.", "rank": 551, "start": 68650, "IsComparative": "0", "id": "st_551"}, {"end": 68769, "text": "Then, (L(p)) = (L+(p)), and (p) = 0.", "rank": 552, "start": 68733, "IsComparative": "0", "id": "st_552"}, {"end": 68839, "text": "These cases correspond to the virtual critical points mentioned above.", "rank": 553, "start": 68769, "IsComparative": "0", "id": "st_553"}, {"end": 68979, "text": "Critical points in the interior of cubic cells are handled by the smooth theory, since in that case the normal Morse data are 0-dimensional.", "rank": 554, "start": 68839, "IsComparative": "1", "id": "st_554"}, {"end": 69058, "text": "This implies that the link will be an empty set with Euler characteristic zero.", "rank": 555, "start": 68979, "IsComparative": "0", "id": "st_555"}, {"end": 69092, "text": "So, by Equation (3.4), (L) = (TL).", "rank": 556, "start": 69058, "IsComparative": "0", "id": "st_556"}, {"end": 69208, "text": "Because the restriction of the scalar field to a grid edge is a linear function, no critical point can appear there.", "rank": 557, "start": 69092, "IsComparative": "1", "id": "st_557"}, {"end": 69317, "text": "As a result, the new cases are critical points occurring at vertices or in the interior of faces of the grid.", "rank": 558, "start": 69208, "IsComparative": "0", "id": "st_558"}, {"end": 69480, "text": "For a critical point p in a vertex, stratification can be carried out recursively, using the edges of the cubes meeting in p as tangential and normal submanifolds.", "rank": 559, "start": 69317, "IsComparative": "0", "id": "st_559"}, {"end": 69640, "text": "Denoting by nl1,nl2,nl3 the number of vertices adjacent to p with scalar value less than that of p in each Cartesian coordinate direction, Equation (3.4) gives:", "rank": 560, "start": 69480, "IsComparative": "1", "id": "st_560"}]}, {"paragraph_info": {"end": 69783, "start": 69640, "text": "(L+(p)) can be computed similarly, but considering the number of neighbors of p in each Cartesian direction with scalars higher than that of p.", "rank": 163, "paragraph_comparative_number": 0, "entities": [], "id": "p_163"}, "sentences": [{"end": 69783, "text": "(L+(p)) can be computed similarly, but considering the number of neighbors of p in each Cartesian direction with scalars higher than that of p.", "rank": 561, "start": 69640, "IsComparative": "0", "id": "st_561"}]}, {"paragraph_info": {"end": 70337, "start": 69783, "text": "If p is a critical point lying in a face r of a cube, we consider the face itself as the tangential submanifold and the line segment r orthogonal to r through p the normal submanifold.Recursively, the tangential submanifold can be further stratified in two 1-disks (tangential and normal).Denote by nl the number of ends of r with scalar value less than that of p.Also, recalling that the critical point lying in the face r is necessarily a saddle, thus having two face corners with scalar values less and two higher than that of p, Equation (3.4) gives:", "rank": 164, "paragraph_comparative_number": 1, "entities": [], "id": "p_164"}, "sentences": [{"end": 69967, "text": "If p is a critical point lying in a face r of a cube, we consider the face itself as the tangential submanifold and the line segment r orthogonal to r through p the normal submanifold.", "rank": 562, "start": 69783, "IsComparative": "0", "id": "st_562"}, {"end": 70072, "text": "Recursively, the tangential submanifold can be further stratified in two 1-disks (tangential and normal).", "rank": 563, "start": 69967, "IsComparative": "1", "id": "st_563"}, {"end": 70147, "text": "Denote by nl the number of ends of r with scalar value less than that of p.", "rank": 564, "start": 70072, "IsComparative": "0", "id": "st_564"}, {"end": 70337, "text": "Also, recalling that the critical point lying in the face r is necessarily a saddle, thus having two face corners with scalar values less and two higher than that of p, Equation (3.4) gives:", "rank": 565, "start": 70147, "IsComparative": "0", "id": "st_565"}]}, {"paragraph_info": {"end": 70464, "start": 70337, "text": "Analogously, we can compute (L+(p)) = nu + 2  2 nu where nu is the number of ends of r with scalar value higher than that of p.", "rank": 165, "paragraph_comparative_number": 1, "entities": [], "id": "p_165"}, "sentences": [{"end": 70464, "text": "Analogously, we can compute (L+(p)) = nu + 2  2 nu where nu is the number of ends of r with scalar value higher than that of p.", "rank": 566, "start": 70337, "IsComparative": "1", "id": "st_566"}]}, {"paragraph_info": {"end": 70887, "start": 70464, "text": "A similar analysis can be be carried out for every type of critical point, regardless of whether the point belongs to the interior of a grid cell (and so would yield equally well to a smooth Morse theory analysis), an interior face, a boundary face, or a vertex of any type.The Euler characteristic  of any isosurface with isovalue  is simply given as: where C is the set of critical points with critical values less than .", "rank": 166, "paragraph_comparative_number": 1, "entities": [], "id": "p_166"}, "sentences": [{"end": 70738, "text": "A similar analysis can be be carried out for every type of critical point, regardless of whether the point belongs to the interior of a grid cell (and so would yield equally well to a smooth Morse theory analysis), an interior face, a boundary face, or a vertex of any type.", "rank": 567, "start": 70464, "IsComparative": "1", "id": "st_567"}, {"end": 70887, "text": "The Euler characteristic  of any isosurface with isovalue  is simply given as: where C is the set of critical points with critical values less than .", "rank": 568, "start": 70738, "IsComparative": "0", "id": "st_568"}]}, {"paragraph_info": {"end": 71544, "start": 70887, "text": "It is worth mentioning once again that, to the best of our knowledge, no other work has presented a scheme which provides such a simple mechanism for computing the Euler characteristic of level sets of piecewise-smooth trilinear functions.Compare, for example, the case analyses and state machines performed separately by Nielson <125>, by Carr and Snoeyink <17>, and by Carr and Max <15>.In contrast, we can recover an (admittedly weaker) topological invariant by a much simpler argument.In addition, this argument already generalizes (trivially because of the stratification argument) to arbitrary dimensions, unlike the other arguments in the literature.", "rank": 167, "paragraph_comparative_number": 3, "entities": [], "id": "p_167"}, "sentences": [{"end": 71126, "text": "It is worth mentioning once again that, to the best of our knowledge, no other work has presented a scheme which provides such a simple mechanism for computing the Euler characteristic of level sets of piecewise-smooth trilinear functions.", "rank": 569, "start": 70887, "IsComparative": "1", "id": "st_569"}, {"end": 71276, "text": "Compare, for example, the case analyses and state machines performed separately by Nielson <125>, by Carr and Snoeyink <17>, and by Carr and Max <15>.", "rank": 570, "start": 71126, "IsComparative": "1", "id": "st_570"}, {"end": 71376, "text": "In contrast, we can recover an (admittedly weaker) topological invariant by a much simpler argument.", "rank": 571, "start": 71276, "IsComparative": "1", "id": "st_571"}, {"end": 71544, "text": "In addition, this argument already generalizes (trivially because of the stratification argument) to arbitrary dimensions, unlike the other arguments in the literature.", "rank": 572, "start": 71376, "IsComparative": "0", "id": "st_572"}]}, {"paragraph_info": {"end": 71578, "start": 71544, "text": "3.4 Manufactured Solution Pipeline", "rank": 168, "paragraph_comparative_number": 0, "entities": [], "id": "p_168"}, "sentences": [{"end": 71578, "text": "3.4 Manufactured Solution Pipeline", "rank": 573, "start": 71544, "IsComparative": "0", "id": "st_573"}]}, {"paragraph_info": {"end": 71901, "start": 71578, "text": "We now put the pieces together and build a pipeline for topology verification using the re- sults presented in Section 3.3.In the following sections, the procedure called Isosurfacing refers to the isosurface extraction technique under verification.InvariantFromMesh computes topological invariants of a simplicial complex.", "rank": 169, "paragraph_comparative_number": 0, "entities": [], "id": "p_169"}, "sentences": [{"end": 71701, "text": "We now put the pieces together and build a pipeline for topology verification using the re- sults presented in Section 3.3.", "rank": 574, "start": 71578, "IsComparative": "0", "id": "st_574"}, {"end": 71827, "text": "In the following sections, the procedure called Isosurfacing refers to the isosurface extraction technique under verification.", "rank": 575, "start": 71701, "IsComparative": "0", "id": "st_575"}, {"end": 71901, "text": "InvariantFromMesh computes topological invariants of a simplicial complex.", "rank": 576, "start": 71827, "IsComparative": "0", "id": "st_576"}]}, {"paragraph_info": {"end": 71918, "start": 71901, "text": "3.4.1 Consistency", "rank": 170, "paragraph_comparative_number": 0, "entities": [], "id": "p_170"}, "sentences": [{"end": 71918, "text": "3.4.1 Consistency", "rank": 577, "start": 71901, "IsComparative": "0", "id": "st_577"}]}, {"paragraph_info": {"end": 72707, "start": 71918, "text": "As previously mentioned, MC-like algorithms which use disambiguation techniques are expected to generate PL manifold isosurfaces no matter how complex the function sampled in the vertices of the regular grid.In order to stress the consistency test, we generate a random scalar field with values in the interval <1,1> and extract the isosurface with isovalue  = 0 (which is all but guaranteed not to be a critical value) using a given isosurfacing technique, subjecting the resulting triangle mesh to the consistency verification.This process is repeated a large number of times, and if the implementation fails to produce PL manifolds for all cases, then the counterexample provides a documented starting point for debugging.If it passes the tests, we consider the implementation verified.", "rank": 171, "paragraph_comparative_number": 1, "entities": [], "id": "p_171"}, "sentences": [{"end": 72126, "text": "As previously mentioned, MC-like algorithms which use disambiguation techniques are expected to generate PL manifold isosurfaces no matter how complex the function sampled in the vertices of the regular grid.", "rank": 578, "start": 71918, "IsComparative": "0", "id": "st_578"}, {"end": 72447, "text": "In order to stress the consistency test, we generate a random scalar field with values in the interval <1,1> and extract the isosurface with isovalue  = 0 (which is all but guaranteed not to be a critical value) using a given isosurfacing technique, subjecting the resulting triangle mesh to the consistency verification.", "rank": 579, "start": 72126, "IsComparative": "1", "id": "st_579"}, {"end": 72643, "text": "This process is repeated a large number of times, and if the implementation fails to produce PL manifolds for all cases, then the counterexample provides a documented starting point for debugging.", "rank": 580, "start": 72447, "IsComparative": "0", "id": "st_580"}, {"end": 72707, "text": "If it passes the tests, we consider the implementation verified.", "rank": 581, "start": 72643, "IsComparative": "0", "id": "st_581"}]}, {"paragraph_info": {"end": 72755, "start": 72707, "text": "3.4.2 Verification Using Stratified Morse Theory", "rank": 172, "paragraph_comparative_number": 0, "entities": [], "id": "p_172"}, "sentences": [{"end": 72755, "text": "3.4.2 Verification Using Stratified Morse Theory", "rank": 582, "start": 72707, "IsComparative": "0", "id": "st_582"}]}, {"paragraph_info": {"end": 73191, "start": 72755, "text": "We can use the formulation described in Section 3.3.2 to verify isosurfacing programs which promise to match the topology of the trilinear interpolant.The SMT-based verifi- cation procedure is summarized in Algorithm 3.The algorithm has four main steps.A random scalar field with node values in the interval <1, 1> is initially created.Representing the trilinear interpolation in a grid cell by f(x, y, z) = axyz+bxy+cxz+dyz+ex+fy+gz+h,", "rank": 173, "paragraph_comparative_number": 1, "entities": [], "id": "p_173"}, "sentences": [{"end": 72906, "text": "We can use the formulation described in Section 3.3.2 to verify isosurfacing programs which promise to match the topology of the trilinear interpolant.", "rank": 583, "start": 72755, "IsComparative": "0", "id": "st_583"}, {"end": 72974, "text": "The SMT-based verifi- cation procedure is summarized in Algorithm 3.", "rank": 584, "start": 72906, "IsComparative": "0", "id": "st_584"}, {"end": 73008, "text": "The algorithm has four main steps.", "rank": 585, "start": 72974, "IsComparative": "0", "id": "st_585"}, {"end": 73091, "text": "A random scalar field with node values in the interval <1, 1> is initially created.", "rank": 586, "start": 73008, "IsComparative": "0", "id": "st_586"}, {"end": 73191, "text": "Representing the trilinear interpolation in a grid cell by f(x, y, z) = axyz+bxy+cxz+dyz+ex+fy+gz+h,", "rank": 587, "start": 73091, "IsComparative": "1", "id": "st_587"}]}, {"paragraph_info": {"end": 73232, "start": 73191, "text": "3.4.3 Verification Using Digital Topology", "rank": 174, "paragraph_comparative_number": 0, "entities": [], "id": "p_174"}, "sentences": [{"end": 73232, "text": "3.4.3 Verification Using Digital Topology", "rank": 588, "start": 73191, "IsComparative": "0", "id": "st_588"}]}, {"paragraph_info": {"end": 74110, "start": 73232, "text": "Algorithm 4 shows the verification pipeline using the MI algorithm, and Figure 3.6 depicts the refinement process.Once again a random scalar field, with potentially many ambiguous cubes, is initially generated in the vertices of a grid G.The algorithm illustrated in Algorithm 4 is applied to refine G so as to generate a new grid G  which does not have ambiguous cells.If the maximum number of refinement is reached and ambiguous cells still remain, then the process is restarted from scratch.Notice that cube subdivision does not need to be uniform.For instance, each cube may be refined using a randomly placed new node point or using tis critical points, and the result of the verification process still holds.This is because Theorem 3.3.1 only requires ci to be unambiguous.For simplicity, in this work, we refine G uniformly doubling the grid resolution in each dimension.", "rank": 175, "paragraph_comparative_number": 0, "entities": [], "id": "p_175"}, "sentences": [{"end": 73346, "text": "Algorithm 4 shows the verification pipeline using the MI algorithm, and Figure 3.6 depicts the refinement process.", "rank": 589, "start": 73232, "IsComparative": "0", "id": "st_589"}, {"end": 73470, "text": "Once again a random scalar field, with potentially many ambiguous cubes, is initially generated in the vertices of a grid G.", "rank": 590, "start": 73346, "IsComparative": "0", "id": "st_590"}, {"end": 73602, "text": "The algorithm illustrated in Algorithm 4 is applied to refine G so as to generate a new grid G  which does not have ambiguous cells.", "rank": 591, "start": 73470, "IsComparative": "0", "id": "st_591"}, {"end": 73726, "text": "If the maximum number of refinement is reached and ambiguous cells still remain, then the process is restarted from scratch.", "rank": 592, "start": 73602, "IsComparative": "0", "id": "st_592"}, {"end": 73783, "text": "Notice that cube subdivision does not need to be uniform.", "rank": 593, "start": 73726, "IsComparative": "0", "id": "st_593"}, {"end": 73946, "text": "For instance, each cube may be refined using a randomly placed new node point or using tis critical points, and the result of the verification process still holds.", "rank": 594, "start": 73783, "IsComparative": "0", "id": "st_594"}, {"end": 74011, "text": "This is because Theorem 3.3.1 only requires ci to be unambiguous.", "rank": 595, "start": 73946, "IsComparative": "0", "id": "st_595"}, {"end": 74110, "text": "For simplicity, in this work, we refine G uniformly doubling the grid resolution in each dimension.", "rank": 596, "start": 74011, "IsComparative": "0", "id": "st_596"}]}, {"paragraph_info": {"end": 74628, "start": 74110, "text": "Scalars are assigned to the new vertices of G  (the ones not in G) by trilinearly in- terpolating from scalars in G, thus ensuring that G and G  have exactly the same scalar field <125>.As all cubic cells in G  are unambiguous, Theorem 3.3.1 guarantees the topology of the digital surface O obtained from G  is equivalent to that of t(x) = .Algorithm InvariantFromDS computes topological invariants of O using the scheme discussed in Section 3.3.1.In this context, InvariantFromDS is the algorithm illustrated in Algo-", "rank": 176, "paragraph_comparative_number": 1, "entities": [], "id": "p_176"}, "sentences": [{"end": 74296, "text": "Scalars are assigned to the new vertices of G  (the ones not in G) by trilinearly in- terpolating from scalars in G, thus ensuring that G and G  have exactly the same scalar field <125>.", "rank": 597, "start": 74110, "IsComparative": "0", "id": "st_597"}, {"end": 74451, "text": "As all cubic cells in G  are unambiguous, Theorem 3.3.1 guarantees the topology of the digital surface O obtained from G  is equivalent to that of t(x) = .", "rank": 598, "start": 74296, "IsComparative": "1", "id": "st_598"}, {"end": 74558, "text": "Algorithm InvariantFromDS computes topological invariants of O using the scheme discussed in Section 3.3.1.", "rank": 599, "start": 74451, "IsComparative": "0", "id": "st_599"}, {"end": 74628, "text": "In this context, InvariantFromDS is the algorithm illustrated in Algo-", "rank": 600, "start": 74558, "IsComparative": "0", "id": "st_600"}]}, {"paragraph_info": {"end": 74845, "start": 74628, "text": "Algorithm 4 Overview of the method of manufactured solutions (MMS) using digital topology.The method either fails to match the expected topology, in which case G is provided as a counterexample, or succeeds otherwise.", "rank": 177, "paragraph_comparative_number": 1, "entities": [], "id": "p_177"}, "sentences": [{"end": 74718, "text": "Algorithm 4 Overview of the method of manufactured solutions (MMS) using digital topology.", "rank": 601, "start": 74628, "IsComparative": "1", "id": "st_601"}, {"end": 74845, "text": "The method either fails to match the expected topology, in which case G is provided as a counterexample, or succeeds otherwise.", "rank": 602, "start": 74718, "IsComparative": "0", "id": "st_602"}]}, {"paragraph_info": {"end": 74869, "start": 74845, "text": "3.5 Experimental Results", "rank": 178, "paragraph_comparative_number": 0, "entities": [], "id": "p_178"}, "sentences": [{"end": 74869, "text": "3.5 Experimental Results", "rank": 603, "start": 74845, "IsComparative": "0", "id": "st_603"}]}, {"paragraph_info": {"end": 75122, "start": 74869, "text": "In this section, we present the results of applying our topology verification methodology to a number of different isosurfacing techniques, three of them with topological guarantees with respect to trilinear interpolant.Specifically, the techniques are:", "rank": 179, "paragraph_comparative_number": 1, "entities": [], "id": "p_179"}, "sentences": [{"end": 75089, "text": "In this section, we present the results of applying our topology verification methodology to a number of different isosurfacing techniques, three of them with topological guarantees with respect to trilinear interpolant.", "rank": 604, "start": 74869, "IsComparative": "1", "id": "st_604"}, {"end": 75122, "text": "Specifically, the techniques are:", "rank": 605, "start": 75089, "IsComparative": "0", "id": "st_605"}]}, {"paragraph_info": {"end": 75519, "start": 75122, "text": "VTKMC <155> is the Visualization Toolkit (VTK) implementation of the Marching Cubes algorithm with the implicit disambiguation scheme proposed by Montani et al.<117>.Essentially, it separates positive vertices when a face saddle appears and assumes no tunnels exist inside a cube.The proposed scheme is topologically consistent, but it does not reproduce the topology of the trilinear interpolant.", "rank": 180, "paragraph_comparative_number": 2, "entities": [], "id": "p_180"}, "sentences": [{"end": 75282, "text": "VTKMC <155> is the Visualization Toolkit (VTK) implementation of the Marching Cubes algorithm with the implicit disambiguation scheme proposed by Montani et al.", "rank": 606, "start": 75122, "IsComparative": "0", "id": "st_606"}, {"end": 75288, "text": "<117>.", "rank": 607, "start": 75282, "IsComparative": "1", "id": "st_607"}, {"end": 75402, "text": "Essentially, it separates positive vertices when a face saddle appears and assumes no tunnels exist inside a cube.", "rank": 608, "start": 75288, "IsComparative": "1", "id": "st_608"}, {"end": 75519, "text": "The proposed scheme is topologically consistent, but it does not reproduce the topology of the trilinear interpolant.", "rank": 609, "start": 75402, "IsComparative": "0", "id": "st_609"}]}, {"paragraph_info": {"end": 75906, "start": 75519, "text": "Marching Cubes with Edge Transformations or Macet <33> is a Marching Cubes-based technique designed to generate triangle meshes with good quality.Quality is reached by displacing active edges of the grid (edges intersected by the isosurface), both in normal and tangential direction toward avoiding sliver intersections.Macet does not reproduce the topology of the trilinear interpolant.", "rank": 181, "paragraph_comparative_number": 1, "entities": [], "id": "p_181"}, "sentences": [{"end": 75665, "text": "Marching Cubes with Edge Transformations or Macet <33> is a Marching Cubes-based technique designed to generate triangle meshes with good quality.", "rank": 610, "start": 75519, "IsComparative": "1", "id": "st_610"}, {"end": 75839, "text": "Quality is reached by displacing active edges of the grid (edges intersected by the isosurface), both in normal and tangential direction toward avoiding sliver intersections.", "rank": 611, "start": 75665, "IsComparative": "0", "id": "st_611"}, {"end": 75906, "text": "Macet does not reproduce the topology of the trilinear interpolant.", "rank": 612, "start": 75839, "IsComparative": "0", "id": "st_612"}]}, {"paragraph_info": {"end": 76525, "start": 75906, "text": "Afront <153> is an advancing-front method for isosurface extraction, remeshing, and triangulation of point sets.It works by advancing triangles over an implicit surface.A sizing function that takes curvature into account is used to adapt the triangle mesh to features of the surface.Afront uses cubic spline reconstruction kernels to construct the scalar field from a regular grid.The algorithm produces high-quality triangle meshes with bounded Hausdorff error.As occurred with the VTK and Macet implementations, Afront produces consistent surfaces but, as expected, the results do not match the trilinear interpolant.", "rank": 182, "paragraph_comparative_number": 2, "entities": [], "id": "p_182"}, "sentences": [{"end": 76018, "text": "Afront <153> is an advancing-front method for isosurface extraction, remeshing, and triangulation of point sets.", "rank": 613, "start": 75906, "IsComparative": "1", "id": "st_613"}, {"end": 76075, "text": "It works by advancing triangles over an implicit surface.", "rank": 614, "start": 76018, "IsComparative": "0", "id": "st_614"}, {"end": 76189, "text": "A sizing function that takes curvature into account is used to adapt the triangle mesh to features of the surface.", "rank": 615, "start": 76075, "IsComparative": "0", "id": "st_615"}, {"end": 76287, "text": "Afront uses cubic spline reconstruction kernels to construct the scalar field from a regular grid.", "rank": 616, "start": 76189, "IsComparative": "1", "id": "st_616"}, {"end": 76368, "text": "The algorithm produces high-quality triangle meshes with bounded Hausdorff error.", "rank": 617, "start": 76287, "IsComparative": "0", "id": "st_617"}, {"end": 76525, "text": "As occurred with the VTK and Macet implementations, Afront produces consistent surfaces but, as expected, the results do not match the trilinear interpolant.", "rank": 618, "start": 76368, "IsComparative": "0", "id": "st_618"}]}, {"paragraph_info": {"end": 76941, "start": 76525, "text": "Matlab  <103> is a high-level language for building codes that requires intensive nu- merical computation.It has a number of features and among them an isosurface extraction routine for volume data visualization.Unfortunately, Matlab documentation does not offer information on the particularities of the implemented isosurface extraction technique (e.g., Marching Cubes, Delaunay-based, etc; consistent or correct).", "rank": 183, "paragraph_comparative_number": 1, "entities": [], "id": "p_183"}, "sentences": [{"end": 76631, "text": "Matlab  <103> is a high-level language for building codes that requires intensive nu- merical computation.", "rank": 619, "start": 76525, "IsComparative": "1", "id": "st_619"}, {"end": 76737, "text": "It has a number of features and among them an isosurface extraction routine for volume data visualization.", "rank": 620, "start": 76631, "IsComparative": "0", "id": "st_620"}, {"end": 76941, "text": "Unfortunately, Matlab documentation does not offer information on the particularities of the implemented isosurface extraction technique (e.g., Marching Cubes, Delaunay-based, etc; consistent or correct).", "rank": 621, "start": 76737, "IsComparative": "0", "id": "st_621"}]}, {"paragraph_info": {"end": 77397, "start": 76941, "text": "SnapMC <141> is a Marching Cubes variant which produces high-quality triangle meshes from regular grids.The central idea is to extend the original lookup table to account for cases where the isosurface passes exactly through the grid nodes.Specifically, a user-controlled parameter dictates maximum distance for snapping the isosurface into the grid node.The authors report an improvement in the minimum triangle angle when compared to previous techniques.", "rank": 184, "paragraph_comparative_number": 2, "entities": [], "id": "p_184"}, "sentences": [{"end": 77045, "text": "SnapMC <141> is a Marching Cubes variant which produces high-quality triangle meshes from regular grids.", "rank": 622, "start": 76941, "IsComparative": "1", "id": "st_622"}, {"end": 77181, "text": "The central idea is to extend the original lookup table to account for cases where the isosurface passes exactly through the grid nodes.", "rank": 623, "start": 77045, "IsComparative": "0", "id": "st_623"}, {"end": 77296, "text": "Specifically, a user-controlled parameter dictates maximum distance for snapping the isosurface into the grid node.", "rank": 624, "start": 77181, "IsComparative": "1", "id": "st_624"}, {"end": 77397, "text": "The authors report an improvement in the minimum triangle angle when compared to previous techniques.", "rank": 625, "start": 77296, "IsComparative": "0", "id": "st_625"}]}, {"paragraph_info": {"end": 78076, "start": 77397, "text": "MC33 was introduced by Chernyaev <21> to solve ambiguities in the original MC.It extends the Marching Cubes table from 15 to 33 cases to account for ambiguous cases and to reproduce the topology of the trilinear interpolant inside each cube.The original table was later modified to remove two redundant cases, which leads to 31 unique configurations.Chernyaevs MC solves face ambiguity using Nielsen and Hamanns <126> asymptotic decider and internal ambiguity by evaluating the bilinear function over a plane parallel to a face.Additional points may be inserted to reproduce some configuration requiring subvoxel accuracy.We use the implementation provided by Lewiner et al.<94>.", "rank": 185, "paragraph_comparative_number": 4, "entities": [], "id": "p_185"}, "sentences": [{"end": 77475, "text": "MC33 was introduced by Chernyaev <21> to solve ambiguities in the original MC.", "rank": 626, "start": 77397, "IsComparative": "0", "id": "st_626"}, {"end": 77638, "text": "It extends the Marching Cubes table from 15 to 33 cases to account for ambiguous cases and to reproduce the topology of the trilinear interpolant inside each cube.", "rank": 627, "start": 77475, "IsComparative": "1", "id": "st_627"}, {"end": 77747, "text": "The original table was later modified to remove two redundant cases, which leads to 31 unique configurations.", "rank": 628, "start": 77638, "IsComparative": "1", "id": "st_628"}, {"end": 77925, "text": "Chernyaevs MC solves face ambiguity using Nielsen and Hamanns <126> asymptotic decider and internal ambiguity by evaluating the bilinear function over a plane parallel to a face.", "rank": 629, "start": 77747, "IsComparative": "1", "id": "st_629"}, {"end": 78019, "text": "Additional points may be inserted to reproduce some configuration requiring subvoxel accuracy.", "rank": 630, "start": 77925, "IsComparative": "0", "id": "st_630"}, {"end": 78071, "text": "We use the implementation provided by Lewiner et al.", "rank": 631, "start": 78019, "IsComparative": "0", "id": "st_631"}, {"end": 78076, "text": "<94>.", "rank": 632, "start": 78071, "IsComparative": "1", "id": "st_632"}]}, {"paragraph_info": {"end": 78451, "start": 78076, "text": "DelIso <32> is a Delaunay-based approach for isosurface extraction.It uses the inter- section of the 3D Voronoi diagram and the desired surface to define a restricted Delaunay triangulation.Moreover, it builds the restricted Delaunay triangulation without having to compute the whole 3D Voronoi structure.DelIso has theoretical guarantees of homeomor- phism and mesh quality.", "rank": 186, "paragraph_comparative_number": 2, "entities": [], "id": "p_186"}, "sentences": [{"end": 78143, "text": "DelIso <32> is a Delaunay-based approach for isosurface extraction.", "rank": 633, "start": 78076, "IsComparative": "0", "id": "st_633"}, {"end": 78266, "text": "It uses the inter- section of the 3D Voronoi diagram and the desired surface to define a restricted Delaunay triangulation.", "rank": 634, "start": 78143, "IsComparative": "1", "id": "st_634"}, {"end": 78381, "text": "Moreover, it builds the restricted Delaunay triangulation without having to compute the whole 3D Voronoi structure.", "rank": 635, "start": 78266, "IsComparative": "1", "id": "st_635"}, {"end": 78451, "text": "DelIso has theoretical guarantees of homeomor- phism and mesh quality.", "rank": 636, "start": 78381, "IsComparative": "0", "id": "st_636"}]}, {"paragraph_info": {"end": 79120, "start": 78451, "text": "MCFlow is a proof-of-concept implementation of the algorithm described in Schei- degger et al.<151>.It works by successive cube subdivision until it has a simple edge flow.A cube has a simple edge flow if it has only one minima and one maxima.A vertex s  ci is a minimum if all vertices sj  ci connected to it has t(sj) > t(si).Similarly, a vertex is a maximum if t(sj) < t(si) for every neighbor vertex j. This property guarantees that the Marching Cubes method will generate a triangle mesh homeomorphic to the isosurface.After subdivision, the surfaces must be attached back together.The final mesh is topologically correct with respect to the trilinear interpolant.", "rank": 187, "paragraph_comparative_number": 1, "entities": [], "id": "p_187"}, "sentences": [{"end": 78545, "text": "MCFlow is a proof-of-concept implementation of the algorithm described in Schei- degger et al.", "rank": 637, "start": 78451, "IsComparative": "0", "id": "st_637"}, {"end": 78551, "text": "<151>.", "rank": 638, "start": 78545, "IsComparative": "1", "id": "st_638"}, {"end": 78623, "text": "It works by successive cube subdivision until it has a simple edge flow.", "rank": 639, "start": 78551, "IsComparative": "0", "id": "st_639"}, {"end": 78694, "text": "A cube has a simple edge flow if it has only one minima and one maxima.", "rank": 640, "start": 78623, "IsComparative": "0", "id": "st_640"}, {"end": 78779, "text": "A vertex s  ci is a minimum if all vertices sj  ci connected to it has t(sj) > t(si).", "rank": 641, "start": 78694, "IsComparative": "0", "id": "st_641"}, {"end": 78975, "text": "Similarly, a vertex is a maximum if t(sj) < t(si) for every neighbor vertex j. This property guarantees that the Marching Cubes method will generate a triangle mesh homeomorphic to the isosurface.", "rank": 642, "start": 78779, "IsComparative": "0", "id": "st_642"}, {"end": 79038, "text": "After subdivision, the surfaces must be attached back together.", "rank": 643, "start": 78975, "IsComparative": "0", "id": "st_643"}, {"end": 79120, "text": "The final mesh is topologically correct with respect to the trilinear interpolant.", "rank": 644, "start": 79038, "IsComparative": "0", "id": "st_644"}]}, {"paragraph_info": {"end": 79808, "start": 79120, "text": "We believe that the implementation of any of these algorithms in full detail is nontrivial.The results reported in the following section support this statement.They show that coding isosurfacing algorithms is complex and error-prone, and they reinforce the need for robust verification mechanisms.In what follows, we say that a mismatch occurs when invariants computed from a verification procedure disagree with the invariants computed from the isosurfacing technique.A mismatch does not necessarily mean an implementation is incorrect, as we shall see later in this section.After discussions with the developers, however, we did find that there were bugs in some of the implementations.", "rank": 188, "paragraph_comparative_number": 1, "entities": [], "id": "p_188"}, "sentences": [{"end": 79211, "text": "We believe that the implementation of any of these algorithms in full detail is nontrivial.", "rank": 645, "start": 79120, "IsComparative": "0", "id": "st_645"}, {"end": 79280, "text": "The results reported in the following section support this statement.", "rank": 646, "start": 79211, "IsComparative": "0", "id": "st_646"}, {"end": 79417, "text": "They show that coding isosurfacing algorithms is complex and error-prone, and they reinforce the need for robust verification mechanisms.", "rank": 647, "start": 79280, "IsComparative": "1", "id": "st_647"}, {"end": 79589, "text": "In what follows, we say that a mismatch occurs when invariants computed from a verification procedure disagree with the invariants computed from the isosurfacing technique.", "rank": 648, "start": 79417, "IsComparative": "0", "id": "st_648"}, {"end": 79696, "text": "A mismatch does not necessarily mean an implementation is incorrect, as we shall see later in this section.", "rank": 649, "start": 79589, "IsComparative": "0", "id": "st_649"}, {"end": 79808, "text": "After discussions with the developers, however, we did find that there were bugs in some of the implementations.", "rank": 650, "start": 79696, "IsComparative": "0", "id": "st_650"}]}, {"paragraph_info": {"end": 79834, "start": 79808, "text": "3.5.1 Topology Consistency", "rank": 189, "paragraph_comparative_number": 0, "entities": [], "id": "p_189"}, "sentences": [{"end": 79834, "text": "3.5.1 Topology Consistency", "rank": 651, "start": 79808, "IsComparative": "0", "id": "st_651"}]}, {"paragraph_info": {"end": 80100, "start": 79834, "text": "All implementations were subject to the consistency test (Section 3.4.1), resulting in the outputs reported in the first column of Table 3.1.We observed mismatches for DelIso, SnapMC (with nonzero snap value), and Matlab implementations.Now, we detail these results.", "rank": 190, "paragraph_comparative_number": 0, "entities": [], "id": "p_190"}, "sentences": [{"end": 79975, "text": "All implementations were subject to the consistency test (Section 3.4.1), resulting in the outputs reported in the first column of Table 3.1.", "rank": 652, "start": 79834, "IsComparative": "0", "id": "st_652"}, {"end": 80071, "text": "We observed mismatches for DelIso, SnapMC (with nonzero snap value), and Matlab implementations.", "rank": 653, "start": 79975, "IsComparative": "0", "id": "st_653"}, {"end": 80100, "text": "Now, we detail these results.", "rank": 654, "start": 80071, "IsComparative": "0", "id": "st_654"}]}, {"paragraph_info": {"end": 80112, "start": 80100, "text": "3.5.2 DelIso", "rank": 191, "paragraph_comparative_number": 0, "entities": [], "id": "p_191"}, "sentences": [{"end": 80112, "text": "3.5.2 DelIso", "rank": 655, "start": 80100, "IsComparative": "0", "id": "st_655"}]}, {"paragraph_info": {"end": 81405, "start": 80112, "text": "We analyzed 50 cases where DelIsos output mismatched the ground truth produced by MMS, and we found that: 1) 28 cases had incorrect hole(s) in the mesh, 2) 15 cases had missing triangle(s), and 3) 7 cases had duplicated vertices.These cases are illustrated in Figure 3.7.The first problem is possibly due to the nonsmooth nature of the piecewise trilinear interpolant, since in all 28 cases, the holes appeared in the faces of the cubic grid.It is important to recall that DelIso is designed to reproduce the topology of the trilinear interpolant inside each grid cube, but the underlying algorithm requires the isosurface to be C2 continuous everywhere, which does not hold for the piecewise trilinear isosurface.In practice, real-world datasets such as medical images may induce smoother piecewise trilinear fields when compared to the extreme stressing from the random field, which should reduce the incidence of such cases.Missing triangles, however, occurred in the interior of cubic cells where the trilinear surface is smooth.Those problems deserve a deeper analysis, as one cannot say beforehand if the mismatches are caused by problems in the code or numerical instability associated with the initial sampling, ray-surface intersection, and the 3D Delaunay triangulation construction.", "rank": 192, "paragraph_comparative_number": 4, "entities": [], "id": "p_192"}, "sentences": [{"end": 80341, "text": "We analyzed 50 cases where DelIsos output mismatched the ground truth produced by MMS, and we found that: 1) 28 cases had incorrect hole(s) in the mesh, 2) 15 cases had missing triangle(s), and 3) 7 cases had duplicated vertices.", "rank": 656, "start": 80112, "IsComparative": "1", "id": "st_656"}, {"end": 80383, "text": "These cases are illustrated in Figure 3.7.", "rank": 657, "start": 80341, "IsComparative": "0", "id": "st_657"}, {"end": 80554, "text": "The first problem is possibly due to the nonsmooth nature of the piecewise trilinear interpolant, since in all 28 cases, the holes appeared in the faces of the cubic grid.", "rank": 658, "start": 80383, "IsComparative": "1", "id": "st_658"}, {"end": 80826, "text": "It is important to recall that DelIso is designed to reproduce the topology of the trilinear interpolant inside each grid cube, but the underlying algorithm requires the isosurface to be C2 continuous everywhere, which does not hold for the piecewise trilinear isosurface.", "rank": 659, "start": 80554, "IsComparative": "0", "id": "st_659"}, {"end": 81039, "text": "In practice, real-world datasets such as medical images may induce smoother piecewise trilinear fields when compared to the extreme stressing from the random field, which should reduce the incidence of such cases.", "rank": 660, "start": 80826, "IsComparative": "1", "id": "st_660"}, {"end": 81145, "text": "Missing triangles, however, occurred in the interior of cubic cells where the trilinear surface is smooth.", "rank": 661, "start": 81039, "IsComparative": "1", "id": "st_661"}, {"end": 81405, "text": "Those problems deserve a deeper analysis, as one cannot say beforehand if the mismatches are caused by problems in the code or numerical instability associated with the initial sampling, ray-surface intersection, and the 3D Delaunay triangulation construction.", "rank": 662, "start": 81145, "IsComparative": "0", "id": "st_662"}]}, {"paragraph_info": {"end": 81417, "start": 81405, "text": "3.5.3 SnapMC", "rank": 193, "paragraph_comparative_number": 0, "entities": [], "id": "p_193"}, "sentences": [{"end": 81417, "text": "3.5.3 SnapMC", "rank": 663, "start": 81405, "IsComparative": "0", "id": "st_663"}]}, {"paragraph_info": {"end": 82155, "start": 81417, "text": "Table 3.1 shows that SnapMC with nonzero snap value causes the mesh to be topologically inconsistent (Figure 3.8(a)) in more than 50% of the performed tests.The reason for this behavior is in the heart of the technique: the snapping process causes geometrically close vertices to be merged together which may eliminate connected components, or loops, join connected components, or even create nonmanifold surfaces.This is why there was an increase in the number of mismatches when compared with SnapMC with zero snap value.Since nonmanifold meshes are not desirable in many applications, the authors suggest a postprocessing for fixing these topological issues, although no implementation or algorithm for this postprocessing is provided.", "rank": 194, "paragraph_comparative_number": 2, "entities": [], "id": "p_194"}, "sentences": [{"end": 81574, "text": "Table 3.1 shows that SnapMC with nonzero snap value causes the mesh to be topologically inconsistent (Figure 3.8(a)) in more than 50% of the performed tests.", "rank": 664, "start": 81417, "IsComparative": "1", "id": "st_664"}, {"end": 81831, "text": "The reason for this behavior is in the heart of the technique: the snapping process causes geometrically close vertices to be merged together which may eliminate connected components, or loops, join connected components, or even create nonmanifold surfaces.", "rank": 665, "start": 81574, "IsComparative": "1", "id": "st_665"}, {"end": 81940, "text": "This is why there was an increase in the number of mismatches when compared with SnapMC with zero snap value.", "rank": 666, "start": 81831, "IsComparative": "0", "id": "st_666"}, {"end": 82155, "text": "Since nonmanifold meshes are not desirable in many applications, the authors suggest a postprocessing for fixing these topological issues, although no implementation or algorithm for this postprocessing is provided.", "rank": 667, "start": 81940, "IsComparative": "0", "id": "st_667"}]}, {"paragraph_info": {"end": 82167, "start": 82155, "text": "3.5.4 Matlab", "rank": 195, "paragraph_comparative_number": 0, "entities": [], "id": "p_195"}, "sentences": [{"end": 82167, "text": "3.5.4 Matlab", "rank": 668, "start": 82155, "IsComparative": "0", "id": "st_668"}]}, {"paragraph_info": {"end": 82842, "start": 82167, "text": "Matlab documentation does not specify the properties of the implemented isosurface extraction technique.Consequently, it becomes hard to justify the results for the high number of mismatches we see in Table 3.1.For instance, Figure 3.8(b) shows an example of a nonmanifold mesh extracted using Matlab.In that figure, the two highlighted edges have more than two faces connected to them and the faces between these edges are coplanar.Since we do not have enough information to explain this behavior, this might be the actual expected behavior or an unexpected side effect.An advantage of our tests is the record of the observed behavior of mesh topologies generated by Matlab.", "rank": 196, "paragraph_comparative_number": 1, "entities": [], "id": "p_196"}, "sentences": [{"end": 82271, "text": "Matlab documentation does not specify the properties of the implemented isosurface extraction technique.", "rank": 669, "start": 82167, "IsComparative": "0", "id": "st_669"}, {"end": 82378, "text": "Consequently, it becomes hard to justify the results for the high number of mismatches we see in Table 3.1.", "rank": 670, "start": 82271, "IsComparative": "0", "id": "st_670"}, {"end": 82468, "text": "For instance, Figure 3.8(b) shows an example of a nonmanifold mesh extracted using Matlab.", "rank": 671, "start": 82378, "IsComparative": "0", "id": "st_671"}, {"end": 82600, "text": "In that figure, the two highlighted edges have more than two faces connected to them and the faces between these edges are coplanar.", "rank": 672, "start": 82468, "IsComparative": "0", "id": "st_672"}, {"end": 82738, "text": "Since we do not have enough information to explain this behavior, this might be the actual expected behavior or an unexpected side effect.", "rank": 673, "start": 82600, "IsComparative": "0", "id": "st_673"}, {"end": 82842, "text": "An advantage of our tests is the record of the observed behavior of mesh topologies generated by Matlab.", "rank": 674, "start": 82738, "IsComparative": "1", "id": "st_674"}]}, {"paragraph_info": {"end": 82853, "start": 82842, "text": "3.5.5 Macet", "rank": 197, "paragraph_comparative_number": 0, "entities": [], "id": "p_197"}, "sentences": [{"end": 82853, "text": "3.5.5 Macet", "rank": 675, "start": 82842, "IsComparative": "0", "id": "st_675"}]}, {"paragraph_info": {"end": 83171, "start": 82853, "text": "In our first tests, Macet failed in all consistency tests for a 555 grid.An inspection in the code revealed that the layer of cells in the boundary of the grid has not been traversed.Once that bug was fixed, Macet started to produce PL manifold meshes and was successful in the consistency test, as shown in Table 3.1.", "rank": 198, "paragraph_comparative_number": 2, "entities": [], "id": "p_198"}, "sentences": [{"end": 82926, "text": "In our first tests, Macet failed in all consistency tests for a 555 grid.", "rank": 676, "start": 82853, "IsComparative": "1", "id": "st_676"}, {"end": 83036, "text": "An inspection in the code revealed that the layer of cells in the boundary of the grid has not been traversed.", "rank": 677, "start": 82926, "IsComparative": "0", "id": "st_677"}, {"end": 83171, "text": "Once that bug was fixed, Macet started to produce PL manifold meshes and was successful in the consistency test, as shown in Table 3.1.", "rank": 678, "start": 83036, "IsComparative": "1", "id": "st_678"}]}, {"paragraph_info": {"end": 83197, "start": 83171, "text": "3.5.6 Topology Correctness", "rank": 199, "paragraph_comparative_number": 0, "entities": [], "id": "p_199"}, "sentences": [{"end": 83197, "text": "3.5.6 Topology Correctness", "rank": 679, "start": 83171, "IsComparative": "0", "id": "st_679"}]}, {"paragraph_info": {"end": 84284, "start": 83197, "text": "The verification tests described in Section 3.4.2 and 3.4.3 were applied to all algorithms, although only MC33, DelIso, and MCFlow were expected to generate meshes with the same topology of the trilinear interpolant.Our tests consisted of one thousand random fields generated in a rectilinear 5  5  5 grid G.The verification test using Digital Surfaces demanded a compact, orientable, 2-manifold without boundary, so we set scalars to one for grid vertices in the boundary of the grid.As stratified Morse theory supports surfaces with boundary, no special treatment was employed in the boundary of G.We decided to run these tests using all algorithms for completeness and also for testing the tightness of the theory, which says that if the algorithms do not preserve the topology of the trilinear interpolant, a mismatch should occur.Interestingly, with this test, we were able to find another code mistake in Macet that prevented it from terminating safely when the SMT procedure was applied.For all nontopology-preserving algorithms, there was a high number of mismatches as expected.", "rank": 200, "paragraph_comparative_number": 4, "entities": [], "id": "p_200"}, "sentences": [{"end": 83413, "text": "The verification tests described in Section 3.4.2 and 3.4.3 were applied to all algorithms, although only MC33, DelIso, and MCFlow were expected to generate meshes with the same topology of the trilinear interpolant.", "rank": 680, "start": 83197, "IsComparative": "1", "id": "st_680"}, {"end": 83505, "text": "Our tests consisted of one thousand random fields generated in a rectilinear 5  5  5 grid G.", "rank": 681, "start": 83413, "IsComparative": "1", "id": "st_681"}, {"end": 83682, "text": "The verification test using Digital Surfaces demanded a compact, orientable, 2-manifold without boundary, so we set scalars to one for grid vertices in the boundary of the grid.", "rank": 682, "start": 83505, "IsComparative": "0", "id": "st_682"}, {"end": 83797, "text": "As stratified Morse theory supports surfaces with boundary, no special treatment was employed in the boundary of G.", "rank": 683, "start": 83682, "IsComparative": "0", "id": "st_683"}, {"end": 84032, "text": "We decided to run these tests using all algorithms for completeness and also for testing the tightness of the theory, which says that if the algorithms do not preserve the topology of the trilinear interpolant, a mismatch should occur.", "rank": 684, "start": 83797, "IsComparative": "1", "id": "st_684"}, {"end": 84191, "text": "Interestingly, with this test, we were able to find another code mistake in Macet that prevented it from terminating safely when the SMT procedure was applied.", "rank": 685, "start": 84032, "IsComparative": "1", "id": "st_685"}, {"end": 84284, "text": "For all nontopology-preserving algorithms, there was a high number of mismatches as expected.", "rank": 686, "start": 84191, "IsComparative": "0", "id": "st_686"}]}, {"paragraph_info": {"end": 85337, "start": 84284, "text": "One might think that the algorithms described in Algorithms 3 and 4 do not cover all possible topology configurations because some scalar fields are eventually discarded (lines 7 and 6, respectively).This could happen due to the presence of ambiguous cells after refining the input grid to the maximum tolerance (digital topology test) or critical points falling too close to edges/faces of the cubic cells (SMT test).However, we can ensure that all possible configurations for the trilinear interpolation were considered in the tests.Figure 3.9 shows the incidence of each possible configuration (including all ambiguous cases) for the trilinear interpolation in the generated random fields.Dark bars correspond to the number of times a specific case happens in the random field, and the light bars show how many of those cases are accepted by our verification methodology, that is, the random field is not discarded.Notice that no significant differences can be observed, implying that our rejection-sampling method does not bias the case frequencies.", "rank": 201, "paragraph_comparative_number": 4, "entities": [], "id": "p_201"}, "sentences": [{"end": 84484, "text": "One might think that the algorithms described in Algorithms 3 and 4 do not cover all possible topology configurations because some scalar fields are eventually discarded (lines 7 and 6, respectively).", "rank": 687, "start": 84284, "IsComparative": "0", "id": "st_687"}, {"end": 84702, "text": "This could happen due to the presence of ambiguous cells after refining the input grid to the maximum tolerance (digital topology test) or critical points falling too close to edges/faces of the cubic cells (SMT test).", "rank": 688, "start": 84484, "IsComparative": "1", "id": "st_688"}, {"end": 84819, "text": "However, we can ensure that all possible configurations for the trilinear interpolation were considered in the tests.", "rank": 689, "start": 84702, "IsComparative": "0", "id": "st_689"}, {"end": 84976, "text": "Figure 3.9 shows the incidence of each possible configuration (including all ambiguous cases) for the trilinear interpolation in the generated random fields.", "rank": 690, "start": 84819, "IsComparative": "1", "id": "st_690"}, {"end": 85202, "text": "Dark bars correspond to the number of times a specific case happens in the random field, and the light bars show how many of those cases are accepted by our verification methodology, that is, the random field is not discarded.", "rank": 691, "start": 84976, "IsComparative": "1", "id": "st_691"}, {"end": 85337, "text": "Notice that no significant differences can be observed, implying that our rejection-sampling method does not bias the case frequencies.", "rank": 692, "start": 85202, "IsComparative": "1", "id": "st_692"}]}, {"paragraph_info": {"end": 85671, "start": 85337, "text": "DelIso is likely to extract the biggest connected component and, occasionally, it misses small components.It is important to say that the ray-sample based scheme tends to work fine in practical applications where small surfaces are not present.The invariant mismatches for 1 and 2 are computed only if no consistency mismatch happens.", "rank": 202, "paragraph_comparative_number": 1, "entities": [], "id": "p_202"}, "sentences": [{"end": 85443, "text": "DelIso is likely to extract the biggest connected component and, occasionally, it misses small components.", "rank": 693, "start": 85337, "IsComparative": "1", "id": "st_693"}, {"end": 85581, "text": "It is important to say that the ray-sample based scheme tends to work fine in practical applications where small surfaces are not present.", "rank": 694, "start": 85443, "IsComparative": "0", "id": "st_694"}, {"end": 85671, "text": "The invariant mismatches for 1 and 2 are computed only if no consistency mismatch happens.", "rank": 695, "start": 85581, "IsComparative": "0", "id": "st_695"}]}, {"paragraph_info": {"end": 86395, "start": 85671, "text": "For MCFlow, we applied the verification framework systematically during its imple- mentation/development.Obviously, many bugs were uncovered and fixed over the course of its development.Since we are randomizing the piecewise trilinear field, we are likely to cover all possible Marching Cubes entries and also different cube combinations.As verification tests have been applied since the very beginning, all detectable bugs were removed, resulting in no mismatches.The downside of MCFlow, though, is that typical bad quality triangles appearing in Marching Cubes become even worse in MCFlow, because cubes of different sizes are glued together.MCFlow geometrical convergence is presented in the supplementary material <151>.", "rank": 203, "paragraph_comparative_number": 3, "entities": [], "id": "p_203"}, "sentences": [{"end": 85776, "text": "For MCFlow, we applied the verification framework systematically during its imple- mentation/development.", "rank": 696, "start": 85671, "IsComparative": "1", "id": "st_696"}, {"end": 85857, "text": "Obviously, many bugs were uncovered and fixed over the course of its development.", "rank": 697, "start": 85776, "IsComparative": "1", "id": "st_697"}, {"end": 86009, "text": "Since we are randomizing the piecewise trilinear field, we are likely to cover all possible Marching Cubes entries and also different cube combinations.", "rank": 698, "start": 85857, "IsComparative": "1", "id": "st_698"}, {"end": 86136, "text": "As verification tests have been applied since the very beginning, all detectable bugs were removed, resulting in no mismatches.", "rank": 699, "start": 86009, "IsComparative": "0", "id": "st_699"}, {"end": 86315, "text": "The downside of MCFlow, though, is that typical bad quality triangles appearing in Marching Cubes become even worse in MCFlow, because cubes of different sizes are glued together.", "rank": 700, "start": 86136, "IsComparative": "0", "id": "st_700"}, {"end": 86395, "text": "MCFlow geometrical convergence is presented in the supplementary material <151>.", "rank": 701, "start": 86315, "IsComparative": "0", "id": "st_701"}]}, {"paragraph_info": {"end": 86465, "start": 86395, "text": "3.6 Discussion and Limitations 3.6.1 Quality of Manufactured Solutions", "rank": 204, "paragraph_comparative_number": 1, "entities": [], "id": "p_204"}, "sentences": [{"end": 86465, "text": "3.6 Discussion and Limitations 3.6.1 Quality of Manufactured Solutions", "rank": 702, "start": 86395, "IsComparative": "1", "id": "st_702"}]}, {"paragraph_info": {"end": 87464, "start": 86465, "text": "Whenever one uses MMS, one very important question is that of the quality of the manufactured solutions, since it reflects directly on the quality of the verification process.Using random solutions, for which we compute the necessary invariants, naturally seems to yield good results.However, our random solutions will almost always have nonidentical values.This raises the issue of detecting and handling degenerate inputs, such as the ones arising from quantization.We note that most implementations use techniques such as Simulation of Simplicity <37> (for example, by arbitrarily breaking ties using node ordering) to effectively keep the facade of nondegeneracy.However, we note that developing man- ufactured solutions specifically to stress degeneracies is desirable when using verification tools during development.We decided against this since different implementations might employ different strategies to handle degeneracies and our goal was to keep the presentation sufficiently uniform.", "rank": 205, "paragraph_comparative_number": 7, "entities": [], "id": "p_205"}, "sentences": [{"end": 86640, "text": "Whenever one uses MMS, one very important question is that of the quality of the manufactured solutions, since it reflects directly on the quality of the verification process.", "rank": 703, "start": 86465, "IsComparative": "1", "id": "st_703"}, {"end": 86749, "text": "Using random solutions, for which we compute the necessary invariants, naturally seems to yield good results.", "rank": 704, "start": 86640, "IsComparative": "1", "id": "st_704"}, {"end": 86823, "text": "However, our random solutions will almost always have nonidentical values.", "rank": 705, "start": 86749, "IsComparative": "1", "id": "st_705"}, {"end": 86933, "text": "This raises the issue of detecting and handling degenerate inputs, such as the ones arising from quantization.", "rank": 706, "start": 86823, "IsComparative": "1", "id": "st_706"}, {"end": 87132, "text": "We note that most implementations use techniques such as Simulation of Simplicity <37> (for example, by arbitrarily breaking ties using node ordering) to effectively keep the facade of nondegeneracy.", "rank": 707, "start": 86933, "IsComparative": "1", "id": "st_707"}, {"end": 87288, "text": "However, we note that developing man- ufactured solutions specifically to stress degeneracies is desirable when using verification tools during development.", "rank": 708, "start": 87132, "IsComparative": "1", "id": "st_708"}, {"end": 87464, "text": "We decided against this since different implementations might employ different strategies to handle degeneracies and our goal was to keep the presentation sufficiently uniform.", "rank": 709, "start": 87288, "IsComparative": "1", "id": "st_709"}]}, {"paragraph_info": {"end": 87491, "start": 87464, "text": "3.6.2 Topology and Geometry", "rank": 206, "paragraph_comparative_number": 0, "entities": [], "id": "p_206"}, "sentences": [{"end": 87491, "text": "3.6.2 Topology and Geometry", "rank": 710, "start": 87464, "IsComparative": "0", "id": "st_710"}]}, {"paragraph_info": {"end": 87802, "start": 87491, "text": "This work extends the work by Etiene et al.<46> toward including topology in the loop of verification for isosurface techniques.The machinery presented herein combined with the methodology for verifying geometry comprises a solid battery of tests able to stress most of the existing isosurface extraction codes.", "rank": 207, "paragraph_comparative_number": 2, "entities": [], "id": "p_207"}, "sentences": [{"end": 87534, "text": "This work extends the work by Etiene et al.", "rank": 711, "start": 87491, "IsComparative": "0", "id": "st_711"}, {"end": 87619, "text": "<46> toward including topology in the loop of verification for isosurface techniques.", "rank": 712, "start": 87534, "IsComparative": "1", "id": "st_712"}, {"end": 87802, "text": "The machinery presented herein combined with the methodology for verifying geometry comprises a solid battery of tests able to stress most of the existing isosurface extraction codes.", "rank": 713, "start": 87619, "IsComparative": "1", "id": "st_713"}]}, {"paragraph_info": {"end": 88528, "start": 87802, "text": "To illustrate this, we also submitted MC33 and MCFlow techniques to the geometrical test proposed by Etiene, as these codes have not been geometrically verified.While MC33 has geometrical behavior in agreement with Etienes approach, the results presented in Section 3.5 show it does not pass the topological tests.On the other hand, after ensuring that MCFlow was successful regarding topological tests, we submitted it to the geometrical analysis, which revealed problems.Figure 3.8(c) shows an example of an output generated in the early stages of development of MCFlow before (left) and after (right) fixing the bug.The topology matches the expected one (a topological sphere); nevertheless, the geometry does not converge.", "rank": 208, "paragraph_comparative_number": 1, "entities": [], "id": "p_208"}, "sentences": [{"end": 87963, "text": "To illustrate this, we also submitted MC33 and MCFlow techniques to the geometrical test proposed by Etiene, as these codes have not been geometrically verified.", "rank": 714, "start": 87802, "IsComparative": "0", "id": "st_714"}, {"end": 88116, "text": "While MC33 has geometrical behavior in agreement with Etienes approach, the results presented in Section 3.5 show it does not pass the topological tests.", "rank": 715, "start": 87963, "IsComparative": "0", "id": "st_715"}, {"end": 88275, "text": "On the other hand, after ensuring that MCFlow was successful regarding topological tests, we submitted it to the geometrical analysis, which revealed problems.", "rank": 716, "start": 88116, "IsComparative": "1", "id": "st_716"}, {"end": 88421, "text": "Figure 3.8(c) shows an example of an output generated in the early stages of development of MCFlow before (left) and after (right) fixing the bug.", "rank": 717, "start": 88275, "IsComparative": "0", "id": "st_717"}, {"end": 88528, "text": "The topology matches the expected one (a topological sphere); nevertheless, the geometry does not converge.", "rank": 718, "start": 88421, "IsComparative": "0", "id": "st_718"}]}, {"paragraph_info": {"end": 88543, "start": 88528, "text": "3.6.3 SMT vs.DT", "rank": 209, "paragraph_comparative_number": 1, "entities": [], "id": "p_209"}, "sentences": [{"end": 88541, "text": "3.6.3 SMT vs.", "rank": 719, "start": 88528, "IsComparative": "0", "id": "st_719"}, {"end": 88543, "text": "DT", "rank": 720, "start": 88541, "IsComparative": "1", "id": "st_720"}]}, {"paragraph_info": {"end": 89903, "start": 88543, "text": "The verification approach using digital surfaces generates detailed information about the expected topology because it provides 0, 1, and 2.However, verifying isosurfaces with boundaries would require additional theoretical results, as the theory supporting our verification algorithm is only valid for surfaces without boundary.In contrast, the verification methodology using stratified Morse theory can handle surfaces with boundary.However, SMT only provides information about the Euler characteristic, making it harder to determine when the topological verification process fails.Another issue with SMT is that if a code incorrectly introduces topological features so as to preserve , then no failure will be detected.For example, suppose the surface to be reconstructed is a torus, but the code produces a torus plus three triangles, each one sharing two vertices with the other triangles but not an edge.In this case, torus plus three cycling triangles also has  = 0, exactly the Euler characteristic of the single torus.In that case, notice that the digital surface-based test would be able to detect the spurious three triangles by comparing 0.Despite being less sensitive in theory, SMT-based verification revealed similar problems as the digital topology tests have.We believe this effectiveness comes in part from the randomized nature of our tests.", "rank": 210, "paragraph_comparative_number": 6, "entities": [], "id": "p_210"}, "sentences": [{"end": 88683, "text": "The verification approach using digital surfaces generates detailed information about the expected topology because it provides 0, 1, and 2.", "rank": 721, "start": 88543, "IsComparative": "0", "id": "st_721"}, {"end": 88872, "text": "However, verifying isosurfaces with boundaries would require additional theoretical results, as the theory supporting our verification algorithm is only valid for surfaces without boundary.", "rank": 722, "start": 88683, "IsComparative": "0", "id": "st_722"}, {"end": 88978, "text": "In contrast, the verification methodology using stratified Morse theory can handle surfaces with boundary.", "rank": 723, "start": 88872, "IsComparative": "0", "id": "st_723"}, {"end": 89127, "text": "However, SMT only provides information about the Euler characteristic, making it harder to determine when the topological verification process fails.", "rank": 724, "start": 88978, "IsComparative": "1", "id": "st_724"}, {"end": 89265, "text": "Another issue with SMT is that if a code incorrectly introduces topological features so as to preserve , then no failure will be detected.", "rank": 725, "start": 89127, "IsComparative": "1", "id": "st_725"}, {"end": 89453, "text": "For example, suppose the surface to be reconstructed is a torus, but the code produces a torus plus three triangles, each one sharing two vertices with the other triangles but not an edge.", "rank": 726, "start": 89265, "IsComparative": "1", "id": "st_726"}, {"end": 89570, "text": "In this case, torus plus three cycling triangles also has  = 0, exactly the Euler characteristic of the single torus.", "rank": 727, "start": 89453, "IsComparative": "0", "id": "st_727"}, {"end": 89695, "text": "In that case, notice that the digital surface-based test would be able to detect the spurious three triangles by comparing 0.", "rank": 728, "start": 89570, "IsComparative": "1", "id": "st_728"}, {"end": 89819, "text": "Despite being less sensitive in theory, SMT-based verification revealed similar problems as the digital topology tests have.", "rank": 729, "start": 89695, "IsComparative": "1", "id": "st_729"}, {"end": 89903, "text": "We believe this effectiveness comes in part from the randomized nature of our tests.", "rank": 730, "start": 89819, "IsComparative": "1", "id": "st_730"}]}, {"paragraph_info": {"end": 89937, "start": 89903, "text": "3.6.4 Implementation of SMT and DT", "rank": 211, "paragraph_comparative_number": 0, "entities": [], "id": "p_211"}, "sentences": [{"end": 89937, "text": "3.6.4 Implementation of SMT and DT", "rank": 731, "start": 89903, "IsComparative": "0", "id": "st_731"}]}, {"paragraph_info": {"end": 90817, "start": 89937, "text": "Verification tools should be as simple as possible while still revealing unexpected behav- ior.The pipeline for geometric convergence is straightforward and thus much less error- prone.This is mostly because the approach of Etiene et al.uses analytical manufactured solutions to provide information about function value, gradients, area, and curvature.In topology, on the other hand, we can manufacture only simple analytical solutions (e.g., a sphere, torus, double-torus, etc.)for which we know topological invariants.There are no guarantees that these solutions will cover all cases of a trilinear interpolant inside a cube.For this reason, we employ a random manufactured solution and must then compute explicitly the topological invariants.A point which naturally arises in verification settings is that the verification code is another program.How do we verify the verifier?", "rank": 212, "paragraph_comparative_number": 3, "entities": [], "id": "p_212"}, "sentences": [{"end": 90032, "text": "Verification tools should be as simple as possible while still revealing unexpected behav- ior.", "rank": 732, "start": 89937, "IsComparative": "0", "id": "st_732"}, {"end": 90122, "text": "The pipeline for geometric convergence is straightforward and thus much less error- prone.", "rank": 733, "start": 90032, "IsComparative": "0", "id": "st_733"}, {"end": 90174, "text": "This is mostly because the approach of Etiene et al.", "rank": 734, "start": 90122, "IsComparative": "1", "id": "st_734"}, {"end": 90289, "text": "uses analytical manufactured solutions to provide information about function value, gradients, area, and curvature.", "rank": 735, "start": 90174, "IsComparative": "1", "id": "st_735"}, {"end": 90416, "text": "In topology, on the other hand, we can manufacture only simple analytical solutions (e.g., a sphere, torus, double-torus, etc.)", "rank": 736, "start": 90289, "IsComparative": "0", "id": "st_736"}, {"end": 90457, "text": "for which we know topological invariants.", "rank": 737, "start": 90416, "IsComparative": "1", "id": "st_737"}, {"end": 90564, "text": "There are no guarantees that these solutions will cover all cases of a trilinear interpolant inside a cube.", "rank": 738, "start": 90457, "IsComparative": "0", "id": "st_738"}, {"end": 90682, "text": "For this reason, we employ a random manufactured solution and must then compute explicitly the topological invariants.", "rank": 739, "start": 90564, "IsComparative": "0", "id": "st_739"}, {"end": 90787, "text": "A point which naturally arises in verification settings is that the verification code is another program.", "rank": 740, "start": 90682, "IsComparative": "0", "id": "st_740"}, {"end": 90817, "text": "How do we verify the verifier?", "rank": 741, "start": 90787, "IsComparative": "0", "id": "st_741"}]}, {"paragraph_info": {"end": 91755, "start": 90817, "text": "First, note that the implementation of either verifier is simpler than the isosurfacing techniques under scrutiny.This reduces the chances of a bug impacting the original verification.In addition, we can use the same strategy to check if the verification tools are implemented correctly.For SMT, one may compute  for an isovalue that is greater than any other in the grid.In such case, the verification tool should result in  = 0.For DT, we can use the fact that Majority Interpolation always produces a 2-manifold.Fortunately, this test reduces to check for two invalid cube configurations, as described by Stelldinger et al.<164>.Obviously, there might remain bugs in the verification code.As we have stated before, a mismatch between the expected invariants and the computed ones indicates a problem somewhere in the pipeline; our experiments are empirical evidence of the techniques effectiveness in detecting implementation problems.", "rank": 213, "paragraph_comparative_number": 4, "entities": [], "id": "p_213"}, "sentences": [{"end": 90931, "text": "First, note that the implementation of either verifier is simpler than the isosurfacing techniques under scrutiny.", "rank": 742, "start": 90817, "IsComparative": "0", "id": "st_742"}, {"end": 91001, "text": "This reduces the chances of a bug impacting the original verification.", "rank": 743, "start": 90931, "IsComparative": "0", "id": "st_743"}, {"end": 91104, "text": "In addition, we can use the same strategy to check if the verification tools are implemented correctly.", "rank": 744, "start": 91001, "IsComparative": "1", "id": "st_744"}, {"end": 91189, "text": "For SMT, one may compute  for an isovalue that is greater than any other in the grid.", "rank": 745, "start": 91104, "IsComparative": "0", "id": "st_745"}, {"end": 91247, "text": "In such case, the verification tool should result in  = 0.", "rank": 746, "start": 91189, "IsComparative": "0", "id": "st_746"}, {"end": 91332, "text": "For DT, we can use the fact that Majority Interpolation always produces a 2-manifold.", "rank": 747, "start": 91247, "IsComparative": "0", "id": "st_747"}, {"end": 91443, "text": "Fortunately, this test reduces to check for two invalid cube configurations, as described by Stelldinger et al.", "rank": 748, "start": 91332, "IsComparative": "1", "id": "st_748"}, {"end": 91449, "text": "<164>.", "rank": 749, "start": 91443, "IsComparative": "1", "id": "st_749"}, {"end": 91509, "text": "Obviously, there might remain bugs in the verification code.", "rank": 750, "start": 91449, "IsComparative": "0", "id": "st_750"}, {"end": 91755, "text": "As we have stated before, a mismatch between the expected invariants and the computed ones indicates a problem somewhere in the pipeline; our experiments are empirical evidence of the techniques effectiveness in detecting implementation problems.", "rank": 751, "start": 91509, "IsComparative": "1", "id": "st_751"}]}, {"paragraph_info": {"end": 92493, "start": 91755, "text": "Another concern is the performance of the verification tools.In our experiments, the invariant computation via SMT and DS is faster than any isosurface extraction presented in this work, for most of the random grids.In some scenarios, DS might experience a slowdown because it refines the grid in order to eliminate ambiguous cubes (the maximum number of refinement is set to 4).Thus, both SMT and DS (after grid refinement) need to perform a constant number of operations for each grid cube to determine the digital surface (DS) or critical points (SMT).In this particular context, we highlight the recent developments on certifying algorithms, which produce both the output and an efficiently checkable certificate of correctness <107>.", "rank": 214, "paragraph_comparative_number": 5, "entities": [], "id": "p_214"}, "sentences": [{"end": 91816, "text": "Another concern is the performance of the verification tools.", "rank": 752, "start": 91755, "IsComparative": "1", "id": "st_752"}, {"end": 91971, "text": "In our experiments, the invariant computation via SMT and DS is faster than any isosurface extraction presented in this work, for most of the random grids.", "rank": 753, "start": 91816, "IsComparative": "1", "id": "st_753"}, {"end": 92134, "text": "In some scenarios, DS might experience a slowdown because it refines the grid in order to eliminate ambiguous cubes (the maximum number of refinement is set to 4).", "rank": 754, "start": 91971, "IsComparative": "1", "id": "st_754"}, {"end": 92310, "text": "Thus, both SMT and DS (after grid refinement) need to perform a constant number of operations for each grid cube to determine the digital surface (DS) or critical points (SMT).", "rank": 755, "start": 92134, "IsComparative": "1", "id": "st_755"}, {"end": 92493, "text": "In this particular context, we highlight the recent developments on certifying algorithms, which produce both the output and an efficiently checkable certificate of correctness <107>.", "rank": 756, "start": 92310, "IsComparative": "1", "id": "st_756"}]}, {"paragraph_info": {"end": 92512, "start": 92493, "text": "3.6.5 Contour Trees", "rank": 215, "paragraph_comparative_number": 0, "entities": [], "id": "p_215"}, "sentences": [{"end": 92512, "text": "3.6.5 Contour Trees", "rank": 757, "start": 92493, "IsComparative": "0", "id": "st_757"}]}, {"paragraph_info": {"end": 94255, "start": 92512, "text": "Contour trees <18> are powerful structures to describe the evolution of level-sets of simply connected domains.It normally assumes a simplicial complex as input, but there are extensions to handle regular grids <130>.Contour trees naturally provide 0, and they can be extended to report 1 and 2.Hence, for any isovalue, we have information about all Betti numbers, even for surfaces with boundaries.This fact renders contour trees a good candidate for verification purposes.In fact, if an implementation is available, we encourage its use so as to increase confidence in the algorithms behavior.However, the implementation of a contour tree is more complicated than the techniques presented here.For regular-grids, a divide-and-conquer approach can be used along with oracles representing the split and join trees in the deepest level of the recursion, which is nontrivial.Also, implementing the merging of the two trees to obtain the final contour tree is still involving and error- prone.Our approach, on the other hand, is based on regular grid refinement and voxel selection for the DT method and critical point computation and classification for the SMT method.There are other tools, including contour trees, that could be used to assess topology correctness of isosurface extraction algorithms, and an interesting experiment would be to compare the number of mismatches found by each of these tools.Nevertheless, in this work, we have focused on the approaches using SMT and DT because of their simplicity and effectiveness in finding code mistakes in publicly available implementations.We believe that the simpler methodologies we have presented here are more likely to be adopted during development of visualization isosurfacing tools.", "rank": 216, "paragraph_comparative_number": 7, "entities": [], "id": "p_216"}, "sentences": [{"end": 92623, "text": "Contour trees <18> are powerful structures to describe the evolution of level-sets of simply connected domains.", "rank": 758, "start": 92512, "IsComparative": "1", "id": "st_758"}, {"end": 92729, "text": "It normally assumes a simplicial complex as input, but there are extensions to handle regular grids <130>.", "rank": 759, "start": 92623, "IsComparative": "1", "id": "st_759"}, {"end": 92807, "text": "Contour trees naturally provide 0, and they can be extended to report 1 and 2.", "rank": 760, "start": 92729, "IsComparative": "1", "id": "st_760"}, {"end": 92911, "text": "Hence, for any isovalue, we have information about all Betti numbers, even for surfaces with boundaries.", "rank": 761, "start": 92807, "IsComparative": "0", "id": "st_761"}, {"end": 92986, "text": "This fact renders contour trees a good candidate for verification purposes.", "rank": 762, "start": 92911, "IsComparative": "1", "id": "st_762"}, {"end": 93107, "text": "In fact, if an implementation is available, we encourage its use so as to increase confidence in the algorithms behavior.", "rank": 763, "start": 92986, "IsComparative": "1", "id": "st_763"}, {"end": 93208, "text": "However, the implementation of a contour tree is more complicated than the techniques presented here.", "rank": 764, "start": 93107, "IsComparative": "0", "id": "st_764"}, {"end": 93385, "text": "For regular-grids, a divide-and-conquer approach can be used along with oracles representing the split and join trees in the deepest level of the recursion, which is nontrivial.", "rank": 765, "start": 93208, "IsComparative": "0", "id": "st_765"}, {"end": 93502, "text": "Also, implementing the merging of the two trees to obtain the final contour tree is still involving and error- prone.", "rank": 766, "start": 93385, "IsComparative": "1", "id": "st_766"}, {"end": 93678, "text": "Our approach, on the other hand, is based on regular grid refinement and voxel selection for the DT method and critical point computation and classification for the SMT method.", "rank": 767, "start": 93502, "IsComparative": "0", "id": "st_767"}, {"end": 93917, "text": "There are other tools, including contour trees, that could be used to assess topology correctness of isosurface extraction algorithms, and an interesting experiment would be to compare the number of mismatches found by each of these tools.", "rank": 768, "start": 93678, "IsComparative": "0", "id": "st_768"}, {"end": 94105, "text": "Nevertheless, in this work, we have focused on the approaches using SMT and DT because of their simplicity and effectiveness in finding code mistakes in publicly available implementations.", "rank": 769, "start": 93917, "IsComparative": "1", "id": "st_769"}, {"end": 94255, "text": "We believe that the simpler methodologies we have presented here are more likely to be adopted during development of visualization isosurfacing tools.", "rank": 770, "start": 94105, "IsComparative": "0", "id": "st_770"}]}, {"paragraph_info": {"end": 94294, "start": 94255, "text": "3.6.6 Topology of the Underlying Object", "rank": 217, "paragraph_comparative_number": 0, "entities": [], "id": "p_217"}, "sentences": [{"end": 94294, "text": "3.6.6 Topology of the Underlying Object", "rank": 771, "start": 94255, "IsComparative": "0", "id": "st_771"}]}, {"paragraph_info": {"end": 95877, "start": 94294, "text": "In this work, we are interested in how to effectively verify topological properties of codes which employ trilinear interpolation.In particular, this means that our verification tools will work for implementations other than marching methods (for example, DelIso is based on Delaunay refinement).Nevertheless, in practice, the original scalar field will not be trilinear, and algorithms which assume a trilinearly interpolated scalar field might not provide any topological guarantee regarding the reconstructed object.Consider, for example, a piecewise linear curve  built by walking through diagonals of adjacent cubes ci  G and define the distance field d(x) = min<||xx||such that x  >.The isosurface d(x) =  for any  > 0 is a single tube around .However, none of the implementations tested could successfully reproduce the tubular structure for all  > 0.This is not particularly surprising, since the trilinear interpolation from samples of d is quite different from the d. Figure 3.11 shows a typical output produced by VTK Marching Cubes for the distance field d = .Notice, however, that this is not only an issue of sampling rate because if the tube keeps going through the diagonals of cubic cells, VTK will not be able reproduce d =  yet.Also recall that some structures cannot even be reproduced by trilinear interpolants, as when  crosses diagonals of two parallel faces of a cubic cell, as described in <21, 130>.The aspects above are not errors in the codes but reflect software design choices that should be clearly expressed to users of those visualization techniques.", "rank": 218, "paragraph_comparative_number": 3, "entities": [], "id": "p_218"}, "sentences": [{"end": 94424, "text": "In this work, we are interested in how to effectively verify topological properties of codes which employ trilinear interpolation.", "rank": 772, "start": 94294, "IsComparative": "0", "id": "st_772"}, {"end": 94590, "text": "In particular, this means that our verification tools will work for implementations other than marching methods (for example, DelIso is based on Delaunay refinement).", "rank": 773, "start": 94424, "IsComparative": "1", "id": "st_773"}, {"end": 94813, "text": "Nevertheless, in practice, the original scalar field will not be trilinear, and algorithms which assume a trilinearly interpolated scalar field might not provide any topological guarantee regarding the reconstructed object.", "rank": 774, "start": 94590, "IsComparative": "0", "id": "st_774"}, {"end": 94983, "text": "Consider, for example, a piecewise linear curve  built by walking through diagonals of adjacent cubes ci  G and define the distance field d(x) = min<||xx||such that x  >.", "rank": 775, "start": 94813, "IsComparative": "0", "id": "st_775"}, {"end": 95044, "text": "The isosurface d(x) =  for any  > 0 is a single tube around .", "rank": 776, "start": 94983, "IsComparative": "0", "id": "st_776"}, {"end": 95152, "text": "However, none of the implementations tested could successfully reproduce the tubular structure for all  > 0.", "rank": 777, "start": 95044, "IsComparative": "1", "id": "st_777"}, {"end": 95366, "text": "This is not particularly surprising, since the trilinear interpolation from samples of d is quite different from the d. Figure 3.11 shows a typical output produced by VTK Marching Cubes for the distance field d = .", "rank": 778, "start": 95152, "IsComparative": "0", "id": "st_778"}, {"end": 95541, "text": "Notice, however, that this is not only an issue of sampling rate because if the tube keeps going through the diagonals of cubic cells, VTK will not be able reproduce d =  yet.", "rank": 779, "start": 95366, "IsComparative": "0", "id": "st_779"}, {"end": 95719, "text": "Also recall that some structures cannot even be reproduced by trilinear interpolants, as when  crosses diagonals of two parallel faces of a cubic cell, as described in <21, 130>.", "rank": 780, "start": 95541, "IsComparative": "0", "id": "st_780"}, {"end": 95877, "text": "The aspects above are not errors in the codes but reflect software design choices that should be clearly expressed to users of those visualization techniques.", "rank": 781, "start": 95719, "IsComparative": "1", "id": "st_781"}]}, {"paragraph_info": {"end": 95894, "start": 95877, "text": "3.6.7 Limitations", "rank": 219, "paragraph_comparative_number": 0, "entities": [], "id": "p_219"}, "sentences": [{"end": 95894, "text": "3.6.7 Limitations", "rank": 782, "start": 95877, "IsComparative": "0", "id": "st_782"}]}, {"paragraph_info": {"end": 96234, "start": 95894, "text": "The theoretical guarantees supporting our manufactured solution rely on the trilinear interpolant.If an interpolant other than trilinear is employed, then new results ensuring homeomorphism (Theorem 3.3.1) should be derived.The basic infrastructure we have described here, however, should be appropriate as a starting point for the process.", "rank": 220, "paragraph_comparative_number": 1, "entities": [], "id": "p_220"}, "sentences": [{"end": 95992, "text": "The theoretical guarantees supporting our manufactured solution rely on the trilinear interpolant.", "rank": 783, "start": 95894, "IsComparative": "1", "id": "st_783"}, {"end": 96118, "text": "If an interpolant other than trilinear is employed, then new results ensuring homeomorphism (Theorem 3.3.1) should be derived.", "rank": 784, "start": 95992, "IsComparative": "0", "id": "st_784"}, {"end": 96234, "text": "The basic infrastructure we have described here, however, should be appropriate as a starting point for the process.", "rank": 785, "start": 96118, "IsComparative": "0", "id": "st_785"}]}, {"paragraph_info": {"end": 96248, "start": 96234, "text": "3.7 Conclusion", "rank": 221, "paragraph_comparative_number": 0, "entities": [], "id": "p_221"}, "sentences": [{"end": 96248, "text": "3.7 Conclusion", "rank": 786, "start": 96234, "IsComparative": "0", "id": "st_786"}]}, {"paragraph_info": {"end": 97128, "start": 96248, "text": "In this chapter, we extended the framework presented in the previous chapter by in- cluding topology into the verification cycle.We used machinery from digital topology and stratified Morse theory to derive two verification tools that are simple and yet capable of finding unexpected behavior and coding mistakes.We argue that researchers and de- velopers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.Topological properties are as important as geometric ones, and they deserve the same amount of attention.It is telling that the only algorithm that passed all verification tests proposed here is the one that used the verification procedures during its development.We believe this happened because topological properties are particularly subtle and require an unusually large amount of care.", "rank": 222, "paragraph_comparative_number": 4, "entities": [], "id": "p_222"}, "sentences": [{"end": 96377, "text": "In this chapter, we extended the framework presented in the previous chapter by in- cluding topology into the verification cycle.", "rank": 787, "start": 96248, "IsComparative": "0", "id": "st_787"}, {"end": 96561, "text": "We used machinery from digital topology and stratified Morse theory to derive two verification tools that are simple and yet capable of finding unexpected behavior and coding mistakes.", "rank": 788, "start": 96377, "IsComparative": "1", "id": "st_788"}, {"end": 96738, "text": "We argue that researchers and de- velopers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.", "rank": 789, "start": 96561, "IsComparative": "1", "id": "st_789"}, {"end": 96843, "text": "Topological properties are as important as geometric ones, and they deserve the same amount of attention.", "rank": 790, "start": 96738, "IsComparative": "0", "id": "st_790"}, {"end": 97002, "text": "It is telling that the only algorithm that passed all verification tests proposed here is the one that used the verification procedures during its development.", "rank": 791, "start": 96843, "IsComparative": "1", "id": "st_791"}, {"end": 97128, "text": "We believe this happened because topological properties are particularly subtle and require an unusually large amount of care.", "rank": 792, "start": 97002, "IsComparative": "1", "id": "st_792"}]}, {"paragraph_info": {"end": 97214, "start": 97128, "text": "CHAPTER 4 PRACTICAL CONSIDERATIONS ON THE TOPOLOGICAL CORRECTNESS OF MARCHING CUBES 33", "rank": 223, "paragraph_comparative_number": 0, "entities": [], "id": "p_223"}, "sentences": [{"end": 97214, "text": "CHAPTER 4 PRACTICAL CONSIDERATIONS ON THE TOPOLOGICAL CORRECTNESS OF MARCHING CUBES 33", "rank": 793, "start": 97128, "IsComparative": "0", "id": "st_793"}]}, {"paragraph_info": {"end": 97902, "start": 97214, "text": "Isosurface extraction techniques can be divided into two classes according to their topo- logical guarantees, namely, consistency or correctness.Topologically consistent techniques produce surfaces that are piecewise-linear (PL) manifolds (i.e., crack-free surfaces), except at the boundary of the domain.Topologically correct techniques produce a PL-manifold homeomorphic to the surface induced by a given interpolant, such as the trilinear inter- polant.Although there are many topologically consistent MC-based techniques, only a handful are topologically correct.Marching Cubes 33 is one of the first MC-based algorithms that aim to preserve the topology of the trilinear interpolant.", "rank": 224, "paragraph_comparative_number": 2, "entities": [], "id": "p_224"}, "sentences": [{"end": 97359, "text": "Isosurface extraction techniques can be divided into two classes according to their topo- logical guarantees, namely, consistency or correctness.", "rank": 794, "start": 97214, "IsComparative": "1", "id": "st_794"}, {"end": 97519, "text": "Topologically consistent techniques produce surfaces that are piecewise-linear (PL) manifolds (i.e., crack-free surfaces), except at the boundary of the domain.", "rank": 795, "start": 97359, "IsComparative": "1", "id": "st_795"}, {"end": 97670, "text": "Topologically correct techniques produce a PL-manifold homeomorphic to the surface induced by a given interpolant, such as the trilinear inter- polant.", "rank": 796, "start": 97519, "IsComparative": "0", "id": "st_796"}, {"end": 97781, "text": "Although there are many topologically consistent MC-based techniques, only a handful are topologically correct.", "rank": 797, "start": 97670, "IsComparative": "0", "id": "st_797"}, {"end": 97902, "text": "Marching Cubes 33 is one of the first MC-based algorithms that aim to preserve the topology of the trilinear interpolant.", "rank": 798, "start": 97781, "IsComparative": "0", "id": "st_798"}]}, {"paragraph_info": {"end": 99181, "start": 97902, "text": "Topological correctness increases the complexity of isosurface extraction algorithms.The many isosurface configurations possible for a given interpolant in a cubic grid makes both the algorithm and its implementation a challenging task.As algorithms and implementations become more complex, issues may be overlooked and remain hidden in the multitude of (pseudo-) lines of code.Throughout years of research, it has been shown that some supposedly topologically correct techniques, including MC33, have issues that prevent correctness <45, 98, 124>.In particular, the work of Etiene et al.<45> shows that the MC33 implementation by Lewiner et al.<93, 94> fails to produce topologically correct isosurfaces.Alas, the authors do not provide an explanation for the problem source, let alone fix the problem.They only provide cases that are mishandled by MC33 and a conjecture regarding the root of one of the observed flaws.As we studied the MC33 implementation, we realized that the source of the problem was not merely implementation bugs but the core ideas behind the implemented algorithm.In this work, we address issues with Chernyaevs original algorithm, its extension, and its implementation.Our work closes an existing gap in the topological correctness of Marching Cubes 33.", "rank": 225, "paragraph_comparative_number": 6, "entities": [], "id": "p_225"}, "sentences": [{"end": 97987, "text": "Topological correctness increases the complexity of isosurface extraction algorithms.", "rank": 799, "start": 97902, "IsComparative": "0", "id": "st_799"}, {"end": 98138, "text": "The many isosurface configurations possible for a given interpolant in a cubic grid makes both the algorithm and its implementation a challenging task.", "rank": 800, "start": 97987, "IsComparative": "1", "id": "st_800"}, {"end": 98280, "text": "As algorithms and implementations become more complex, issues may be overlooked and remain hidden in the multitude of (pseudo-) lines of code.", "rank": 801, "start": 98138, "IsComparative": "0", "id": "st_801"}, {"end": 98450, "text": "Throughout years of research, it has been shown that some supposedly topologically correct techniques, including MC33, have issues that prevent correctness <45, 98, 124>.", "rank": 802, "start": 98280, "IsComparative": "0", "id": "st_802"}, {"end": 98490, "text": "In particular, the work of Etiene et al.", "rank": 803, "start": 98450, "IsComparative": "0", "id": "st_803"}, {"end": 98547, "text": "<45> shows that the MC33 implementation by Lewiner et al.", "rank": 804, "start": 98490, "IsComparative": "1", "id": "st_804"}, {"end": 98607, "text": "<93, 94> fails to produce topologically correct isosurfaces.", "rank": 805, "start": 98547, "IsComparative": "1", "id": "st_805"}, {"end": 98705, "text": "Alas, the authors do not provide an explanation for the problem source, let alone fix the problem.", "rank": 806, "start": 98607, "IsComparative": "0", "id": "st_806"}, {"end": 98822, "text": "They only provide cases that are mishandled by MC33 and a conjecture regarding the root of one of the observed flaws.", "rank": 807, "start": 98705, "IsComparative": "0", "id": "st_807"}, {"end": 98991, "text": "As we studied the MC33 implementation, we realized that the source of the problem was not merely implementation bugs but the core ideas behind the implemented algorithm.", "rank": 808, "start": 98822, "IsComparative": "1", "id": "st_808"}, {"end": 99097, "text": "In this work, we address issues with Chernyaevs original algorithm, its extension, and its implementation.", "rank": 809, "start": 98991, "IsComparative": "1", "id": "st_809"}, {"end": 99181, "text": "Our work closes an existing gap in the topological correctness of Marching Cubes 33.", "rank": 810, "start": 99097, "IsComparative": "1", "id": "st_810"}]}, {"paragraph_info": {"end": 99897, "start": 99181, "text": "The subtleties involved in the correctness of isosurface extraction techniques are some- times difficult to grasp in the ordinary paper medium.Both the geometry and topology inside grid voxels are often complex and challenging to understand, study and replicate (e.g., see Figures 9 and 10 in <125>).As an attempt to bridge this gap, we build on recent efforts towards executable papers <82, 172>.Executable papers extend the traditional paper/digital counterpart by including tools that allow readers to interact, explore, and verify experiments more easily.In this chapter, we use executable papers to increase the reproducibility of our results.Our contributions, which have a practical nature, are the following:", "rank": 226, "paragraph_comparative_number": 5, "entities": [], "id": "p_226"}, "sentences": [{"end": 99324, "text": "The subtleties involved in the correctness of isosurface extraction techniques are some- times difficult to grasp in the ordinary paper medium.", "rank": 811, "start": 99181, "IsComparative": "1", "id": "st_811"}, {"end": 99481, "text": "Both the geometry and topology inside grid voxels are often complex and challenging to understand, study and replicate (e.g., see Figures 9 and 10 in <125>).", "rank": 812, "start": 99324, "IsComparative": "1", "id": "st_812"}, {"end": 99578, "text": "As an attempt to bridge this gap, we build on recent efforts towards executable papers <82, 172>.", "rank": 813, "start": 99481, "IsComparative": "0", "id": "st_813"}, {"end": 99740, "text": "Executable papers extend the traditional paper/digital counterpart by including tools that allow readers to interact, explore, and verify experiments more easily.", "rank": 814, "start": 99578, "IsComparative": "1", "id": "st_814"}, {"end": 99829, "text": "In this chapter, we use executable papers to increase the reproducibility of our results.", "rank": 815, "start": 99740, "IsComparative": "1", "id": "st_815"}, {"end": 99897, "text": "Our contributions, which have a practical nature, are the following:", "rank": 816, "start": 99829, "IsComparative": "1", "id": "st_816"}]}, {"paragraph_info": {"end": 100198, "start": 99897, "text": "We explain and address three algorithmic issues and one nontrivial implementation issue with Marching Cubes 33.In particular, we solve an issue with the core MC33 disambiguation procedure that, as far as we know, has not been addressed elsewhere.Hence, we close an existing gap in the MC33 literature.", "rank": 227, "paragraph_comparative_number": 1, "entities": [], "id": "p_227"}, "sentences": [{"end": 100008, "text": "We explain and address three algorithmic issues and one nontrivial implementation issue with Marching Cubes 33.", "rank": 817, "start": 99897, "IsComparative": "1", "id": "st_817"}, {"end": 100143, "text": "In particular, we solve an issue with the core MC33 disambiguation procedure that, as far as we know, has not been addressed elsewhere.", "rank": 818, "start": 100008, "IsComparative": "0", "id": "st_818"}, {"end": 100198, "text": "Hence, we close an existing gap in the MC33 literature.", "rank": 819, "start": 100143, "IsComparative": "0", "id": "st_819"}]}, {"paragraph_info": {"end": 100368, "start": 100198, "text": "We make our results reproducible.CrowdLabs <172> and Vistrails <49> are used to create an executable paper that can reproduce the results shown in the following sections.", "rank": 228, "paragraph_comparative_number": 2, "entities": [], "id": "p_228"}, "sentences": [{"end": 100231, "text": "We make our results reproducible.", "rank": 820, "start": 100198, "IsComparative": "1", "id": "st_820"}, {"end": 100368, "text": "CrowdLabs <172> and Vistrails <49> are used to create an executable paper that can reproduce the results shown in the following sections.", "rank": 821, "start": 100231, "IsComparative": "1", "id": "st_821"}]}, {"paragraph_info": {"end": 100492, "start": 100368, "text": "We provide datasets that can be used to verify the correctness of any topologically correct isosurface extraction technique.", "rank": 229, "paragraph_comparative_number": 0, "entities": [], "id": "p_229"}, "sentences": [{"end": 100492, "text": "We provide datasets that can be used to verify the correctness of any topologically correct isosurface extraction technique.", "rank": 822, "start": 100368, "IsComparative": "0", "id": "st_822"}]}, {"paragraph_info": {"end": 100858, "start": 100492, "text": "A by-product of this work is a thorough analysis of both the MC33 algorithm and its implementation that can be used by anyone interested in the use or development of correct isosurface extraction algorithms based on MC33.The results of our efforts are materialized into an extended version of the MC33 implementation <93>, henceforth called Corrected- MC33 (C-MC33).", "rank": 230, "paragraph_comparative_number": 2, "entities": [], "id": "p_230"}, "sentences": [{"end": 100713, "text": "A by-product of this work is a thorough analysis of both the MC33 algorithm and its implementation that can be used by anyone interested in the use or development of correct isosurface extraction algorithms based on MC33.", "rank": 823, "start": 100492, "IsComparative": "1", "id": "st_823"}, {"end": 100858, "text": "The results of our efforts are materialized into an extended version of the MC33 implementation <93>, henceforth called Corrected- MC33 (C-MC33).", "rank": 824, "start": 100713, "IsComparative": "1", "id": "st_824"}]}, {"paragraph_info": {"end": 101304, "start": 100858, "text": "This work is organized as follows.Section 4.2 reviews key aspects related to the Marching Cubes 33 algorithm.Section 4.3 explains how experiments that uncovered problems in both MC33 algorithm and implementation were conducted.The details of the problems found are shown in Section 4.4 and the solutions are presented in Section 4.5.Section 4.6 shows the results of applying algorithm with different topological guarantees to real-world datasets.", "rank": 231, "paragraph_comparative_number": 2, "entities": [], "id": "p_231"}, "sentences": [{"end": 100892, "text": "This work is organized as follows.", "rank": 825, "start": 100858, "IsComparative": "0", "id": "st_825"}, {"end": 100967, "text": "Section 4.2 reviews key aspects related to the Marching Cubes 33 algorithm.", "rank": 826, "start": 100892, "IsComparative": "1", "id": "st_826"}, {"end": 101085, "text": "Section 4.3 explains how experiments that uncovered problems in both MC33 algorithm and implementation were conducted.", "rank": 827, "start": 100967, "IsComparative": "0", "id": "st_827"}, {"end": 101191, "text": "The details of the problems found are shown in Section 4.4 and the solutions are presented in Section 4.5.", "rank": 828, "start": 101085, "IsComparative": "0", "id": "st_828"}, {"end": 101304, "text": "Section 4.6 shows the results of applying algorithm with different topological guarantees to real-world datasets.", "rank": 829, "start": 101191, "IsComparative": "1", "id": "st_829"}]}, {"paragraph_info": {"end": 101320, "start": 101304, "text": "4.1 Related Work", "rank": 232, "paragraph_comparative_number": 0, "entities": [], "id": "p_232"}, "sentences": [{"end": 101320, "text": "4.1 Related Work", "rank": 830, "start": 101304, "IsComparative": "0", "id": "st_830"}]}, {"paragraph_info": {"end": 101870, "start": 101320, "text": "Soon after the publication of the MC algorithm, the quest for a topologically correct isosurface extraction technique began.A number of approaches were proposed for dealing with cracks, face ambiguity, and, lastly, interior ambiguity.Du rst <35> was the first to point out that some MC cases allow multiple triangulations.A consequence of this is that MC does not always generate topologically consistent surfaces.This problem arises due to the ambiguity problem; the Asymptotic Decider <126> provides a simple and elegant solution to face ambiguity.", "rank": 233, "paragraph_comparative_number": 1, "entities": [], "id": "p_233"}, "sentences": [{"end": 101444, "text": "Soon after the publication of the MC algorithm, the quest for a topologically correct isosurface extraction technique began.", "rank": 831, "start": 101320, "IsComparative": "0", "id": "st_831"}, {"end": 101554, "text": "A number of approaches were proposed for dealing with cracks, face ambiguity, and, lastly, interior ambiguity.", "rank": 832, "start": 101444, "IsComparative": "0", "id": "st_832"}, {"end": 101642, "text": "Du rst <35> was the first to point out that some MC cases allow multiple triangulations.", "rank": 833, "start": 101554, "IsComparative": "1", "id": "st_833"}, {"end": 101734, "text": "A consequence of this is that MC does not always generate topologically consistent surfaces.", "rank": 834, "start": 101642, "IsComparative": "0", "id": "st_834"}, {"end": 101870, "text": "This problem arises due to the ambiguity problem; the Asymptotic Decider <126> provides a simple and elegant solution to face ambiguity.", "rank": 835, "start": 101734, "IsComparative": "0", "id": "st_835"}]}, {"paragraph_info": {"end": 102398, "start": 101870, "text": "The ambiguity problem also occurs in the interior of a voxel.Natarajan <122> was the first to address this problem by adding four new cases to the standard MC triangulation table (subcases of cases 3, 4, 6, and 7).To find the correct subcases, the author proposed a disambiguation procedure based on both face and interior critical points.Nevertheless, the method misses the possibility of two interior critical points in case 7; consequently, the proposed algorithm may generate a surface with the incorrect topology <15, 124>.", "rank": 234, "paragraph_comparative_number": 1, "entities": [], "id": "p_234"}, "sentences": [{"end": 101931, "text": "The ambiguity problem also occurs in the interior of a voxel.", "rank": 836, "start": 101870, "IsComparative": "0", "id": "st_836"}, {"end": 102084, "text": "Natarajan <122> was the first to address this problem by adding four new cases to the standard MC triangulation table (subcases of cases 3, 4, 6, and 7).", "rank": 837, "start": 101931, "IsComparative": "1", "id": "st_837"}, {"end": 102209, "text": "To find the correct subcases, the author proposed a disambiguation procedure based on both face and interior critical points.", "rank": 838, "start": 102084, "IsComparative": "0", "id": "st_838"}, {"end": 102398, "text": "Nevertheless, the method misses the possibility of two interior critical points in case 7; consequently, the proposed algorithm may generate a surface with the incorrect topology <15, 124>.", "rank": 839, "start": 102209, "IsComparative": "0", "id": "st_839"}]}, {"paragraph_info": {"end": 103083, "start": 102398, "text": "Using a different approach, Chernyaev <21> extended the original MC table to 33 cases  hence MC33; this extension included all the subcases for each ambiguous case.He used the Asymptotic Decider and a new interior ambiguity test to discriminate among subcases.Lewiner et al.<94> provided a practical open-source implementation of the Chernyaev algorithm.It is worth noting that some of the configurations shown in Chernyaevs work <21> may have been inspired by personal communication with Nielson <125>.Matveyev <105> introduced an isosurface technique that is also based on an extended table and used the intersections of isosurfaces with cube diagonals to determine the correct case.", "rank": 235, "paragraph_comparative_number": 3, "entities": [], "id": "p_235"}, "sentences": [{"end": 102562, "text": "Using a different approach, Chernyaev <21> extended the original MC table to 33 cases  hence MC33; this extension included all the subcases for each ambiguous case.", "rank": 840, "start": 102398, "IsComparative": "1", "id": "st_840"}, {"end": 102658, "text": "He used the Asymptotic Decider and a new interior ambiguity test to discriminate among subcases.", "rank": 841, "start": 102562, "IsComparative": "1", "id": "st_841"}, {"end": 102672, "text": "Lewiner et al.", "rank": 842, "start": 102658, "IsComparative": "0", "id": "st_842"}, {"end": 102752, "text": "<94> provided a practical open-source implementation of the Chernyaev algorithm.", "rank": 843, "start": 102672, "IsComparative": "1", "id": "st_843"}, {"end": 102901, "text": "It is worth noting that some of the configurations shown in Chernyaevs work <21> may have been inspired by personal communication with Nielson <125>.", "rank": 844, "start": 102752, "IsComparative": "0", "id": "st_844"}, {"end": 103083, "text": "Matveyev <105> introduced an isosurface technique that is also based on an extended table and used the intersections of isosurfaces with cube diagonals to determine the correct case.", "rank": 845, "start": 102901, "IsComparative": "0", "id": "st_845"}]}, {"paragraph_info": {"end": 103866, "start": 103083, "text": "Lopes and Brodlie <98> extended the tests proposed by Natarajan.The goals of the work are threefold: i) extract topologically correct isosurfaces; ii) produce geometrically accurate isosurface; iii) allow continuity with respect to changes in threshold and data.Nevertheless, as in Natarajans work, the method missed the possibility of two interior critical points in case 7 <98>.Cignoni et al.<23> also used the test proposed by Natarajan to reconstruct topologically correct isosurfaces.The work of Theisel <168> uses B ezier patches to build G1 continuous isosurfaces that are topologically correct.Nielson <125> lists all possible cases of a trilinear interpolant inside a cubic grid and builds a topologically correct MC using a three stage algorithm for surface polygonization.", "rank": 236, "paragraph_comparative_number": 2, "entities": [], "id": "p_236"}, "sentences": [{"end": 103147, "text": "Lopes and Brodlie <98> extended the tests proposed by Natarajan.", "rank": 846, "start": 103083, "IsComparative": "0", "id": "st_846"}, {"end": 103345, "text": "The goals of the work are threefold: i) extract topologically correct isosurfaces; ii) produce geometrically accurate isosurface; iii) allow continuity with respect to changes in threshold and data.", "rank": 847, "start": 103147, "IsComparative": "0", "id": "st_847"}, {"end": 103463, "text": "Nevertheless, as in Natarajans work, the method missed the possibility of two interior critical points in case 7 <98>.", "rank": 848, "start": 103345, "IsComparative": "0", "id": "st_848"}, {"end": 103477, "text": "Cignoni et al.", "rank": 849, "start": 103463, "IsComparative": "0", "id": "st_849"}, {"end": 103572, "text": "<23> also used the test proposed by Natarajan to reconstruct topologically correct isosurfaces.", "rank": 850, "start": 103477, "IsComparative": "0", "id": "st_850"}, {"end": 103685, "text": "The work of Theisel <168> uses B ezier patches to build G1 continuous isosurfaces that are topologically correct.", "rank": 851, "start": 103572, "IsComparative": "1", "id": "st_851"}, {"end": 103866, "text": "Nielson <125> lists all possible cases of a trilinear interpolant inside a cubic grid and builds a topologically correct MC using a three stage algorithm for surface polygonization.", "rank": 852, "start": 103685, "IsComparative": "1", "id": "st_852"}]}, {"paragraph_info": {"end": 105035, "start": 103866, "text": "The past two decades have also produced a number of isosurface techniques that are not MC-based.Dual Contouring <73> (DC) is a robust, crack-free, isosurface extraction technique that works on the dual grid.Several improvements over Dual Contouring have been proposed: Schaefer et al.<149> address the issue of nonmanifold surfaces generated by DC; Varadhan et al.<182> combine a signed distance field with DC to reconstruct details such as thin features; and Zhang et al.<193> use DC for topology-preserving simplification of isosurfaces.Note that none of these techniques are intended to preserve the topology of the trilinear interpolant.Dey and Levine <32> presented an algorithm that computes a Delaunay triangulation based on the intersection between the isosurface and the 3D Voronoi diagram.Another paradigm for isosurface extraction is the advancing front method.Advancing front algorithms build a triangulated surface by progressively adding triangles to an implicit surface <59>, possibly creating several fronts that are simultaneously advanced one triangle at a time.A number of extensions have been proposed for advancing front techniques <153, 154, 159>.", "rank": 237, "paragraph_comparative_number": 5, "entities": [], "id": "p_237"}, "sentences": [{"end": 103962, "text": "The past two decades have also produced a number of isosurface techniques that are not MC-based.", "rank": 853, "start": 103866, "IsComparative": "1", "id": "st_853"}, {"end": 104073, "text": "Dual Contouring <73> (DC) is a robust, crack-free, isosurface extraction technique that works on the dual grid.", "rank": 854, "start": 103962, "IsComparative": "1", "id": "st_854"}, {"end": 104150, "text": "Several improvements over Dual Contouring have been proposed: Schaefer et al.", "rank": 855, "start": 104073, "IsComparative": "0", "id": "st_855"}, {"end": 104230, "text": "<149> address the issue of nonmanifold surfaces generated by DC; Varadhan et al.", "rank": 856, "start": 104150, "IsComparative": "0", "id": "st_856"}, {"end": 104338, "text": "<182> combine a signed distance field with DC to reconstruct details such as thin features; and Zhang et al.", "rank": 857, "start": 104230, "IsComparative": "1", "id": "st_857"}, {"end": 104405, "text": "<193> use DC for topology-preserving simplification of isosurfaces.", "rank": 858, "start": 104338, "IsComparative": "1", "id": "st_858"}, {"end": 104507, "text": "Note that none of these techniques are intended to preserve the topology of the trilinear interpolant.", "rank": 859, "start": 104405, "IsComparative": "0", "id": "st_859"}, {"end": 104665, "text": "Dey and Levine <32> presented an algorithm that computes a Delaunay triangulation based on the intersection between the isosurface and the 3D Voronoi diagram.", "rank": 860, "start": 104507, "IsComparative": "0", "id": "st_860"}, {"end": 104738, "text": "Another paradigm for isosurface extraction is the advancing front method.", "rank": 861, "start": 104665, "IsComparative": "0", "id": "st_861"}, {"end": 104946, "text": "Advancing front algorithms build a triangulated surface by progressively adding triangles to an implicit surface <59>, possibly creating several fronts that are simultaneously advanced one triangle at a time.", "rank": 862, "start": 104738, "IsComparative": "1", "id": "st_862"}, {"end": 105035, "text": "A number of extensions have been proposed for advancing front techniques <153, 154, 159>.", "rank": 863, "start": 104946, "IsComparative": "0", "id": "st_863"}]}, {"paragraph_info": {"end": 106199, "start": 105035, "text": "In the following sections, we focus on MC33.Note that, although many of the algorithms presented previously are topologically consistent, only a handful of them are topologically correct <21, 32>.Also, the implementation of a topologically correct isosurface extraction algorithm is nontrivial.Hence, once the algorithm is implemented, topological guarantees, both consistency and correctness, may be lost because of algorithm or implementation issues, as shown in the work of Etiene et al.<45>.Although it has been ten years since the publication of MC33, we believe it is important to correct a mistake in the algorithm that has gone unnoticed since Chernyaev published it almost 20 years ago.In this work, we aim to close an existing gap in the MC33 literature.Furthermore, we aim not only to provide a correct algorithm but verify that our modified implementation is faithful to the correct algorithm.We explain the issues and propose solutions for both algorithm and implementation.We note that MC33 may refer to either the Marching Cubes 33 algorithm presented in Chernyaevs work <21> or its implementation, as in Lewiner et al.<94> depending on the context.", "rank": 238, "paragraph_comparative_number": 5, "entities": [], "id": "p_238"}, "sentences": [{"end": 105079, "text": "In the following sections, we focus on MC33.", "rank": 864, "start": 105035, "IsComparative": "0", "id": "st_864"}, {"end": 105231, "text": "Note that, although many of the algorithms presented previously are topologically consistent, only a handful of them are topologically correct <21, 32>.", "rank": 865, "start": 105079, "IsComparative": "0", "id": "st_865"}, {"end": 105329, "text": "Also, the implementation of a topologically correct isosurface extraction algorithm is nontrivial.", "rank": 866, "start": 105231, "IsComparative": "0", "id": "st_866"}, {"end": 105525, "text": "Hence, once the algorithm is implemented, topological guarantees, both consistency and correctness, may be lost because of algorithm or implementation issues, as shown in the work of Etiene et al.", "rank": 867, "start": 105329, "IsComparative": "1", "id": "st_867"}, {"end": 105530, "text": "<45>.", "rank": 868, "start": 105525, "IsComparative": "1", "id": "st_868"}, {"end": 105730, "text": "Although it has been ten years since the publication of MC33, we believe it is important to correct a mistake in the algorithm that has gone unnoticed since Chernyaev published it almost 20 years ago.", "rank": 869, "start": 105530, "IsComparative": "1", "id": "st_869"}, {"end": 105799, "text": "In this work, we aim to close an existing gap in the MC33 literature.", "rank": 870, "start": 105730, "IsComparative": "0", "id": "st_870"}, {"end": 105940, "text": "Furthermore, we aim not only to provide a correct algorithm but verify that our modified implementation is faithful to the correct algorithm.", "rank": 871, "start": 105799, "IsComparative": "1", "id": "st_871"}, {"end": 106022, "text": "We explain the issues and propose solutions for both algorithm and implementation.", "rank": 872, "start": 105940, "IsComparative": "0", "id": "st_872"}, {"end": 106169, "text": "We note that MC33 may refer to either the Marching Cubes 33 algorithm presented in Chernyaevs work <21> or its implementation, as in Lewiner et al.", "rank": 873, "start": 106022, "IsComparative": "1", "id": "st_873"}, {"end": 106199, "text": "<94> depending on the context.", "rank": 874, "start": 106169, "IsComparative": "0", "id": "st_874"}]}, {"paragraph_info": {"end": 106216, "start": 106199, "text": "4.2 Preliminaries", "rank": 239, "paragraph_comparative_number": 0, "entities": [], "id": "p_239"}, "sentences": [{"end": 106216, "text": "4.2 Preliminaries", "rank": 875, "start": 106199, "IsComparative": "0", "id": "st_875"}]}, {"paragraph_info": {"end": 106763, "start": 106216, "text": "In this section, we present the notation that will be used throughout this chapter.We also briefly review the main concepts behind Chernyaevs algorithm and the implementation of Lewiner et al.. Let G be a rectilinear grid with scalar values associated with each vertex xj  G. Let g : R3  R be a piecewise-trilinear interpolation function defined on G.Given an isovalue , the isosurface S is defined as the set of points for which g(x) = .For each voxel vi  G, and x  vi, g(x) = gi(x) where gi is the trilinear interpolant inside the cubic cell vi.", "rank": 240, "paragraph_comparative_number": 0, "entities": [], "id": "p_240"}, "sentences": [{"end": 106299, "text": "In this section, we present the notation that will be used throughout this chapter.", "rank": 876, "start": 106216, "IsComparative": "0", "id": "st_876"}, {"end": 106567, "text": "We also briefly review the main concepts behind Chernyaevs algorithm and the implementation of Lewiner et al.. Let G be a rectilinear grid with scalar values associated with each vertex xj  G. Let g : R3  R be a piecewise-trilinear interpolation function defined on G.", "rank": 877, "start": 106299, "IsComparative": "0", "id": "st_877"}, {"end": 106654, "text": "Given an isovalue , the isosurface S is defined as the set of points for which g(x) = .", "rank": 878, "start": 106567, "IsComparative": "0", "id": "st_878"}, {"end": 106763, "text": "For each voxel vi  G, and x  vi, g(x) = gi(x) where gi is the trilinear interpolant inside the cubic cell vi.", "rank": 879, "start": 106654, "IsComparative": "0", "id": "st_879"}]}, {"paragraph_info": {"end": 107069, "start": 106763, "text": "The output of MC-based algorithms is a piecewise-linear mesh M, and we say that an algorithm and its implementation are topologically correct if M is homeomorphic to S. Without loss of generality, we assume that  = 0, and thus S = S0 = S.We say that a point x is positive (negative) if g(x) > 0 (g(x) < 0).", "rank": 241, "paragraph_comparative_number": 1, "entities": [], "id": "p_241"}, "sentences": [{"end": 107001, "text": "The output of MC-based algorithms is a piecewise-linear mesh M, and we say that an algorithm and its implementation are topologically correct if M is homeomorphic to S. Without loss of generality, we assume that  = 0, and thus S = S0 = S.", "rank": 880, "start": 106763, "IsComparative": "1", "id": "st_880"}, {"end": 107069, "text": "We say that a point x is positive (negative) if g(x) > 0 (g(x) < 0).", "rank": 881, "start": 107001, "IsComparative": "0", "id": "st_881"}]}, {"paragraph_info": {"end": 107400, "start": 107069, "text": "Given a voxel vi, and a cutting-plane P parallel to one of vis faces, define fi : R2  R as the bilinear interpolant along P. Note that fi(x) = gi(x) for x  P. Throughout the text, we deal with a single voxel v; thus, we omit the subscript i. We also assume that v and P are defined in the domains <0, 1>3 and <0, 1>2, respectively.", "rank": 242, "paragraph_comparative_number": 0, "entities": [], "id": "p_242"}, "sentences": [{"end": 107400, "text": "Given a voxel vi, and a cutting-plane P parallel to one of vis faces, define fi : R2  R as the bilinear interpolant along P. Note that fi(x) = gi(x) for x  P. Throughout the text, we deal with a single voxel v; thus, we omit the subscript i. We also assume that v and P are defined in the domains <0, 1>3 and <0, 1>2, respectively.", "rank": 882, "start": 107069, "IsComparative": "0", "id": "st_882"}]}, {"paragraph_info": {"end": 107421, "start": 107400, "text": "4.2.1 Chernyaevs MC33", "rank": 243, "paragraph_comparative_number": 0, "entities": [], "id": "p_243"}, "sentences": [{"end": 107421, "text": "4.2.1 Chernyaevs MC33", "rank": 883, "start": 107400, "IsComparative": "0", "id": "st_883"}]}, {"paragraph_info": {"end": 108223, "start": 107421, "text": "The two pillars of Marching Cubes 33s topological correctness are Nielson and Hamanns Asymptotic Decider and Chernyaevs interior ambiguities test; together these solve the face ambiguity and interior ambiguity problems in the Marching Cubes 33 algorithm.A face ambiguity occurs when face vertices have alternating signs.That is, one face diagonal is positive (both vertices are positive) and the other is negative (both vertices are negative).In this case, the signs of the face vertices are insufficient to determine the correct way to triangulate the isosurface.Similarly, an interior ambiguity occurs when the signs of the cube vertices are insufficient to determine the correct surface triangulation, i.e., when multiple triangulations are possible for the same cube configuration (see Figure 4.1).", "rank": 244, "paragraph_comparative_number": 1, "entities": [], "id": "p_244"}, "sentences": [{"end": 107675, "text": "The two pillars of Marching Cubes 33s topological correctness are Nielson and Hamanns Asymptotic Decider and Chernyaevs interior ambiguities test; together these solve the face ambiguity and interior ambiguity problems in the Marching Cubes 33 algorithm.", "rank": 884, "start": 107421, "IsComparative": "1", "id": "st_884"}, {"end": 107741, "text": "A face ambiguity occurs when face vertices have alternating signs.", "rank": 885, "start": 107675, "IsComparative": "0", "id": "st_885"}, {"end": 107864, "text": "That is, one face diagonal is positive (both vertices are positive) and the other is negative (both vertices are negative).", "rank": 886, "start": 107741, "IsComparative": "0", "id": "st_886"}, {"end": 107985, "text": "In this case, the signs of the face vertices are insufficient to determine the correct way to triangulate the isosurface.", "rank": 887, "start": 107864, "IsComparative": "0", "id": "st_887"}, {"end": 108223, "text": "Similarly, an interior ambiguity occurs when the signs of the cube vertices are insufficient to determine the correct surface triangulation, i.e., when multiple triangulations are possible for the same cube configuration (see Figure 4.1).", "rank": 888, "start": 107985, "IsComparative": "0", "id": "st_888"}]}, {"paragraph_info": {"end": 108785, "start": 108223, "text": "The idea behind the Asymptotic Decider is to verify the face saddle sign and compare it to the sign on the face vertices.A positive saddle means that the positive face vertices are connected; consequently, the positive face vertices are separated if the face saddle point is negative (see Figure 4.2).To compute the face saddle sign, the saddle point position xc must be computed <21>: where A, B, C, and D are the scalar values at the face vertices (see Figure 4.2).The sign of xc can easily be checked by replacing Equation (4.1) into the bilinear interpolant:", "rank": 245, "paragraph_comparative_number": 1, "entities": [], "id": "p_245"}, "sentences": [{"end": 108344, "text": "The idea behind the Asymptotic Decider is to verify the face saddle sign and compare it to the sign on the face vertices.", "rank": 889, "start": 108223, "IsComparative": "1", "id": "st_889"}, {"end": 108524, "text": "A positive saddle means that the positive face vertices are connected; consequently, the positive face vertices are separated if the face saddle point is negative (see Figure 4.2).", "rank": 890, "start": 108344, "IsComparative": "0", "id": "st_890"}, {"end": 108690, "text": "To compute the face saddle sign, the saddle point position xc must be computed <21>: where A, B, C, and D are the scalar values at the face vertices (see Figure 4.2).", "rank": 891, "start": 108524, "IsComparative": "0", "id": "st_891"}, {"end": 108785, "text": "The sign of xc can easily be checked by replacing Equation (4.1) into the bilinear interpolant:", "rank": 892, "start": 108690, "IsComparative": "0", "id": "st_892"}]}, {"paragraph_info": {"end": 109011, "start": 108785, "text": "For an ambiguous face, assuming A, C positive and B and D negative, the denominator of the Equation (4.2) is always positive (see Figure 4.2).Then, the face ambiguity is solved by evaluating the sign of the numerator of f(xc).", "rank": 246, "paragraph_comparative_number": 0, "entities": [], "id": "p_246"}, "sentences": [{"end": 108927, "text": "For an ambiguous face, assuming A, C positive and B and D negative, the denominator of the Equation (4.2) is always positive (see Figure 4.2).", "rank": 893, "start": 108785, "IsComparative": "0", "id": "st_893"}, {"end": 109011, "text": "Then, the face ambiguity is solved by evaluating the sign of the numerator of f(xc).", "rank": 894, "start": 108927, "IsComparative": "0", "id": "st_894"}]}, {"paragraph_info": {"end": 109332, "start": 109011, "text": "Due to the interior ambiguity, the Asymptotic Decider alone cannot solve the topological correctness problem.Chernyaev uses the idea behind the Asymptotic Decider to solve the interior ambiguity problem.The proposed test uses a sweeping cutting-plane to evaluate the behavior of the trilinear interpolant inside the cube.", "rank": 247, "paragraph_comparative_number": 0, "entities": [], "id": "p_247"}, "sentences": [{"end": 109120, "text": "Due to the interior ambiguity, the Asymptotic Decider alone cannot solve the topological correctness problem.", "rank": 895, "start": 109011, "IsComparative": "0", "id": "st_895"}, {"end": 109214, "text": "Chernyaev uses the idea behind the Asymptotic Decider to solve the interior ambiguity problem.", "rank": 896, "start": 109120, "IsComparative": "0", "id": "st_896"}, {"end": 109332, "text": "The proposed test uses a sweeping cutting-plane to evaluate the behavior of the trilinear interpolant inside the cube.", "rank": 897, "start": 109214, "IsComparative": "0", "id": "st_897"}]}, {"paragraph_info": {"end": 110066, "start": 109332, "text": "Given a cube with an ambiguous configuration, define the scalar values at the base and top planes as A0, B0, C0, D0, and A1, B1, C1, D1, respectively (see Figure 4.2).Let A0 and C1, the vertices to be tested, be positive.Observe that, although A0 and C1 belong to opposite cube faces, they can be connected through the cube interior.In other words, there may exist a path from A0 to C1 passing through the voxel interior for which all points belonging to that path are positive.To determine whether A0 and C1 are connected, Chernyaev begins by observing that the saddle points at the top and base cube faces are negative, i.e., Equation (4.2) is negative at the bottom and top faces.Since the denominator is positive, it follows that:", "rank": 248, "paragraph_comparative_number": 1, "entities": [], "id": "p_248"}, "sentences": [{"end": 109499, "text": "Given a cube with an ambiguous configuration, define the scalar values at the base and top planes as A0, B0, C0, D0, and A1, B1, C1, D1, respectively (see Figure 4.2).", "rank": 898, "start": 109332, "IsComparative": "0", "id": "st_898"}, {"end": 109553, "text": "Let A0 and C1, the vertices to be tested, be positive.", "rank": 899, "start": 109499, "IsComparative": "0", "id": "st_899"}, {"end": 109665, "text": "Observe that, although A0 and C1 belong to opposite cube faces, they can be connected through the cube interior.", "rank": 900, "start": 109553, "IsComparative": "0", "id": "st_900"}, {"end": 109810, "text": "In other words, there may exist a path from A0 to C1 passing through the voxel interior for which all points belonging to that path are positive.", "rank": 901, "start": 109665, "IsComparative": "1", "id": "st_901"}, {"end": 110015, "text": "To determine whether A0 and C1 are connected, Chernyaev begins by observing that the saddle points at the top and base cube faces are negative, i.e., Equation (4.2) is negative at the bottom and top faces.", "rank": 902, "start": 109810, "IsComparative": "0", "id": "st_902"}, {"end": 110066, "text": "Since the denominator is positive, it follows that:", "rank": 903, "start": 110015, "IsComparative": "0", "id": "st_903"}]}, {"paragraph_info": {"end": 110336, "start": 110066, "text": "Then, if there is a plane cutting the cube such that its saddle point is positive, it means that there is a positive area crossing the cube, i.e., the positive vertices are connected inside the cube.In other words, the Chernyaev interior test searches for a t for which:", "rank": 249, "paragraph_comparative_number": 1, "entities": [], "id": "p_249"}, "sentences": [{"end": 110265, "text": "Then, if there is a plane cutting the cube such that its saddle point is positive, it means that there is a positive area crossing the cube, i.e., the positive vertices are connected inside the cube.", "rank": 904, "start": 110066, "IsComparative": "0", "id": "st_904"}, {"end": 110336, "text": "In other words, the Chernyaev interior test searches for a t for which:", "rank": 905, "start": 110265, "IsComparative": "1", "id": "st_905"}]}, {"paragraph_info": {"end": 110519, "start": 110336, "text": "This can be achieved by solving a second order equation in t. Replacing Xt = X0 + (X1  X0)t, X  <A, B, C, D> and t  <0, 1> in Equation (4.5), one obtains a second order equation in t:", "rank": 250, "paragraph_comparative_number": 0, "entities": [], "id": "p_250"}, "sentences": [{"end": 110519, "text": "This can be achieved by solving a second order equation in t. Replacing Xt = X0 + (X1  X0)t, X  <A, B, C, D> and t  <0, 1> in Equation (4.5), one obtains a second order equation in t:", "rank": 906, "start": 110336, "IsComparative": "0", "id": "st_906"}]}, {"paragraph_info": {"end": 110559, "start": 110519, "text": "F(t) = AtCt BtDt (4.6) = at2+bt+c, (4.7)", "rank": 251, "paragraph_comparative_number": 0, "entities": [], "id": "p_251"}, "sentences": [{"end": 110559, "text": "F(t) = AtCt BtDt (4.6) = at2+bt+c, (4.7)", "rank": 907, "start": 110519, "IsComparative": "0", "id": "st_907"}]}, {"paragraph_info": {"end": 110900, "start": 110559, "text": "where a, b, and c are functions of A,B,C, and D (see Appendix A).Chernyaev concludes that positive vertices A0 and C1 are connected through the cube interior if: of the test proposed by Chernyaev, but condition (i) is not used, and condition (ii) is always true because e is an edge intersected by the isosurface; consequently, talt  (0, 1).", "rank": 252, "paragraph_comparative_number": 0, "entities": [], "id": "p_252"}, "sentences": [{"end": 110624, "text": "where a, b, and c are functions of A,B,C, and D (see Appendix A).", "rank": 908, "start": 110559, "IsComparative": "0", "id": "st_908"}, {"end": 110900, "text": "Chernyaev concludes that positive vertices A0 and C1 are connected through the cube interior if: of the test proposed by Chernyaev, but condition (i) is not used, and condition (ii) is always true because e is an edge intersected by the isosurface; consequently, talt  (0, 1).", "rank": 909, "start": 110624, "IsComparative": "0", "id": "st_909"}]}, {"paragraph_info": {"end": 111317, "start": 110900, "text": "Section 4.4 explains why the algorithm proposed by Chernyaev and its modified version proposed by Lewiner et al.may fail to extract surfaces that are topologically correct.In the following section, we present the tools we use to detect, debug, and reproduce the issues found in the MC33 algorithm and its implementation.The full Marching Cubes table can be found in the works of Chernyaev <21> and Lewiner et al.<94>.", "rank": 253, "paragraph_comparative_number": 5, "entities": [], "id": "p_253"}, "sentences": [{"end": 111012, "text": "Section 4.4 explains why the algorithm proposed by Chernyaev and its modified version proposed by Lewiner et al.", "rank": 910, "start": 110900, "IsComparative": "1", "id": "st_910"}, {"end": 111072, "text": "may fail to extract surfaces that are topologically correct.", "rank": 911, "start": 111012, "IsComparative": "1", "id": "st_911"}, {"end": 111220, "text": "In the following section, we present the tools we use to detect, debug, and reproduce the issues found in the MC33 algorithm and its implementation.", "rank": 912, "start": 111072, "IsComparative": "1", "id": "st_912"}, {"end": 111312, "text": "The full Marching Cubes table can be found in the works of Chernyaev <21> and Lewiner et al.", "rank": 913, "start": 111220, "IsComparative": "1", "id": "st_913"}, {"end": 111317, "text": "<94>.", "rank": 914, "start": 111312, "IsComparative": "1", "id": "st_914"}]}, {"paragraph_info": {"end": 111338, "start": 111317, "text": "4.3 Experiments Setup", "rank": 254, "paragraph_comparative_number": 1, "entities": [], "id": "p_254"}, "sentences": [{"end": 111338, "text": "4.3 Experiments Setup", "rank": 915, "start": 111317, "IsComparative": "1", "id": "st_915"}]}, {"paragraph_info": {"end": 112714, "start": 111338, "text": "We begin by investigating the source of topological problems in the MC33 implemen- tation <45>.The topological issues described were obtained by systematically stress-testing the implementation over many topological configurations using the verification framework proposed in Etiene et al.<45>.These authors algorithm can be summarized as follows.(I) A random scalar field G is built by uniformly sampling scalar values in the range <1, 1> for each xj  G.(II) The expected topological invariants are obtained directly from S, i.e., without extracting the isosurface of interest.The topological invariants used are the Euler characteristic (S) and the Betti numbers k(S).(III) The MC33 implementation is used to extract a piecewise linear mesh M, and its invariants (M) and k(M) are computed.(IV) Lastly, the pairs of topological invariants <(S), (M)> and <k(S),k(M)> are compared.A mismatch indicates that a problem has occurred.Nevertheless, as the authors note, a match between invariants does not imply a bug-free code <45>.The verification process does not prove the absence of bugs but only increases ones confidence in its correctness.In this chapter, we exploit the fact that when the expected and obtained surfaces are not homeomorphic, a counterexample is given in the form of a scalar field G and a mesh M. We use this information to find and correct errors in MC33.", "rank": 255, "paragraph_comparative_number": 4, "entities": [], "id": "p_255"}, "sentences": [{"end": 111433, "text": "We begin by investigating the source of topological problems in the MC33 implemen- tation <45>.", "rank": 916, "start": 111338, "IsComparative": "0", "id": "st_916"}, {"end": 111627, "text": "The topological issues described were obtained by systematically stress-testing the implementation over many topological configurations using the verification framework proposed in Etiene et al.", "rank": 917, "start": 111433, "IsComparative": "0", "id": "st_917"}, {"end": 111632, "text": "<45>.", "rank": 918, "start": 111627, "IsComparative": "1", "id": "st_918"}, {"end": 111685, "text": "These authors algorithm can be summarized as follows.", "rank": 919, "start": 111632, "IsComparative": "0", "id": "st_919"}, {"end": 111793, "text": "(I) A random scalar field G is built by uniformly sampling scalar values in the range <1, 1> for each xj  G.", "rank": 920, "start": 111685, "IsComparative": "0", "id": "st_920"}, {"end": 111916, "text": "(II) The expected topological invariants are obtained directly from S, i.e., without extracting the isosurface of interest.", "rank": 921, "start": 111793, "IsComparative": "0", "id": "st_921"}, {"end": 112008, "text": "The topological invariants used are the Euler characteristic (S) and the Betti numbers k(S).", "rank": 922, "start": 111916, "IsComparative": "0", "id": "st_922"}, {"end": 112129, "text": "(III) The MC33 implementation is used to extract a piecewise linear mesh M, and its invariants (M) and k(M) are computed.", "rank": 923, "start": 112008, "IsComparative": "1", "id": "st_923"}, {"end": 112218, "text": "(IV) Lastly, the pairs of topological invariants <(S), (M)> and <k(S),k(M)> are compared.", "rank": 924, "start": 112129, "IsComparative": "0", "id": "st_924"}, {"end": 112267, "text": "A mismatch indicates that a problem has occurred.", "rank": 925, "start": 112218, "IsComparative": "0", "id": "st_925"}, {"end": 112365, "text": "Nevertheless, as the authors note, a match between invariants does not imply a bug-free code <45>.", "rank": 926, "start": 112267, "IsComparative": "1", "id": "st_926"}, {"end": 112479, "text": "The verification process does not prove the absence of bugs but only increases ones confidence in its correctness.", "rank": 927, "start": 112365, "IsComparative": "1", "id": "st_927"}, {"end": 112714, "text": "In this chapter, we exploit the fact that when the expected and obtained surfaces are not homeomorphic, a counterexample is given in the form of a scalar field G and a mesh M. We use this information to find and correct errors in MC33.", "rank": 928, "start": 112479, "IsComparative": "0", "id": "st_928"}]}, {"paragraph_info": {"end": 112735, "start": 112714, "text": "4.3.1 Reproducibility", "rank": 256, "paragraph_comparative_number": 0, "entities": [], "id": "p_256"}, "sentences": [{"end": 112735, "text": "4.3.1 Reproducibility", "rank": 929, "start": 112714, "IsComparative": "0", "id": "st_929"}]}, {"paragraph_info": {"end": 114086, "start": 112735, "text": "As investigators in a mature field within the scientific visualization community, isosurface extraction researchers have developed ways to help other researchers and practitioners repro- duce their results.Published journal articles offer a first approximation of reproducibility.Nevertheless, many details regarding implementation, source code, input data, and other types of information are often omitted.Many, but not all, published techniques make source code and input data freely available, and some are part of widely used visualization packages such as VTK <155>.This practice greatly increases the degree of reproducibility of the work.We use CrowdLabs <172> and Vistrails <49, 158> as a platform to achieve this goal.To explore some of the results shown in this chapter, the reader may click on individual figure captions and interact with the results via web browser.We have selected cases in which MC33 fails and have provided the respective correct results.In addition, to allow the reader to explore and study the results presented here, he or she can also download the scalar fields and respective topological invariants  and  used for stress testing MC33.We also provide 10000 Marching Cubes cases grids and randomly generated 5x5x5 grids <28>.This dataset can be used to test any topologically correct isosurface extraction technique.", "rank": 257, "paragraph_comparative_number": 5, "entities": [], "id": "p_257"}, "sentences": [{"end": 112941, "text": "As investigators in a mature field within the scientific visualization community, isosurface extraction researchers have developed ways to help other researchers and practitioners repro- duce their results.", "rank": 930, "start": 112735, "IsComparative": "1", "id": "st_930"}, {"end": 113015, "text": "Published journal articles offer a first approximation of reproducibility.", "rank": 931, "start": 112941, "IsComparative": "0", "id": "st_931"}, {"end": 113142, "text": "Nevertheless, many details regarding implementation, source code, input data, and other types of information are often omitted.", "rank": 932, "start": 113015, "IsComparative": "0", "id": "st_932"}, {"end": 113306, "text": "Many, but not all, published techniques make source code and input data freely available, and some are part of widely used visualization packages such as VTK <155>.", "rank": 933, "start": 113142, "IsComparative": "1", "id": "st_933"}, {"end": 113380, "text": "This practice greatly increases the degree of reproducibility of the work.", "rank": 934, "start": 113306, "IsComparative": "0", "id": "st_934"}, {"end": 113462, "text": "We use CrowdLabs <172> and Vistrails <49, 158> as a platform to achieve this goal.", "rank": 935, "start": 113380, "IsComparative": "1", "id": "st_935"}, {"end": 113613, "text": "To explore some of the results shown in this chapter, the reader may click on individual figure captions and interact with the results via web browser.", "rank": 936, "start": 113462, "IsComparative": "1", "id": "st_936"}, {"end": 113705, "text": "We have selected cases in which MC33 fails and have provided the respective correct results.", "rank": 937, "start": 113613, "IsComparative": "0", "id": "st_937"}, {"end": 113906, "text": "In addition, to allow the reader to explore and study the results presented here, he or she can also download the scalar fields and respective topological invariants  and  used for stress testing MC33.", "rank": 938, "start": 113705, "IsComparative": "0", "id": "st_938"}, {"end": 113995, "text": "We also provide 10000 Marching Cubes cases grids and randomly generated 5x5x5 grids <28>.", "rank": 939, "start": 113906, "IsComparative": "1", "id": "st_939"}, {"end": 114086, "text": "This dataset can be used to test any topologically correct isosurface extraction technique.", "rank": 940, "start": 113995, "IsComparative": "0", "id": "st_940"}]}, {"paragraph_info": {"end": 114110, "start": 114086, "text": "4.4 Issues with the MC33", "rank": 258, "paragraph_comparative_number": 1, "entities": [], "id": "p_258"}, "sentences": [{"end": 114110, "text": "4.4 Issues with the MC33", "rank": 941, "start": 114086, "IsComparative": "1", "id": "st_941"}]}, {"paragraph_info": {"end": 114535, "start": 114110, "text": "In this section, we discuss specific issues regarding both the work of Chernyaev <21> and Lewiner et al.<94>.Because Lewiner et al.extends Chernyaevs work, the issues presented in the latter are also part of the former.Specifically, we detail three algorithmic issues  two in Chernyaevs MC33 and one in Lewiner et al.and one implementation issue.The solutions for the issues raised here will be presented in the next section.", "rank": 259, "paragraph_comparative_number": 2, "entities": [], "id": "p_259"}, "sentences": [{"end": 114214, "text": "In this section, we discuss specific issues regarding both the work of Chernyaev <21> and Lewiner et al.", "rank": 942, "start": 114110, "IsComparative": "1", "id": "st_942"}, {"end": 114219, "text": "<94>.", "rank": 943, "start": 114214, "IsComparative": "1", "id": "st_943"}, {"end": 114241, "text": "Because Lewiner et al.", "rank": 944, "start": 114219, "IsComparative": "0", "id": "st_944"}, {"end": 114329, "text": "extends Chernyaevs work, the issues presented in the latter are also part of the former.", "rank": 945, "start": 114241, "IsComparative": "0", "id": "st_945"}, {"end": 114427, "text": "Specifically, we detail three algorithmic issues  two in Chernyaevs MC33 and one in Lewiner et al.", "rank": 946, "start": 114329, "IsComparative": "0", "id": "st_946"}, {"end": 114456, "text": "and one implementation issue.", "rank": 947, "start": 114427, "IsComparative": "0", "id": "st_947"}, {"end": 114535, "text": "The solutions for the issues raised here will be presented in the next section.", "rank": 948, "start": 114456, "IsComparative": "0", "id": "st_948"}]}, {"paragraph_info": {"end": 115237, "start": 114535, "text": "This section is organized as follows.First, we explain an algorithmic problem with the MC33 core disambiguation procedure.This issue has not been discussed in the literature to date.We then discuss a second algorithmic problem related to the triangulation table and the extraction of nonmanifold meshes.Although this problem has been discussed in the literature, we discuss it here for completeness and because we provide an alternative solution to the problem (see Section 4.5).Next, we show a third algorithmic problem related to the alternative approach proposed by Lewiner et al.for computing the height plane t. Lastly, we show a nontrivial problem with the open-source implementation of the MC33.", "rank": 260, "paragraph_comparative_number": 1, "entities": [], "id": "p_260"}, "sentences": [{"end": 114572, "text": "This section is organized as follows.", "rank": 949, "start": 114535, "IsComparative": "0", "id": "st_949"}, {"end": 114657, "text": "First, we explain an algorithmic problem with the MC33 core disambiguation procedure.", "rank": 950, "start": 114572, "IsComparative": "0", "id": "st_950"}, {"end": 114717, "text": "This issue has not been discussed in the literature to date.", "rank": 951, "start": 114657, "IsComparative": "0", "id": "st_951"}, {"end": 114838, "text": "We then discuss a second algorithmic problem related to the triangulation table and the extraction of nonmanifold meshes.", "rank": 952, "start": 114717, "IsComparative": "1", "id": "st_952"}, {"end": 115014, "text": "Although this problem has been discussed in the literature, we discuss it here for completeness and because we provide an alternative solution to the problem (see Section 4.5).", "rank": 953, "start": 114838, "IsComparative": "0", "id": "st_953"}, {"end": 115118, "text": "Next, we show a third algorithmic problem related to the alternative approach proposed by Lewiner et al.", "rank": 954, "start": 115014, "IsComparative": "0", "id": "st_954"}, {"end": 115237, "text": "for computing the height plane t. Lastly, we show a nontrivial problem with the open-source implementation of the MC33.", "rank": 955, "start": 115118, "IsComparative": "0", "id": "st_955"}]}, {"paragraph_info": {"end": 115261, "start": 115237, "text": "4.4.1 Issue I  Case 13.5", "rank": 261, "paragraph_comparative_number": 0, "entities": [], "id": "p_261"}, "sentences": [{"end": 115261, "text": "4.4.1 Issue I  Case 13.5", "rank": 956, "start": 115237, "IsComparative": "0", "id": "st_956"}]}, {"paragraph_info": {"end": 115442, "start": 115261, "text": "Here, we show a problem with the core disambiguation procedure described in the work of Chernyaev.To our knowledge, this problem has not been exposed or addressed in the literature.", "rank": 262, "paragraph_comparative_number": 1, "entities": [], "id": "p_262"}, "sentences": [{"end": 115359, "text": "Here, we show a problem with the core disambiguation procedure described in the work of Chernyaev.", "rank": 957, "start": 115261, "IsComparative": "0", "id": "st_957"}, {"end": 115442, "text": "To our knowledge, this problem has not been exposed or addressed in the literature.", "rank": 958, "start": 115359, "IsComparative": "1", "id": "st_958"}]}, {"paragraph_info": {"end": 116121, "start": 115442, "text": "Case 13 is certainly the most complex table case; all faces are ambiguous, and six subcases are possible.Four of the subcases can be discriminated by using Asymptotic De- cider.The remaining cases 13.5.1 and 13.5.2 require Chernyaevs MC33 interior ambiguity resolution method.Recall that the MC33 approach discriminates between tunnels and isolated sheets by finding a cutting-plane for which positive nodes in the cube diagonal are joined by points in the interior of the cubic cell (see Figure 4.2).Cases 13.5.1 and 13.5.2 differ precisely because the positive nodes in case 13.5.2 are connected to one another by interior points, which is not true for 13.5.1 (see Figure 4.3).", "rank": 263, "paragraph_comparative_number": 1, "entities": [], "id": "p_263"}, "sentences": [{"end": 115547, "text": "Case 13 is certainly the most complex table case; all faces are ambiguous, and six subcases are possible.", "rank": 959, "start": 115442, "IsComparative": "1", "id": "st_959"}, {"end": 115619, "text": "Four of the subcases can be discriminated by using Asymptotic De- cider.", "rank": 960, "start": 115547, "IsComparative": "0", "id": "st_960"}, {"end": 115718, "text": "The remaining cases 13.5.1 and 13.5.2 require Chernyaevs MC33 interior ambiguity resolution method.", "rank": 961, "start": 115619, "IsComparative": "0", "id": "st_961"}, {"end": 115943, "text": "Recall that the MC33 approach discriminates between tunnels and isolated sheets by finding a cutting-plane for which positive nodes in the cube diagonal are joined by points in the interior of the cubic cell (see Figure 4.2).", "rank": 962, "start": 115718, "IsComparative": "0", "id": "st_962"}, {"end": 116121, "text": "Cases 13.5.1 and 13.5.2 differ precisely because the positive nodes in case 13.5.2 are connected to one another by interior points, which is not true for 13.5.1 (see Figure 4.3).", "rank": 963, "start": 115943, "IsComparative": "0", "id": "st_963"}]}, {"paragraph_info": {"end": 116459, "start": 116121, "text": "Although it seems that the MC33 methodology described in Section 4.2 fits naturally in this scenario, as it turns out this disambiguation procedure cannot be applied for 13.5.Let us illustrate this point with an example.Figure 4.4 shows the expected changes in the sign of the saddle point xc as a function of the height t. Mathematically", "rank": 264, "paragraph_comparative_number": 0, "entities": [], "id": "p_264"}, "sentences": [{"end": 116296, "text": "Although it seems that the MC33 methodology described in Section 4.2 fits naturally in this scenario, as it turns out this disambiguation procedure cannot be applied for 13.5.", "rank": 964, "start": 116121, "IsComparative": "0", "id": "st_964"}, {"end": 116341, "text": "Let us illustrate this point with an example.", "rank": 965, "start": 116296, "IsComparative": "0", "id": "st_965"}, {"end": 116459, "text": "Figure 4.4 shows the expected changes in the sign of the saddle point xc as a function of the height t. Mathematically", "rank": 966, "start": 116341, "IsComparative": "0", "id": "st_966"}]}, {"paragraph_info": {"end": 116577, "start": 116459, "text": "It follows that the face saddle value (and thus sign) is also defined as a function of t: f(xc(t)) = AtCt  BtDt (4.10)", "rank": 265, "paragraph_comparative_number": 0, "entities": [], "id": "p_265"}, "sentences": [{"end": 116577, "text": "It follows that the face saddle value (and thus sign) is also defined as a function of t: f(xc(t)) = AtCt  BtDt (4.10)", "rank": 967, "start": 116459, "IsComparative": "0", "id": "st_967"}]}, {"paragraph_info": {"end": 117235, "start": 116577, "text": "As can be seen in Figure 4.4, from left to right, as the plane height t changes, the value of the face saddle f(xc(t)) changes from negative to positive to negative and to positive again.These changes occur at the roots t1 and t2 of f(xc(t)) and the asymptote of f(xc(t)), i.e., the root ta of the denominator of f (see left image in Figure 4.5).Thus, in total, three sign changes will occur.The rightmost image in Figure 4.4 shows the path traced by the face saddles xc(t); as t grows, there is a jump not only in the sign of f(xc(t)) but also in the position of xc(t) .The change occurs precisely when the height t passes through the asymptote of f(xc(t)).", "rank": 266, "paragraph_comparative_number": 1, "entities": [], "id": "p_266"}, "sentences": [{"end": 116764, "text": "As can be seen in Figure 4.4, from left to right, as the plane height t changes, the value of the face saddle f(xc(t)) changes from negative to positive to negative and to positive again.", "rank": 968, "start": 116577, "IsComparative": "0", "id": "st_968"}, {"end": 116923, "text": "These changes occur at the roots t1 and t2 of f(xc(t)) and the asymptote of f(xc(t)), i.e., the root ta of the denominator of f (see left image in Figure 4.5).", "rank": 969, "start": 116764, "IsComparative": "0", "id": "st_969"}, {"end": 116969, "text": "Thus, in total, three sign changes will occur.", "rank": 970, "start": 116923, "IsComparative": "1", "id": "st_970"}, {"end": 117148, "text": "The rightmost image in Figure 4.4 shows the path traced by the face saddles xc(t); as t grows, there is a jump not only in the sign of f(xc(t)) but also in the position of xc(t) .", "rank": 971, "start": 116969, "IsComparative": "0", "id": "st_971"}, {"end": 117235, "text": "The change occurs precisely when the height t passes through the asymptote of f(xc(t)).", "rank": 972, "start": 117148, "IsComparative": "0", "id": "st_972"}]}, {"paragraph_info": {"end": 117735, "start": 117235, "text": "Nevertheless, contrary to what is expected, the polynomial F(t) (Equation (4.7)), used by Chernyaevs MC33 algorithm for tracking the sign of the saddle point, is a second order equation in t and thus can only allow for two sign changes.Therefore, the sign tracked by the MC33 algorithm will not match the expected one at some point.Because the sign of the saddle points is embedded in all three conditions for verifying the presence or absence of tunnels, MC33 will eventually provide a wrong result.", "rank": 267, "paragraph_comparative_number": 2, "entities": [], "id": "p_267"}, "sentences": [{"end": 117471, "text": "Nevertheless, contrary to what is expected, the polynomial F(t) (Equation (4.7)), used by Chernyaevs MC33 algorithm for tracking the sign of the saddle point, is a second order equation in t and thus can only allow for two sign changes.", "rank": 973, "start": 117235, "IsComparative": "1", "id": "st_973"}, {"end": 117567, "text": "Therefore, the sign tracked by the MC33 algorithm will not match the expected one at some point.", "rank": 974, "start": 117471, "IsComparative": "0", "id": "st_974"}, {"end": 117735, "text": "Because the sign of the saddle points is embedded in all three conditions for verifying the presence or absence of tunnels, MC33 will eventually provide a wrong result.", "rank": 975, "start": 117567, "IsComparative": "1", "id": "st_975"}]}, {"paragraph_info": {"end": 118905, "start": 117735, "text": "The source of the problem can be tracked to Equations (4.3) and (4.4) and the as- sumption that the denominator of f(xc) (Equation (4.2)) is positive.These assumptions can easily be verified to be true for case 4, shown in Figure 4.2.However, for case 13, the saddle points at the top and bottom planes have opposite signs, which contradicts Equations (4.3) and (4.4).In addition, the denominator A + C  B  D of f (xc ) changes its sign at the asymptote of f(xc), contrary to the assumption that it is always positive.The consequence of incorrectly tracking sign changes is that the three rules used for resolving internal ambiguity will fail for some scalar fields.As an example, Figure 4.5 shows a case 13.5.2 that will mistakenly be taken as case 13.5.1 because a > 0 characterizes multiples surface sheets instead of a tunnel (see also Appendix A).The problem is not only related to the misclassification of case 13.5.2 as 13.5.1.We have also devised examples in which case 13.5.1 is mistakenly taken as case 13.5.2 because the three criteria shown in Section 4.2 hold.Thus, Chernyaevs interior ambiguity test does not always yield topologically correct isosurfaces.", "rank": 268, "paragraph_comparative_number": 3, "entities": [], "id": "p_268"}, "sentences": [{"end": 117885, "text": "The source of the problem can be tracked to Equations (4.3) and (4.4) and the as- sumption that the denominator of f(xc) (Equation (4.2)) is positive.", "rank": 976, "start": 117735, "IsComparative": "1", "id": "st_976"}, {"end": 117969, "text": "These assumptions can easily be verified to be true for case 4, shown in Figure 4.2.", "rank": 977, "start": 117885, "IsComparative": "0", "id": "st_977"}, {"end": 118103, "text": "However, for case 13, the saddle points at the top and bottom planes have opposite signs, which contradicts Equations (4.3) and (4.4).", "rank": 978, "start": 117969, "IsComparative": "0", "id": "st_978"}, {"end": 118253, "text": "In addition, the denominator A + C  B  D of f (xc ) changes its sign at the asymptote of f(xc), contrary to the assumption that it is always positive.", "rank": 979, "start": 118103, "IsComparative": "1", "id": "st_979"}, {"end": 118401, "text": "The consequence of incorrectly tracking sign changes is that the three rules used for resolving internal ambiguity will fail for some scalar fields.", "rank": 980, "start": 118253, "IsComparative": "1", "id": "st_980"}, {"end": 118587, "text": "As an example, Figure 4.5 shows a case 13.5.2 that will mistakenly be taken as case 13.5.1 because a > 0 characterizes multiples surface sheets instead of a tunnel (see also Appendix A).", "rank": 981, "start": 118401, "IsComparative": "0", "id": "st_981"}, {"end": 118669, "text": "The problem is not only related to the misclassification of case 13.5.2 as 13.5.1.", "rank": 982, "start": 118587, "IsComparative": "0", "id": "st_982"}, {"end": 118808, "text": "We have also devised examples in which case 13.5.1 is mistakenly taken as case 13.5.2 because the three criteria shown in Section 4.2 hold.", "rank": 983, "start": 118669, "IsComparative": "0", "id": "st_983"}, {"end": 118905, "text": "Thus, Chernyaevs interior ambiguity test does not always yield topologically correct isosurfaces.", "rank": 984, "start": 118808, "IsComparative": "0", "id": "st_984"}]}, {"paragraph_info": {"end": 118931, "start": 118905, "text": "4.4.1.1 Tunnel orientation", "rank": 269, "paragraph_comparative_number": 0, "entities": [], "id": "p_269"}, "sentences": [{"end": 118931, "text": "4.4.1.1 Tunnel orientation", "rank": 985, "start": 118905, "IsComparative": "0", "id": "st_985"}]}, {"paragraph_info": {"end": 119941, "start": 118931, "text": "A second minor issue regarding case 13.5.2 is the tunnel orientation of configuration 13.5.2.Once case 13.5.2 is determined, one needs to properly orient the tunnel inside the voxel.Figure 4.6 shows the two possibilities.Both vertices at the voxel diagonal are separated from all other voxel vertices at the voxel faces (note that this is not the case for other vertices).Nevertheless, either the positive or the negative vertex of the cube diagonal will connect with vertices with the same sign through the voxels interior.This will determine which vertex is isolated and which is facing the tunnel.This problem with the tunnel orientation is not dealt with or mentioned in either the work of Chernyaev or Lewiner et al.Nevertheless, it was briefly mentioned in Etiene et al.<45>, but no solution to the problem was provided.As the authors observed, the isosurface topology changes if the tunnel orientation is incorrect; thus, it must be oriented correctly.Section 4.5.1.1 provides a solution for this issue.", "rank": 270, "paragraph_comparative_number": 2, "entities": [], "id": "p_270"}, "sentences": [{"end": 119024, "text": "A second minor issue regarding case 13.5.2 is the tunnel orientation of configuration 13.5.2.", "rank": 986, "start": 118931, "IsComparative": "0", "id": "st_986"}, {"end": 119113, "text": "Once case 13.5.2 is determined, one needs to properly orient the tunnel inside the voxel.", "rank": 987, "start": 119024, "IsComparative": "0", "id": "st_987"}, {"end": 119152, "text": "Figure 4.6 shows the two possibilities.", "rank": 988, "start": 119113, "IsComparative": "1", "id": "st_988"}, {"end": 119303, "text": "Both vertices at the voxel diagonal are separated from all other voxel vertices at the voxel faces (note that this is not the case for other vertices).", "rank": 989, "start": 119152, "IsComparative": "1", "id": "st_989"}, {"end": 119455, "text": "Nevertheless, either the positive or the negative vertex of the cube diagonal will connect with vertices with the same sign through the voxels interior.", "rank": 990, "start": 119303, "IsComparative": "0", "id": "st_990"}, {"end": 119531, "text": "This will determine which vertex is isolated and which is facing the tunnel.", "rank": 991, "start": 119455, "IsComparative": "0", "id": "st_991"}, {"end": 119652, "text": "This problem with the tunnel orientation is not dealt with or mentioned in either the work of Chernyaev or Lewiner et al.", "rank": 992, "start": 119531, "IsComparative": "0", "id": "st_992"}, {"end": 119707, "text": "Nevertheless, it was briefly mentioned in Etiene et al.", "rank": 993, "start": 119652, "IsComparative": "0", "id": "st_993"}, {"end": 119757, "text": "<45>, but no solution to the problem was provided.", "rank": 994, "start": 119707, "IsComparative": "0", "id": "st_994"}, {"end": 119890, "text": "As the authors observed, the isosurface topology changes if the tunnel orientation is incorrect; thus, it must be oriented correctly.", "rank": 995, "start": 119757, "IsComparative": "0", "id": "st_995"}, {"end": 119941, "text": "Section 4.5.1.1 provides a solution for this issue.", "rank": 996, "start": 119890, "IsComparative": "0", "id": "st_996"}]}, {"paragraph_info": {"end": 119977, "start": 119941, "text": "4.4.2 Issue II  Nonmanifold Surfaces", "rank": 271, "paragraph_comparative_number": 0, "entities": [], "id": "p_271"}, "sentences": [{"end": 119977, "text": "4.4.2 Issue II  Nonmanifold Surfaces", "rank": 997, "start": 119941, "IsComparative": "0", "id": "st_997"}]}, {"paragraph_info": {"end": 121018, "start": 119977, "text": "The second algorithmic issue is related to the triangulation table used to build trian- gulated surfaces.The choice of the correct MC configuration is only part of the process of building an algorithm that preserves the topology of the piecewise-trilinear field.The voxel triangulation table is, in fact, the determinant of the final mesh topology.Chernyaevs orig- inal triangulation table contains cases that lead to topologically inconsistent nonmanifold meshes in scenarios such as the one shown in Figure 4.7.This problem occurs because the MC33 triangulation table allows faces that are coplanar with the grid voxel faces.Hence, when neighbor voxels have tunnels in their interiors, and share an ambiguous, coplanar face, the end result will be nonmanifold edges, as shown in Figure 4.7.Because this is an issue with the triangulation table, any topologically correct algorithm whose table is based on Chernyaevs triangulation table will build nonmanifold surfaces whether or not the algorithm can correctly distinguish the voxel cases.", "rank": 272, "paragraph_comparative_number": 2, "entities": [], "id": "p_272"}, "sentences": [{"end": 120082, "text": "The second algorithmic issue is related to the triangulation table used to build trian- gulated surfaces.", "rank": 998, "start": 119977, "IsComparative": "0", "id": "st_998"}, {"end": 120239, "text": "The choice of the correct MC configuration is only part of the process of building an algorithm that preserves the topology of the piecewise-trilinear field.", "rank": 999, "start": 120082, "IsComparative": "1", "id": "st_999"}, {"end": 120325, "text": "The voxel triangulation table is, in fact, the determinant of the final mesh topology.", "rank": 1000, "start": 120239, "IsComparative": "0", "id": "st_1000"}, {"end": 120490, "text": "Chernyaevs orig- inal triangulation table contains cases that lead to topologically inconsistent nonmanifold meshes in scenarios such as the one shown in Figure 4.7.", "rank": 1001, "start": 120325, "IsComparative": "0", "id": "st_1001"}, {"end": 120604, "text": "This problem occurs because the MC33 triangulation table allows faces that are coplanar with the grid voxel faces.", "rank": 1002, "start": 120490, "IsComparative": "0", "id": "st_1002"}, {"end": 120769, "text": "Hence, when neighbor voxels have tunnels in their interiors, and share an ambiguous, coplanar face, the end result will be nonmanifold edges, as shown in Figure 4.7.", "rank": 1003, "start": 120604, "IsComparative": "1", "id": "st_1003"}, {"end": 121018, "text": "Because this is an issue with the triangulation table, any topologically correct algorithm whose table is based on Chernyaevs triangulation table will build nonmanifold surfaces whether or not the algorithm can correctly distinguish the voxel cases.", "rank": 1004, "start": 120769, "IsComparative": "0", "id": "st_1004"}]}, {"paragraph_info": {"end": 121876, "start": 121018, "text": "This problem with Chernyaevs work was pointed out by Lopes and Brodlie <98> (follow- ing earlier work by Van Gelder and Wilhelms <52>) and is one of the motivations of Lopes and Brodlies work on topologically correct and geometrically accurate isosurface extraction algorithm <98>.Lopes and Brodlie aimed at improving the geometry quality of the trilinear surface patches and consequently solving the topology problem.They achieve this goal by adding points to the voxel faces as well as to the voxel interior.These extra points are placed on the trilinear patch, which increases geometry accuracy.They are classified into three different classes and used for extending the contour of the trilinear patch with the voxel faces.The implementation of this technique becomes intricate and error-prone due to the additional steps required for voxel triangulation.", "rank": 273, "paragraph_comparative_number": 1, "entities": [], "id": "p_273"}, "sentences": [{"end": 121299, "text": "This problem with Chernyaevs work was pointed out by Lopes and Brodlie <98> (follow- ing earlier work by Van Gelder and Wilhelms <52>) and is one of the motivations of Lopes and Brodlies work on topologically correct and geometrically accurate isosurface extraction algorithm <98>.", "rank": 1005, "start": 121018, "IsComparative": "0", "id": "st_1005"}, {"end": 121436, "text": "Lopes and Brodlie aimed at improving the geometry quality of the trilinear surface patches and consequently solving the topology problem.", "rank": 1006, "start": 121299, "IsComparative": "1", "id": "st_1006"}, {"end": 121528, "text": "They achieve this goal by adding points to the voxel faces as well as to the voxel interior.", "rank": 1007, "start": 121436, "IsComparative": "0", "id": "st_1007"}, {"end": 121616, "text": "These extra points are placed on the trilinear patch, which increases geometry accuracy.", "rank": 1008, "start": 121528, "IsComparative": "0", "id": "st_1008"}, {"end": 121744, "text": "They are classified into three different classes and used for extending the contour of the trilinear patch with the voxel faces.", "rank": 1009, "start": 121616, "IsComparative": "0", "id": "st_1009"}, {"end": 121876, "text": "The implementation of this technique becomes intricate and error-prone due to the additional steps required for voxel triangulation.", "rank": 1010, "start": 121744, "IsComparative": "0", "id": "st_1010"}]}, {"paragraph_info": {"end": 121918, "start": 121876, "text": "4.4.3 Issue III  Cutting-plane Computation", "rank": 274, "paragraph_comparative_number": 0, "entities": [], "id": "p_274"}, "sentences": [{"end": 121918, "text": "4.4.3 Issue III  Cutting-plane Computation", "rank": 1011, "start": 121876, "IsComparative": "0", "id": "st_1011"}]}, {"paragraph_info": {"end": 123359, "start": 121918, "text": "The third algorithmic issue is related to an MC33 improvement proposed by Lewiner et al.<94> for computing the plane height.The problem is that Equation (4.8) may fail to find an appropriate height that can correctly distinguish between tunnels and surface sheets.Let us illustrate this point with an example.For the cases previously cited, two of the conditions in the Chernyaev interior test described in Section 4.2 are not used.The MC33 implementation does not use condition (i), and (ii) is always true because the edge e will always have a positive and a negative vertex, implying that talt  (0, 1).Thus, only condition (iii) is used in retrieving the correct voxel topology.Suppose that the scalar field in a given voxel defines a tunnel, as shown in the left image in Figure 4.8.In this case, to retrieve the correct topology, F(t) should be a downward-facing parabola with both roots t1,t2  (0,1), t1 < t2, and tmax  (t1,t2).In this case, F(t) > 0 only for t  (t1,t2); hence, F(tmax) > 0, and a tunnel is retrieved according to condition (iii).The problem with the alternative approach is that, as shown in Figure 4.8, the solution to Equation (4.8) is not guaranteed to fall within the (t1,t2) interval, which implies that the scalar field may be incorrectly interpreted as containing two sheets of surface (shown on the right).In other words, because talt  (0,t1) and F(talt) < 0, condition (iii) verifies the absence of a tunnel.", "rank": 275, "paragraph_comparative_number": 3, "entities": [], "id": "p_275"}, "sentences": [{"end": 122006, "text": "The third algorithmic issue is related to an MC33 improvement proposed by Lewiner et al.", "rank": 1012, "start": 121918, "IsComparative": "0", "id": "st_1012"}, {"end": 122042, "text": "<94> for computing the plane height.", "rank": 1013, "start": 122006, "IsComparative": "0", "id": "st_1013"}, {"end": 122182, "text": "The problem is that Equation (4.8) may fail to find an appropriate height that can correctly distinguish between tunnels and surface sheets.", "rank": 1014, "start": 122042, "IsComparative": "1", "id": "st_1014"}, {"end": 122227, "text": "Let us illustrate this point with an example.", "rank": 1015, "start": 122182, "IsComparative": "0", "id": "st_1015"}, {"end": 122350, "text": "For the cases previously cited, two of the conditions in the Chernyaev interior test described in Section 4.2 are not used.", "rank": 1016, "start": 122227, "IsComparative": "0", "id": "st_1016"}, {"end": 122523, "text": "The MC33 implementation does not use condition (i), and (ii) is always true because the edge e will always have a positive and a negative vertex, implying that talt  (0, 1).", "rank": 1017, "start": 122350, "IsComparative": "0", "id": "st_1017"}, {"end": 122599, "text": "Thus, only condition (iii) is used in retrieving the correct voxel topology.", "rank": 1018, "start": 122523, "IsComparative": "0", "id": "st_1018"}, {"end": 122705, "text": "Suppose that the scalar field in a given voxel defines a tunnel, as shown in the left image in Figure 4.8.", "rank": 1019, "start": 122599, "IsComparative": "0", "id": "st_1019"}, {"end": 122852, "text": "In this case, to retrieve the correct topology, F(t) should be a downward-facing parabola with both roots t1,t2  (0,1), t1 < t2, and tmax  (t1,t2).", "rank": 1020, "start": 122705, "IsComparative": "0", "id": "st_1020"}, {"end": 122971, "text": "In this case, F(t) > 0 only for t  (t1,t2); hence, F(tmax) > 0, and a tunnel is retrieved according to condition (iii).", "rank": 1021, "start": 122852, "IsComparative": "0", "id": "st_1021"}, {"end": 123256, "text": "The problem with the alternative approach is that, as shown in Figure 4.8, the solution to Equation (4.8) is not guaranteed to fall within the (t1,t2) interval, which implies that the scalar field may be incorrectly interpreted as containing two sheets of surface (shown on the right).", "rank": 1022, "start": 122971, "IsComparative": "1", "id": "st_1022"}, {"end": 123359, "text": "In other words, because talt  (0,t1) and F(talt) < 0, condition (iii) verifies the absence of a tunnel.", "rank": 1023, "start": 123256, "IsComparative": "1", "id": "st_1023"}]}, {"paragraph_info": {"end": 123561, "start": 123359, "text": "The last issue described in this work is related to the implementation of MC33.De- velopers know all too well that code mistakes are inherent to software and the MC33 implementation is not an exception.", "rank": 276, "paragraph_comparative_number": 0, "entities": [], "id": "p_276"}, "sentences": [{"end": 123438, "text": "The last issue described in this work is related to the implementation of MC33.", "rank": 1024, "start": 123359, "IsComparative": "0", "id": "st_1024"}, {"end": 123561, "text": "De- velopers know all too well that code mistakes are inherent to software and the MC33 implementation is not an exception.", "rank": 1025, "start": 123438, "IsComparative": "0", "id": "st_1025"}]}, {"paragraph_info": {"end": 123909, "start": 123561, "text": "Due to a missing step in the implementation of the disambiguation algorithm, MC33 fails to correctly resolve the ambiguity in cases 10 and 12.Note that both cases have exactly two ambiguous faces and the nodes in ambiguous faces can be either separated or joined.In the discussion that follows, we restrict ourselves to case 10; case 12 is similar.", "rank": 277, "paragraph_comparative_number": 1, "entities": [], "id": "p_277"}, "sentences": [{"end": 123703, "text": "Due to a missing step in the implementation of the disambiguation algorithm, MC33 fails to correctly resolve the ambiguity in cases 10 and 12.", "rank": 1026, "start": 123561, "IsComparative": "1", "id": "st_1026"}, {"end": 123824, "text": "Note that both cases have exactly two ambiguous faces and the nodes in ambiguous faces can be either separated or joined.", "rank": 1027, "start": 123703, "IsComparative": "0", "id": "st_1027"}, {"end": 123909, "text": "In the discussion that follows, we restrict ourselves to case 10; case 12 is similar.", "rank": 1028, "start": 123824, "IsComparative": "0", "id": "st_1028"}]}, {"paragraph_info": {"end": 124162, "start": 123909, "text": "Let us assume that the ambiguous faces are located at the top and bottom of the voxel.Then, following the algorithm proposed by Chernyaev <21>, depending on the sign of the face saddles and the interior ambiguity test, one can identify the correct case:", "rank": 278, "paragraph_comparative_number": 1, "entities": [], "id": "p_278"}, "sentences": [{"end": 123995, "text": "Let us assume that the ambiguous faces are located at the top and bottom of the voxel.", "rank": 1029, "start": 123909, "IsComparative": "0", "id": "st_1029"}, {"end": 124162, "text": "Then, following the algorithm proposed by Chernyaev <21>, depending on the sign of the face saddles and the interior ambiguity test, one can identify the correct case:", "rank": 1030, "start": 123995, "IsComparative": "1", "id": "st_1030"}]}, {"paragraph_info": {"end": 124283, "start": 124162, "text": "Case 10.1.1: the positive nodes on both faces are separated, and the positive nodes at cube diagonals are also separated;", "rank": 279, "paragraph_comparative_number": 0, "entities": [], "id": "p_279"}, "sentences": [{"end": 124283, "text": "Case 10.1.1: the positive nodes on both faces are separated, and the positive nodes at cube diagonals are also separated;", "rank": 1031, "start": 124162, "IsComparative": "0", "id": "st_1031"}]}, {"paragraph_info": {"end": 124397, "start": 124283, "text": "Case 10.1.2: the positive nodes on both faces are separated, and the positive nodes at the cube diagonals are not;", "rank": 280, "paragraph_comparative_number": 0, "entities": [], "id": "p_280"}, "sentences": [{"end": 124397, "text": "Case 10.1.2: the positive nodes on both faces are separated, and the positive nodes at the cube diagonals are not;", "rank": 1032, "start": 124283, "IsComparative": "0", "id": "st_1032"}]}, {"paragraph_info": {"end": 124485, "start": 124397, "text": "Case 10.2: the positive nodes are separated on the top and connected on the bottom face.", "rank": 281, "paragraph_comparative_number": 0, "entities": [], "id": "p_281"}, "sentences": [{"end": 124485, "text": "Case 10.2: the positive nodes are separated on the top and connected on the bottom face.", "rank": 1033, "start": 124397, "IsComparative": "0", "id": "st_1033"}]}, {"paragraph_info": {"end": 124795, "start": 124485, "text": "The cases shown above assume that the positives nodes at the top face are separated.But a similar reasoning must be applied to cases in which the positives nodes at the top faces are joined.In the implementation of Lewiner et al., the possibility that the positive nodes at the top faces are joined is missing.", "rank": 282, "paragraph_comparative_number": 0, "entities": [], "id": "p_282"}, "sentences": [{"end": 124569, "text": "The cases shown above assume that the positives nodes at the top face are separated.", "rank": 1034, "start": 124485, "IsComparative": "0", "id": "st_1034"}, {"end": 124675, "text": "But a similar reasoning must be applied to cases in which the positives nodes at the top faces are joined.", "rank": 1035, "start": 124569, "IsComparative": "0", "id": "st_1035"}, {"end": 124795, "text": "In the implementation of Lewiner et al., the possibility that the positive nodes at the top faces are joined is missing.", "rank": 1036, "start": 124675, "IsComparative": "0", "id": "st_1036"}]}, {"paragraph_info": {"end": 124808, "start": 124795, "text": "4.5 Solutions", "rank": 283, "paragraph_comparative_number": 0, "entities": [], "id": "p_283"}, "sentences": [{"end": 124808, "text": "4.5 Solutions", "rank": 1037, "start": 124795, "IsComparative": "0", "id": "st_1037"}]}, {"paragraph_info": {"end": 124880, "start": 124808, "text": "We present solutions for the four issues raised in the previous section.", "rank": 284, "paragraph_comparative_number": 1, "entities": [], "id": "p_284"}, "sentences": [{"end": 124880, "text": "We present solutions for the four issues raised in the previous section.", "rank": 1038, "start": 124808, "IsComparative": "1", "id": "st_1038"}]}, {"paragraph_info": {"end": 124904, "start": 124880, "text": "4.5.1 Issue I  Case 13.5", "rank": 285, "paragraph_comparative_number": 0, "entities": [], "id": "p_285"}, "sentences": [{"end": 124904, "text": "4.5.1 Issue I  Case 13.5", "rank": 1039, "start": 124880, "IsComparative": "0", "id": "st_1039"}]}, {"paragraph_info": {"end": 125875, "start": 124904, "text": "The disambiguation of case 13.5 has been approached in different ways for different frameworks for isosurface extraction.For example, Nielson <125> presents an algorithm that is concerned with connectivity along edges, faces and the voxel interior.The author presents a detailed description of the behavior of the trilinear interpolant inside the cubic grid and uses these descriptions to solve the ambiguity problem in the interior.Lopes and Brodlie <98>, on the other hand, use critical points in order to resolve some ambiguities.In this case, the sign of the critical point determines the correct configuration.Unfortunately, the above solutions do not seamlessly integrate with the MC33 algorithm.The core idea for solving interior ambiguity, namely, that tunnels can be detected by a sweeping plane through the voxel, is absent in both approaches.This motivated us to devise an alternative solution that we feel follows the idea presented in the original algorithm.", "rank": 286, "paragraph_comparative_number": 1, "entities": [], "id": "p_286"}, "sentences": [{"end": 125025, "text": "The disambiguation of case 13.5 has been approached in different ways for different frameworks for isosurface extraction.", "rank": 1040, "start": 124904, "IsComparative": "0", "id": "st_1040"}, {"end": 125152, "text": "For example, Nielson <125> presents an algorithm that is concerned with connectivity along edges, faces and the voxel interior.", "rank": 1041, "start": 125025, "IsComparative": "0", "id": "st_1041"}, {"end": 125337, "text": "The author presents a detailed description of the behavior of the trilinear interpolant inside the cubic grid and uses these descriptions to solve the ambiguity problem in the interior.", "rank": 1042, "start": 125152, "IsComparative": "1", "id": "st_1042"}, {"end": 125437, "text": "Lopes and Brodlie <98>, on the other hand, use critical points in order to resolve some ambiguities.", "rank": 1043, "start": 125337, "IsComparative": "0", "id": "st_1043"}, {"end": 125519, "text": "In this case, the sign of the critical point determines the correct configuration.", "rank": 1044, "start": 125437, "IsComparative": "0", "id": "st_1044"}, {"end": 125606, "text": "Unfortunately, the above solutions do not seamlessly integrate with the MC33 algorithm.", "rank": 1045, "start": 125519, "IsComparative": "0", "id": "st_1045"}, {"end": 125757, "text": "The core idea for solving interior ambiguity, namely, that tunnels can be detected by a sweeping plane through the voxel, is absent in both approaches.", "rank": 1046, "start": 125606, "IsComparative": "0", "id": "st_1046"}, {"end": 125875, "text": "This motivated us to devise an alternative solution that we feel follows the idea presented in the original algorithm.", "rank": 1047, "start": 125757, "IsComparative": "0", "id": "st_1047"}]}, {"paragraph_info": {"end": 127408, "start": 125875, "text": "We solve this problem by proposing a new interior test that uses the fact that case 13.5.2 requires both roots t1 and t2 of f(xc(t)) and the associated saddle points to be inside the voxel.First, recall that xc(t) tracks the path of the face saddle inside the voxel as a function of height plane at height t, and f(xc(t)) tracks the value (and thus the sign) of that saddle.Both functions are illustrated in the rightmost image in Figure 4.4, in which the black hyperbolic curves represent the path of xc(t) and the color of the circles represents the sign of the face saddle at a given point (white and black circles are points with negative and positive values, respectively).For case 13.5.2, the path traced by the curve xc(t) must intersect the isosurface tunnel twice, once at each of the roots t1 and t2 of f(xc(t)).This implies that both saddle points xc(t1) and xc(t2) must lie inside the voxel.This is not the case for 13.5.1 because the face saddle can cross the middle sheet at most once.Therefore, it suffices to verify that both roots of f(xc(t)) and its saddle points are inside the voxel.Algorithm 6 illustrates our solution.Our algorithm is very simple, and does not require the computation of the critical points of the trilinear interpolant, or a detailed description of its behavior inside a voxel.Our algorithm uses the ideas proposed by Chernyaev in order to fix an algorithmic problem in his work.We have implemented and tested this solution on C-MC33 using over 10000 randomly generated instances of case 13.5.", "rank": 287, "paragraph_comparative_number": 7, "entities": [], "id": "p_287"}, "sentences": [{"end": 126064, "text": "We solve this problem by proposing a new interior test that uses the fact that case 13.5.2 requires both roots t1 and t2 of f(xc(t)) and the associated saddle points to be inside the voxel.", "rank": 1048, "start": 125875, "IsComparative": "1", "id": "st_1048"}, {"end": 126249, "text": "First, recall that xc(t) tracks the path of the face saddle inside the voxel as a function of height plane at height t, and f(xc(t)) tracks the value (and thus the sign) of that saddle.", "rank": 1049, "start": 126064, "IsComparative": "1", "id": "st_1049"}, {"end": 126553, "text": "Both functions are illustrated in the rightmost image in Figure 4.4, in which the black hyperbolic curves represent the path of xc(t) and the color of the circles represents the sign of the face saddle at a given point (white and black circles are points with negative and positive values, respectively).", "rank": 1050, "start": 126249, "IsComparative": "0", "id": "st_1050"}, {"end": 126697, "text": "For case 13.5.2, the path traced by the curve xc(t) must intersect the isosurface tunnel twice, once at each of the roots t1 and t2 of f(xc(t)).", "rank": 1051, "start": 126553, "IsComparative": "0", "id": "st_1051"}, {"end": 126778, "text": "This implies that both saddle points xc(t1) and xc(t2) must lie inside the voxel.", "rank": 1052, "start": 126697, "IsComparative": "0", "id": "st_1052"}, {"end": 126874, "text": "This is not the case for 13.5.1 because the face saddle can cross the middle sheet at most once.", "rank": 1053, "start": 126778, "IsComparative": "1", "id": "st_1053"}, {"end": 126978, "text": "Therefore, it suffices to verify that both roots of f(xc(t)) and its saddle points are inside the voxel.", "rank": 1054, "start": 126874, "IsComparative": "1", "id": "st_1054"}, {"end": 127015, "text": "Algorithm 6 illustrates our solution.", "rank": 1055, "start": 126978, "IsComparative": "1", "id": "st_1055"}, {"end": 127192, "text": "Our algorithm is very simple, and does not require the computation of the critical points of the trilinear interpolant, or a detailed description of its behavior inside a voxel.", "rank": 1056, "start": 127015, "IsComparative": "1", "id": "st_1056"}, {"end": 127294, "text": "Our algorithm uses the ideas proposed by Chernyaev in order to fix an algorithmic problem in his work.", "rank": 1057, "start": 127192, "IsComparative": "1", "id": "st_1057"}, {"end": 127408, "text": "We have implemented and tested this solution on C-MC33 using over 10000 randomly generated instances of case 13.5.", "rank": 1058, "start": 127294, "IsComparative": "0", "id": "st_1058"}]}, {"paragraph_info": {"end": 127434, "start": 127408, "text": "4.5.1.1 Tunnel orientation", "rank": 288, "paragraph_comparative_number": 0, "entities": [], "id": "p_288"}, "sentences": [{"end": 127434, "text": "4.5.1.1 Tunnel orientation", "rank": 1059, "start": 127408, "IsComparative": "0", "id": "st_1059"}]}, {"paragraph_info": {"end": 128399, "start": 127434, "text": "To find the correct tunnel orientation one can use the sign of any point between the roots t1 and t2.This is because any point in this range must have the same sign as the critical points of the trilinear interpolant for case 13.5.2.This can be seen in the black path shown in the rightmost image in Figure 4.4 and from the graph in Figure 4.5.All points between roots t1 and t2 will have the same sign, which is the sign of the interior of the tunnel.Thus, we compare the sign of f((t1 + t2)/2) with the sign of both vertices of the voxel diagonal which is inside the tunnel.The tunnel will face the vertex with the same sign as f((t1 + t2)/2), whereas the other vertex must be isolated from all cube vertices.Figure 4.9 illustrates this scenario.Note that Lopes and Brodlie <98> used the sign of the critical points of the trilinear interpolant to retrieve the correct tunnel orientation.We provide a different solution that fits nicely with Chernyaevs framework.", "rank": 289, "paragraph_comparative_number": 2, "entities": [], "id": "p_289"}, "sentences": [{"end": 127535, "text": "To find the correct tunnel orientation one can use the sign of any point between the roots t1 and t2.", "rank": 1060, "start": 127434, "IsComparative": "1", "id": "st_1060"}, {"end": 127667, "text": "This is because any point in this range must have the same sign as the critical points of the trilinear interpolant for case 13.5.2.", "rank": 1061, "start": 127535, "IsComparative": "0", "id": "st_1061"}, {"end": 127778, "text": "This can be seen in the black path shown in the rightmost image in Figure 4.4 and from the graph in Figure 4.5.", "rank": 1062, "start": 127667, "IsComparative": "0", "id": "st_1062"}, {"end": 127886, "text": "All points between roots t1 and t2 will have the same sign, which is the sign of the interior of the tunnel.", "rank": 1063, "start": 127778, "IsComparative": "0", "id": "st_1063"}, {"end": 128010, "text": "Thus, we compare the sign of f((t1 + t2)/2) with the sign of both vertices of the voxel diagonal which is inside the tunnel.", "rank": 1064, "start": 127886, "IsComparative": "1", "id": "st_1064"}, {"end": 128145, "text": "The tunnel will face the vertex with the same sign as f((t1 + t2)/2), whereas the other vertex must be isolated from all cube vertices.", "rank": 1065, "start": 128010, "IsComparative": "0", "id": "st_1065"}, {"end": 128182, "text": "Figure 4.9 illustrates this scenario.", "rank": 1066, "start": 128145, "IsComparative": "0", "id": "st_1066"}, {"end": 128324, "text": "Note that Lopes and Brodlie <98> used the sign of the critical points of the trilinear interpolant to retrieve the correct tunnel orientation.", "rank": 1067, "start": 128182, "IsComparative": "0", "id": "st_1067"}, {"end": 128399, "text": "We provide a different solution that fits nicely with Chernyaevs framework.", "rank": 1068, "start": 128324, "IsComparative": "0", "id": "st_1068"}]}, {"paragraph_info": {"end": 128611, "start": 128399, "text": "Figure 4.9.Solution to the orientation problem.The black dots represent regions with positive scalar values.The cutting-plane location is at (t1 +t2)/2.The sign of f((t1 +t2)/2) determines the tunnel orientation.", "rank": 290, "paragraph_comparative_number": 0, "entities": [], "id": "p_290"}, "sentences": [{"end": 128410, "text": "Figure 4.9.", "rank": 1069, "start": 128399, "IsComparative": "0", "id": "st_1069"}, {"end": 128446, "text": "Solution to the orientation problem.", "rank": 1070, "start": 128410, "IsComparative": "0", "id": "st_1070"}, {"end": 128507, "text": "The black dots represent regions with positive scalar values.", "rank": 1071, "start": 128446, "IsComparative": "0", "id": "st_1071"}, {"end": 128551, "text": "The cutting-plane location is at (t1 +t2)/2.", "rank": 1072, "start": 128507, "IsComparative": "0", "id": "st_1072"}, {"end": 128611, "text": "The sign of f((t1 +t2)/2) determines the tunnel orientation.", "rank": 1073, "start": 128551, "IsComparative": "0", "id": "st_1073"}]}, {"paragraph_info": {"end": 128647, "start": 128611, "text": "4.5.2 Issue II  Nonmanifold Surfaces", "rank": 291, "paragraph_comparative_number": 0, "entities": [], "id": "p_291"}, "sentences": [{"end": 128647, "text": "4.5.2 Issue II  Nonmanifold Surfaces", "rank": 1074, "start": 128611, "IsComparative": "0", "id": "st_1074"}]}, {"paragraph_info": {"end": 129172, "start": 128647, "text": "A possible solution to this problem involves postprocessing the mesh to remove nonman- ifold features.Although many works in the literature proposed methods for fixing meshes (see Ju <72> for an excellent survey), these are mainly focused on retrieving a valid manifold mesh.Topologically correct algorithms, on the other hand, require that the topology of the trilinear interpolant be preserved.In addition, mesh repairing techniques may mask implementation issues by fixing them, which complicates the verification process.", "rank": 292, "paragraph_comparative_number": 1, "entities": [], "id": "p_292"}, "sentences": [{"end": 128749, "text": "A possible solution to this problem involves postprocessing the mesh to remove nonman- ifold features.", "rank": 1075, "start": 128647, "IsComparative": "0", "id": "st_1075"}, {"end": 128922, "text": "Although many works in the literature proposed methods for fixing meshes (see Ju <72> for an excellent survey), these are mainly focused on retrieving a valid manifold mesh.", "rank": 1076, "start": 128749, "IsComparative": "0", "id": "st_1076"}, {"end": 129043, "text": "Topologically correct algorithms, on the other hand, require that the topology of the trilinear interpolant be preserved.", "rank": 1077, "start": 128922, "IsComparative": "0", "id": "st_1077"}, {"end": 129172, "text": "In addition, mesh repairing techniques may mask implementation issues by fixing them, which complicates the verification process.", "rank": 1078, "start": 129043, "IsComparative": "1", "id": "st_1078"}]}, {"paragraph_info": {"end": 129669, "start": 129172, "text": "We use an alternative approach that does not require any changes in the MC33 tri- angulation table.An interesting fact is that this problem has a low probability of being generated at random and an even lower probability of occurring in real-world datasets.In our tests, it occurred only once in 10000 randomly generated 5  5  5 scalar fields.Thus, instead of implementing the approach of Lopes and Brodlie, we adopt a different solution that takes advantage of the fact that this is a rare event.", "rank": 293, "paragraph_comparative_number": 2, "entities": [], "id": "p_293"}, "sentences": [{"end": 129271, "text": "We use an alternative approach that does not require any changes in the MC33 tri- angulation table.", "rank": 1079, "start": 129172, "IsComparative": "0", "id": "st_1079"}, {"end": 129429, "text": "An interesting fact is that this problem has a low probability of being generated at random and an even lower probability of occurring in real-world datasets.", "rank": 1080, "start": 129271, "IsComparative": "0", "id": "st_1080"}, {"end": 129515, "text": "In our tests, it occurred only once in 10000 randomly generated 5  5  5 scalar fields.", "rank": 1081, "start": 129429, "IsComparative": "1", "id": "st_1081"}, {"end": 129669, "text": "Thus, instead of implementing the approach of Lopes and Brodlie, we adopt a different solution that takes advantage of the fact that this is a rare event.", "rank": 1082, "start": 129515, "IsComparative": "1", "id": "st_1082"}]}, {"paragraph_info": {"end": 130491, "start": 129669, "text": "Nonmanifold surfaces are created when two adjacent voxels that share an ambiguous face have tunnels in the voxel interior.By splitting both voxels at the critical point of that face, the face ambiguity is eliminated <15>.To simplify the algorithm, we split not only the voxels sharing the ambiguous face but all faces in the volume slice that contains that face (see Figure 4.10).Assuming an input of size nnn, each subdivision will add n2 voxels to the grid.Assuming that k subdivisions are required, kn2 voxels will be added.In practice k = O(1), and thus kn2 = O(1)O(n2) = O(n2).This implies that the asymptotic size of the dataset does not change.This subdivision adds the degree of freedom necessary to eliminate the problem, making this implementation of the Marching Cubes 33 topologically correct (see Figure 4.7).", "rank": 294, "paragraph_comparative_number": 2, "entities": [], "id": "p_294"}, "sentences": [{"end": 129791, "text": "Nonmanifold surfaces are created when two adjacent voxels that share an ambiguous face have tunnels in the voxel interior.", "rank": 1083, "start": 129669, "IsComparative": "0", "id": "st_1083"}, {"end": 129890, "text": "By splitting both voxels at the critical point of that face, the face ambiguity is eliminated <15>.", "rank": 1084, "start": 129791, "IsComparative": "0", "id": "st_1084"}, {"end": 130049, "text": "To simplify the algorithm, we split not only the voxels sharing the ambiguous face but all faces in the volume slice that contains that face (see Figure 4.10).", "rank": 1085, "start": 129890, "IsComparative": "1", "id": "st_1085"}, {"end": 130128, "text": "Assuming an input of size nnn, each subdivision will add n2 voxels to the grid.", "rank": 1086, "start": 130049, "IsComparative": "1", "id": "st_1086"}, {"end": 130196, "text": "Assuming that k subdivisions are required, kn2 voxels will be added.", "rank": 1087, "start": 130128, "IsComparative": "0", "id": "st_1087"}, {"end": 130251, "text": "In practice k = O(1), and thus kn2 = O(1)O(n2) = O(n2).", "rank": 1088, "start": 130196, "IsComparative": "0", "id": "st_1088"}, {"end": 130320, "text": "This implies that the asymptotic size of the dataset does not change.", "rank": 1089, "start": 130251, "IsComparative": "0", "id": "st_1089"}, {"end": 130491, "text": "This subdivision adds the degree of freedom necessary to eliminate the problem, making this implementation of the Marching Cubes 33 topologically correct (see Figure 4.7).", "rank": 1090, "start": 130320, "IsComparative": "0", "id": "st_1090"}]}, {"paragraph_info": {"end": 130606, "start": 130491, "text": "Figure 4.10.Grid refinement.The slice of voxels containing the offending configuration is splitted into two slices.", "rank": 295, "paragraph_comparative_number": 1, "entities": [], "id": "p_295"}, "sentences": [{"end": 130503, "text": "Figure 4.10.", "rank": 1091, "start": 130491, "IsComparative": "0", "id": "st_1091"}, {"end": 130519, "text": "Grid refinement.", "rank": 1092, "start": 130503, "IsComparative": "0", "id": "st_1092"}, {"end": 130606, "text": "The slice of voxels containing the offending configuration is splitted into two slices.", "rank": 1093, "start": 130519, "IsComparative": "1", "id": "st_1093"}]}, {"paragraph_info": {"end": 130648, "start": 130606, "text": "4.5.3 Issue III  Cutting-plane Computation", "rank": 296, "paragraph_comparative_number": 0, "entities": [], "id": "p_296"}, "sentences": [{"end": 130648, "text": "4.5.3 Issue III  Cutting-plane Computation", "rank": 1094, "start": 130606, "IsComparative": "0", "id": "st_1094"}]}, {"paragraph_info": {"end": 130821, "start": 130648, "text": "Because this is a problem with the alternative method used in Lewiner et al., the issue can be avoided by replacing the use of talt with use of the originally proposed tmax.", "rank": 297, "paragraph_comparative_number": 0, "entities": [], "id": "p_297"}, "sentences": [{"end": 130821, "text": "Because this is a problem with the alternative method used in Lewiner et al., the issue can be avoided by replacing the use of talt with use of the originally proposed tmax.", "rank": 1095, "start": 130648, "IsComparative": "0", "id": "st_1095"}]}, {"paragraph_info": {"end": 130844, "start": 130821, "text": "4.5.4 Issue IV  Case 10", "rank": 298, "paragraph_comparative_number": 0, "entities": [], "id": "p_298"}, "sentences": [{"end": 130844, "text": "4.5.4 Issue IV  Case 10", "rank": 1096, "start": 130821, "IsComparative": "0", "id": "st_1096"}]}, {"paragraph_info": {"end": 131054, "start": 130844, "text": "Algorithm 7 illustrates the required steps for disambiguation on case 10.We fixed the MC33 implementation by adding the lines 16-20, which in the original implementation were replaced by the result case 10.1.1.", "rank": 299, "paragraph_comparative_number": 0, "entities": [], "id": "p_299"}, "sentences": [{"end": 130917, "text": "Algorithm 7 illustrates the required steps for disambiguation on case 10.", "rank": 1097, "start": 130844, "IsComparative": "0", "id": "st_1097"}, {"end": 131054, "text": "We fixed the MC33 implementation by adding the lines 16-20, which in the original implementation were replaced by the result case 10.1.1.", "rank": 1098, "start": 130917, "IsComparative": "0", "id": "st_1098"}]}, {"paragraph_info": {"end": 131094, "start": 131054, "text": "4.6 Experiments with Real-world Datasets", "rank": 300, "paragraph_comparative_number": 1, "entities": [], "id": "p_300"}, "sentences": [{"end": 131094, "text": "4.6 Experiments with Real-world Datasets", "rank": 1099, "start": 131054, "IsComparative": "1", "id": "st_1099"}]}, {"paragraph_info": {"end": 131438, "start": 131094, "text": "We now turn our attention to the practical impact of the topological correctness of the trilinear interpolant.For real-world datasets, the vast majority of Marching Cubes cases match the nonambiguous configurations, namely, 1, 2, 5, 8, and 9.This means that the standard Marching Cubes will match the topology generated by both MC33 and C-MC33.", "rank": 301, "paragraph_comparative_number": 2, "entities": [], "id": "p_301"}, "sentences": [{"end": 131204, "text": "We now turn our attention to the practical impact of the topological correctness of the trilinear interpolant.", "rank": 1100, "start": 131094, "IsComparative": "1", "id": "st_1100"}, {"end": 131336, "text": "For real-world datasets, the vast majority of Marching Cubes cases match the nonambiguous configurations, namely, 1, 2, 5, 8, and 9.", "rank": 1101, "start": 131204, "IsComparative": "1", "id": "st_1101"}, {"end": 131438, "text": "This means that the standard Marching Cubes will match the topology generated by both MC33 and C-MC33.", "rank": 1102, "start": 131336, "IsComparative": "0", "id": "st_1102"}]}, {"paragraph_info": {"end": 131476, "start": 131438, "text": "Algorithm 7 Algorithm for case 10 <28>", "rank": 302, "paragraph_comparative_number": 0, "entities": [], "id": "p_302"}, "sentences": [{"end": 131476, "text": "Algorithm 7 Algorithm for case 10 <28>", "rank": 1103, "start": 131438, "IsComparative": "0", "id": "st_1103"}]}, {"paragraph_info": {"end": 131607, "start": 131476, "text": "Nevertheless, for some voxels, there will be topological differences in the approaches, which may result in quite different meshes.", "rank": 303, "paragraph_comparative_number": 0, "entities": [], "id": "p_303"}, "sentences": [{"end": 131607, "text": "Nevertheless, for some voxels, there will be topological differences in the approaches, which may result in quite different meshes.", "rank": 1104, "start": 131476, "IsComparative": "0", "id": "st_1104"}]}, {"paragraph_info": {"end": 132541, "start": 131607, "text": "For the sake of completeness, in this section, we provide a qualitative analysis of these differences.The aneurysm dataset shown in Figure 4.11 provides an example of the dif- ferences.From left to right, Figure 4.11 shows meshes extracted with VTK Marching Cubes, MC33, and C-MC33.The VTK implementation is based on the work of Montani et al.<116> and does not have topological guarantees aside from consistency.These three implementations can be viewed as three distinct ways of extracting the mesh topology.Although only a handful of voxels differ among the implementations, for the aneurysm dataset, the consequence is that the (largest) main brain artery appears quite different in each interpretation.Because the dataset contains several thin features, subvoxel accuracy is required to connect the pieces of the blood vessels.As shown in the inset images in Figure 4.11, one voxel is sufficient to separate fairly large vessels.", "rank": 304, "paragraph_comparative_number": 5, "entities": [], "id": "p_304"}, "sentences": [{"end": 131709, "text": "For the sake of completeness, in this section, we provide a qualitative analysis of these differences.", "rank": 1105, "start": 131607, "IsComparative": "1", "id": "st_1105"}, {"end": 131792, "text": "The aneurysm dataset shown in Figure 4.11 provides an example of the dif- ferences.", "rank": 1106, "start": 131709, "IsComparative": "0", "id": "st_1106"}, {"end": 131889, "text": "From left to right, Figure 4.11 shows meshes extracted with VTK Marching Cubes, MC33, and C-MC33.", "rank": 1107, "start": 131792, "IsComparative": "1", "id": "st_1107"}, {"end": 131950, "text": "The VTK implementation is based on the work of Montani et al.", "rank": 1108, "start": 131889, "IsComparative": "0", "id": "st_1108"}, {"end": 132020, "text": "<116> and does not have topological guarantees aside from consistency.", "rank": 1109, "start": 131950, "IsComparative": "1", "id": "st_1109"}, {"end": 132117, "text": "These three implementations can be viewed as three distinct ways of extracting the mesh topology.", "rank": 1110, "start": 132020, "IsComparative": "1", "id": "st_1110"}, {"end": 132314, "text": "Although only a handful of voxels differ among the implementations, for the aneurysm dataset, the consequence is that the (largest) main brain artery appears quite different in each interpretation.", "rank": 1111, "start": 132117, "IsComparative": "0", "id": "st_1111"}, {"end": 132439, "text": "Because the dataset contains several thin features, subvoxel accuracy is required to connect the pieces of the blood vessels.", "rank": 1112, "start": 132314, "IsComparative": "0", "id": "st_1112"}, {"end": 132541, "text": "As shown in the inset images in Figure 4.11, one voxel is sufficient to separate fairly large vessels.", "rank": 1113, "start": 132439, "IsComparative": "1", "id": "st_1113"}]}, {"paragraph_info": {"end": 134706, "start": 132541, "text": "VTK and MC33 generate more extra connected components (shown in purple) than does C-MC33.Figure 4.12 shows the difference in the number of connected components components extracted by VTK implementation of Marching Cubes and the number of connected components extracted by our C-MC33 implementation.The right plot shows the difference in the number of connected components but between the MC33 and C-MC33 implementations.Negative values indicate that the C-MC33 implementation generated more connected components.Clearly, VTK generates more components that C-MC33.MC33 generates more components for most of the isovalues.generated by VTK and C-MC33 (left) and by MC33 and C-MC33 (right) as a function of the isovalue for the aneurysm dataset.Clearly, VTK produces substantially more connected components than C-MC33 (up to 2400 more components).The differences between MC33 and C-MC33 are not as large, although they are sufficient to disconnect important artery segments.In this example, MC33 generates more connected components than C-MC33 for most isovalues.The aneurysm dataset shows that changes in the topology of some voxels can impact the final surface.In this particular example, it is reasonable to assume that the blood vessels form a single connected component and thus that the dataset contains as few connected components as possible.Using this criterion, C-MC33 shows the best performance for most isovalues.We emphasize that the importance of the differences in the number of connected components ought to be measured.For instance, although in general C-MC33 produced fewer connected components, for some isovalues the number of components extracted with C-MC33 was greater than the number extracted using MC33.As it turns out, this is due to the presence of pieces of small components disconnected from the main artery.However, because small isolated components do not disconnect large portions of the datasets, contrary to what is shown in Figure 4.11, MC33 and C-MC33 could be considered only slightly different.A thorough study of impact of the different approaches for extracting mesh topology is desirable but is beyond the scope of this work.", "rank": 305, "paragraph_comparative_number": 5, "entities": [], "id": "p_305"}, "sentences": [{"end": 132630, "text": "VTK and MC33 generate more extra connected components (shown in purple) than does C-MC33.", "rank": 1114, "start": 132541, "IsComparative": "0", "id": "st_1114"}, {"end": 132840, "text": "Figure 4.12 shows the difference in the number of connected components components extracted by VTK implementation of Marching Cubes and the number of connected components extracted by our C-MC33 implementation.", "rank": 1115, "start": 132630, "IsComparative": "1", "id": "st_1115"}, {"end": 132962, "text": "The right plot shows the difference in the number of connected components but between the MC33 and C-MC33 implementations.", "rank": 1116, "start": 132840, "IsComparative": "1", "id": "st_1116"}, {"end": 133054, "text": "Negative values indicate that the C-MC33 implementation generated more connected components.", "rank": 1117, "start": 132962, "IsComparative": "0", "id": "st_1117"}, {"end": 133105, "text": "Clearly, VTK generates more components that C-MC33.", "rank": 1118, "start": 133054, "IsComparative": "0", "id": "st_1118"}, {"end": 133162, "text": "MC33 generates more components for most of the isovalues.", "rank": 1119, "start": 133105, "IsComparative": "0", "id": "st_1119"}, {"end": 133283, "text": "generated by VTK and C-MC33 (left) and by MC33 and C-MC33 (right) as a function of the isovalue for the aneurysm dataset.", "rank": 1120, "start": 133162, "IsComparative": "0", "id": "st_1120"}, {"end": 133386, "text": "Clearly, VTK produces substantially more connected components than C-MC33 (up to 2400 more components).", "rank": 1121, "start": 133283, "IsComparative": "0", "id": "st_1121"}, {"end": 133513, "text": "The differences between MC33 and C-MC33 are not as large, although they are sufficient to disconnect important artery segments.", "rank": 1122, "start": 133386, "IsComparative": "1", "id": "st_1122"}, {"end": 133602, "text": "In this example, MC33 generates more connected components than C-MC33 for most isovalues.", "rank": 1123, "start": 133513, "IsComparative": "0", "id": "st_1123"}, {"end": 133702, "text": "The aneurysm dataset shows that changes in the topology of some voxels can impact the final surface.", "rank": 1124, "start": 133602, "IsComparative": "0", "id": "st_1124"}, {"end": 133889, "text": "In this particular example, it is reasonable to assume that the blood vessels form a single connected component and thus that the dataset contains as few connected components as possible.", "rank": 1125, "start": 133702, "IsComparative": "0", "id": "st_1125"}, {"end": 133964, "text": "Using this criterion, C-MC33 shows the best performance for most isovalues.", "rank": 1126, "start": 133889, "IsComparative": "0", "id": "st_1126"}, {"end": 134075, "text": "We emphasize that the importance of the differences in the number of connected components ought to be measured.", "rank": 1127, "start": 133964, "IsComparative": "1", "id": "st_1127"}, {"end": 134268, "text": "For instance, although in general C-MC33 produced fewer connected components, for some isovalues the number of components extracted with C-MC33 was greater than the number extracted using MC33.", "rank": 1128, "start": 134075, "IsComparative": "0", "id": "st_1128"}, {"end": 134377, "text": "As it turns out, this is due to the presence of pieces of small components disconnected from the main artery.", "rank": 1129, "start": 134268, "IsComparative": "0", "id": "st_1129"}, {"end": 134572, "text": "However, because small isolated components do not disconnect large portions of the datasets, contrary to what is shown in Figure 4.11, MC33 and C-MC33 could be considered only slightly different.", "rank": 1130, "start": 134377, "IsComparative": "0", "id": "st_1130"}, {"end": 134706, "text": "A thorough study of impact of the different approaches for extracting mesh topology is desirable but is beyond the scope of this work.", "rank": 1131, "start": 134572, "IsComparative": "1", "id": "st_1131"}]}, {"paragraph_info": {"end": 134772, "start": 134706, "text": "The left plot shows the difference between the number of connected", "rank": 306, "paragraph_comparative_number": 1, "entities": [], "id": "p_306"}, "sentences": [{"end": 134772, "text": "The left plot shows the difference between the number of connected", "rank": 1132, "start": 134706, "IsComparative": "1", "id": "st_1132"}]}, {"paragraph_info": {"end": 135326, "start": 134772, "text": "The second problem is due to the extraction of nonmanifold features.The issue explained in Section 4.4.2 also pertains to real-world datasets.Figure 4.13 shows an example of a medical dataset in which the output of MC33 implementation is a nonmanifold surface.We have observed the same problem for certain isovalues of other commonly used datasets, such as the backpack and bonsai datasets.Nevertheless, in our experiments, this problem occurred rarely in the datasets tested: on average, one case of nonmanifold edges was found per 107 evaluated voxels.", "rank": 307, "paragraph_comparative_number": 2, "entities": [], "id": "p_307"}, "sentences": [{"end": 134840, "text": "The second problem is due to the extraction of nonmanifold features.", "rank": 1133, "start": 134772, "IsComparative": "1", "id": "st_1133"}, {"end": 134914, "text": "The issue explained in Section 4.4.2 also pertains to real-world datasets.", "rank": 1134, "start": 134840, "IsComparative": "0", "id": "st_1134"}, {"end": 135032, "text": "Figure 4.13 shows an example of a medical dataset in which the output of MC33 implementation is a nonmanifold surface.", "rank": 1135, "start": 134914, "IsComparative": "0", "id": "st_1135"}, {"end": 135162, "text": "We have observed the same problem for certain isovalues of other commonly used datasets, such as the backpack and bonsai datasets.", "rank": 1136, "start": 135032, "IsComparative": "0", "id": "st_1136"}, {"end": 135326, "text": "Nevertheless, in our experiments, this problem occurred rarely in the datasets tested: on average, one case of nonmanifold edges was found per 107 evaluated voxels.", "rank": 1137, "start": 135162, "IsComparative": "1", "id": "st_1137"}]}, {"paragraph_info": {"end": 135340, "start": 135326, "text": "4.7 Conclusion", "rank": 308, "paragraph_comparative_number": 0, "entities": [], "id": "p_308"}, "sentences": [{"end": 135340, "text": "4.7 Conclusion", "rank": 1138, "start": 135326, "IsComparative": "0", "id": "st_1138"}]}, {"paragraph_info": {"end": 135750, "start": 135340, "text": "In this chapter, we discussed in detail three issues with the Marching Cubes 33 algorithm and one nontrivial issue with its implementation.We presented solutions for the issues raised and implement them into C-MC33, a topologically correct version of MC33.In addition, we made our results reproducible so that the reader can easily study, explore, and use the results presented here for his or her own purpose.", "rank": 309, "paragraph_comparative_number": 2, "entities": [], "id": "p_309"}, "sentences": [{"end": 135479, "text": "In this chapter, we discussed in detail three issues with the Marching Cubes 33 algorithm and one nontrivial issue with its implementation.", "rank": 1139, "start": 135340, "IsComparative": "1", "id": "st_1139"}, {"end": 135596, "text": "We presented solutions for the issues raised and implement them into C-MC33, a topologically correct version of MC33.", "rank": 1140, "start": 135479, "IsComparative": "0", "id": "st_1140"}, {"end": 135750, "text": "In addition, we made our results reproducible so that the reader can easily study, explore, and use the results presented here for his or her own purpose.", "rank": 1141, "start": 135596, "IsComparative": "1", "id": "st_1141"}]}, {"paragraph_info": {"end": 135803, "start": 135750, "text": "CHAPTER 5 VERIFYING DIRECT VOLUME RENDERING ALGORITHM", "rank": 310, "paragraph_comparative_number": 0, "entities": [], "id": "p_310"}, "sentences": [{"end": 135803, "text": "CHAPTER 5 VERIFYING DIRECT VOLUME RENDERING ALGORITHM", "rank": 1142, "start": 135750, "IsComparative": "0", "id": "st_1142"}]}, {"paragraph_info": {"end": 137428, "start": 135803, "text": "In the last several decades, the visualization and graphics communities have developed a wide range of volume rendering techniques.As they are used in several different disciplines of science, and thus form a basis for new scientific insights, it is essential to assess their reliability and identify errors.Furthermore, the increasing complexity of volume rendering algorithms makes the correctness of the algorithm itself as well as its potentially error-prone implementations complementary and equally important issues.Being that volume rendering is essential in areas such as medical imaging, where accuracy and precision play a crucial role, a formal methodology for assessing correctness is highly desirable <76, 137>.While verification has been widely adopted in many different branches of computer science  see model checking <25>, fuzzing <56>, and convergence analysis <146>  there has not been signifi- cant work accomplished on a formalized praxis for asserting the correctness of visualization techniques.We use the word verification in the same sense as Babuska and Oden <3>: verification is the process of determining if a computational model, and its corresponding numerical solution, obtained by discretizing the mathematical model (with corresponding exact solution) of a physical event, and the code implementing the computational model can be used to represent the mathematical model of the event with sufficient accuracy <3>.The presented methodology is based on order of accuracy and convergence analysis <146> which we can apply after deriving the expected behavior of the algorithms under observation.", "rank": 311, "paragraph_comparative_number": 3, "entities": [], "id": "p_311"}, "sentences": [{"end": 135934, "text": "In the last several decades, the visualization and graphics communities have developed a wide range of volume rendering techniques.", "rank": 1143, "start": 135803, "IsComparative": "0", "id": "st_1143"}, {"end": 136111, "text": "As they are used in several different disciplines of science, and thus form a basis for new scientific insights, it is essential to assess their reliability and identify errors.", "rank": 1144, "start": 135934, "IsComparative": "0", "id": "st_1144"}, {"end": 136325, "text": "Furthermore, the increasing complexity of volume rendering algorithms makes the correctness of the algorithm itself as well as its potentially error-prone implementations complementary and equally important issues.", "rank": 1145, "start": 136111, "IsComparative": "1", "id": "st_1145"}, {"end": 136527, "text": "Being that volume rendering is essential in areas such as medical imaging, where accuracy and precision play a crucial role, a formal methodology for assessing correctness is highly desirable <76, 137>.", "rank": 1146, "start": 136325, "IsComparative": "0", "id": "st_1146"}, {"end": 136821, "text": "While verification has been widely adopted in many different branches of computer science  see model checking <25>, fuzzing <56>, and convergence analysis <146>  there has not been signifi- cant work accomplished on a formalized praxis for asserting the correctness of visualization techniques.", "rank": 1147, "start": 136527, "IsComparative": "0", "id": "st_1147"}, {"end": 137249, "text": "We use the word verification in the same sense as Babuska and Oden <3>: verification is the process of determining if a computational model, and its corresponding numerical solution, obtained by discretizing the mathematical model (with corresponding exact solution) of a physical event, and the code implementing the computational model can be used to represent the mathematical model of the event with sufficient accuracy <3>.", "rank": 1148, "start": 136821, "IsComparative": "1", "id": "st_1148"}, {"end": 137428, "text": "The presented methodology is based on order of accuracy and convergence analysis <146> which we can apply after deriving the expected behavior of the algorithms under observation.", "rank": 1149, "start": 137249, "IsComparative": "1", "id": "st_1149"}]}, {"paragraph_info": {"end": 138883, "start": 137428, "text": "To allow the verification of volume rendering algorithms, we start with an analysis of the volume rendering integral and the most common discretization of this continuous model  Riemman summation.This analysis gives us insight into the expected behavior of the observed algorithms, which is essential to perform verification <67>.In this sense, our main assumption, serving as a foundation for the proposed verification approach, is that discretization errors of the implementations under verification should behave as the errors introduced by the discretization of the volume rendering integral.Based on this, we can mathematically derive the expected behavior from the discretization of the volume rendering integral and verify existing implementations through convergence analysis by comparing their actual behavior to the expected behavior.Based on the results of this comparison, we can assess the correctness of the implementation under verification.To get further insights about deviations from the expected behavior, we present an investigation of the sensitivity of this method.We can demonstrate that our methodology is capable of increasing the confidence in volume rendering algorithms.To our knowledge, the proposed approach is the first step towards the verification of DVR algorithms.Thus, it can be seen as an important contribution towards a formal verification methodology of volume rendering techniques <143>.Our main contributions are:", "rank": 312, "paragraph_comparative_number": 8, "entities": [], "id": "p_312"}, "sentences": [{"end": 137624, "text": "To allow the verification of volume rendering algorithms, we start with an analysis of the volume rendering integral and the most common discretization of this continuous model  Riemman summation.", "rank": 1150, "start": 137428, "IsComparative": "1", "id": "st_1150"}, {"end": 137758, "text": "This analysis gives us insight into the expected behavior of the observed algorithms, which is essential to perform verification <67>.", "rank": 1151, "start": 137624, "IsComparative": "1", "id": "st_1151"}, {"end": 138024, "text": "In this sense, our main assumption, serving as a foundation for the proposed verification approach, is that discretization errors of the implementations under verification should behave as the errors introduced by the discretization of the volume rendering integral.", "rank": 1152, "start": 137758, "IsComparative": "1", "id": "st_1152"}, {"end": 138272, "text": "Based on this, we can mathematically derive the expected behavior from the discretization of the volume rendering integral and verify existing implementations through convergence analysis by comparing their actual behavior to the expected behavior.", "rank": 1153, "start": 138024, "IsComparative": "1", "id": "st_1153"}, {"end": 138384, "text": "Based on the results of this comparison, we can assess the correctness of the implementation under verification.", "rank": 1154, "start": 138272, "IsComparative": "0", "id": "st_1154"}, {"end": 138515, "text": "To get further insights about deviations from the expected behavior, we present an investigation of the sensitivity of this method.", "rank": 1155, "start": 138384, "IsComparative": "0", "id": "st_1155"}, {"end": 138626, "text": "We can demonstrate that our methodology is capable of increasing the confidence in volume rendering algorithms.", "rank": 1156, "start": 138515, "IsComparative": "1", "id": "st_1156"}, {"end": 138727, "text": "To our knowledge, the proposed approach is the first step towards the verification of DVR algorithms.", "rank": 1157, "start": 138626, "IsComparative": "1", "id": "st_1157"}, {"end": 138856, "text": "Thus, it can be seen as an important contribution towards a formal verification methodology of volume rendering techniques <143>.", "rank": 1158, "start": 138727, "IsComparative": "1", "id": "st_1158"}, {"end": 138883, "text": "Our main contributions are:", "rank": 1159, "start": 138856, "IsComparative": "1", "id": "st_1159"}]}, {"paragraph_info": {"end": 139189, "start": 138883, "text": "we derive the theoretical foundations necessary for verifying volume rendering with order of accuracy and convergence analysis.We analyze the volume rendering integral and its (common) discretization using Riemann summation to derive an algorithms expected behavior when being subject to parameter changes;", "rank": 313, "paragraph_comparative_number": 1, "entities": [], "id": "p_313"}, "sentences": [{"end": 139010, "text": "we derive the theoretical foundations necessary for verifying volume rendering with order of accuracy and convergence analysis.", "rank": 1160, "start": 138883, "IsComparative": "0", "id": "st_1160"}, {"end": 139189, "text": "We analyze the volume rendering integral and its (common) discretization using Riemann summation to derive an algorithms expected behavior when being subject to parameter changes;", "rank": 1161, "start": 139010, "IsComparative": "1", "id": "st_1161"}]}, {"paragraph_info": {"end": 139420, "start": 139189, "text": "we explain how to exploit these theoretical foundations to perform a practical verifi- cation of implemented volume rendering algorithms, such that it can be easily used for the verification of existing volume rendering frameworks;", "rank": 314, "paragraph_comparative_number": 0, "entities": [], "id": "p_314"}, "sentences": [{"end": 139420, "text": "we explain how to exploit these theoretical foundations to perform a practical verifi- cation of implemented volume rendering algorithms, such that it can be easily used for the verification of existing volume rendering frameworks;", "rank": 1162, "start": 139189, "IsComparative": "0", "id": "st_1162"}]}, {"paragraph_info": {"end": 139695, "start": 139420, "text": "we discuss the limitations of the proposed concepts by analyzing frequently occurring errors and by documenting those errors we could identify when applying the presented methodology to two widely used volume rendering frameworks, VTK <155> and Voreen <113> (see Figure 5.1).", "rank": 315, "paragraph_comparative_number": 0, "entities": [], "id": "p_315"}, "sentences": [{"end": 139695, "text": "we discuss the limitations of the proposed concepts by analyzing frequently occurring errors and by documenting those errors we could identify when applying the presented methodology to two widely used volume rendering frameworks, VTK <155> and Voreen <113> (see Figure 5.1).", "rank": 1163, "start": 139420, "IsComparative": "0", "id": "st_1163"}]}, {"paragraph_info": {"end": 139711, "start": 139695, "text": "5.1 Related Work", "rank": 316, "paragraph_comparative_number": 0, "entities": [], "id": "p_316"}, "sentences": [{"end": 139711, "text": "5.1 Related Work", "rank": 1164, "start": 139695, "IsComparative": "0", "id": "st_1164"}]}, {"paragraph_info": {"end": 140530, "start": 139711, "text": "Critical decisions in fields such as medical imaging often rely on images produced by volume rendering algorithms, where it is of utmost importance that the results are correct <34>.The multitude of algorithms components and their interactions make this guarantee a challenge.As a consequence, many authors focus on specific aspects of the problem such as numerical aspects of the evaluation of the volume rendering integral, shading, transfer functions, and interpolation schemes.The quality of volume rendering has always been of central interest to the community, and relying on visual inspection is a common practice.Meissner et al.<111> evaluate volume rendering techniques using the human visual system as a reference while, more recently, Smelyanskiy et al.<161> present a domain expert guided comparison scheme.", "rank": 317, "paragraph_comparative_number": 1, "entities": [], "id": "p_317"}, "sentences": [{"end": 139893, "text": "Critical decisions in fields such as medical imaging often rely on images produced by volume rendering algorithms, where it is of utmost importance that the results are correct <34>.", "rank": 1165, "start": 139711, "IsComparative": "0", "id": "st_1165"}, {"end": 139987, "text": "The multitude of algorithms components and their interactions make this guarantee a challenge.", "rank": 1166, "start": 139893, "IsComparative": "1", "id": "st_1166"}, {"end": 140192, "text": "As a consequence, many authors focus on specific aspects of the problem such as numerical aspects of the evaluation of the volume rendering integral, shading, transfer functions, and interpolation schemes.", "rank": 1167, "start": 139987, "IsComparative": "0", "id": "st_1167"}, {"end": 140332, "text": "The quality of volume rendering has always been of central interest to the community, and relying on visual inspection is a common practice.", "rank": 1168, "start": 140192, "IsComparative": "0", "id": "st_1168"}, {"end": 140347, "text": "Meissner et al.", "rank": 1169, "start": 140332, "IsComparative": "0", "id": "st_1169"}, {"end": 140475, "text": "<111> evaluate volume rendering techniques using the human visual system as a reference while, more recently, Smelyanskiy et al.", "rank": 1170, "start": 140347, "IsComparative": "0", "id": "st_1170"}, {"end": 140530, "text": "<161> present a domain expert guided comparison scheme.", "rank": 1171, "start": 140475, "IsComparative": "0", "id": "st_1171"}]}, {"paragraph_info": {"end": 140704, "start": 140530, "text": "While those approaches are valuable, the need for a more systematic evaluation is discussed in several papers <55, 70, 71, 76>.See Pommert and H ohne <137, 138> for a survey.", "rank": 318, "paragraph_comparative_number": 1, "entities": [], "id": "p_318"}, "sentences": [{"end": 140657, "text": "While those approaches are valuable, the need for a more systematic evaluation is discussed in several papers <55, 70, 71, 76>.", "rank": 1172, "start": 140530, "IsComparative": "0", "id": "st_1172"}, {"end": 140704, "text": "See Pommert and H ohne <137, 138> for a survey.", "rank": 1173, "start": 140657, "IsComparative": "1", "id": "st_1173"}]}, {"paragraph_info": {"end": 141681, "start": 140704, "text": "Among several aspects to consider in the correctness of volume rendering algorithms, one of the most important is the approximation of the volume rendering integral.The solution with linearly interpolated attributes is presented by Williams and Max <188>, with further discussions on its numerical stability by Williams et al.<189>.Interpolant approximations and errors <39, 114, 115, 128>, gradient computation <179> and opacity correction <90> are also the subject of analysis with regard to numerical accuracy.The idea of pre-integration enables high-quality, accurate and efficient algorithms using graphics hardware <42, 85, 145>.Similarly, VTK currently uses partial pre-integration, in particular for unstructured grids <119>.Note that although there has been work on high-accuracy volume rendering  to the best of our knowledge  none of these approaches attempted to evaluate the convergence rate of the standard discretization process of the volume rendering integral.", "rank": 319, "paragraph_comparative_number": 4, "entities": [], "id": "p_319"}, "sentences": [{"end": 140869, "text": "Among several aspects to consider in the correctness of volume rendering algorithms, one of the most important is the approximation of the volume rendering integral.", "rank": 1174, "start": 140704, "IsComparative": "1", "id": "st_1174"}, {"end": 141030, "text": "The solution with linearly interpolated attributes is presented by Williams and Max <188>, with further discussions on its numerical stability by Williams et al.", "rank": 1175, "start": 140869, "IsComparative": "1", "id": "st_1175"}, {"end": 141036, "text": "<189>.", "rank": 1176, "start": 141030, "IsComparative": "1", "id": "st_1176"}, {"end": 141217, "text": "Interpolant approximations and errors <39, 114, 115, 128>, gradient computation <179> and opacity correction <90> are also the subject of analysis with regard to numerical accuracy.", "rank": 1177, "start": 141036, "IsComparative": "1", "id": "st_1177"}, {"end": 141339, "text": "The idea of pre-integration enables high-quality, accurate and efficient algorithms using graphics hardware <42, 85, 145>.", "rank": 1178, "start": 141217, "IsComparative": "0", "id": "st_1178"}, {"end": 141437, "text": "Similarly, VTK currently uses partial pre-integration, in particular for unstructured grids <119>.", "rank": 1179, "start": 141339, "IsComparative": "0", "id": "st_1179"}, {"end": 141681, "text": "Note that although there has been work on high-accuracy volume rendering  to the best of our knowledge  none of these approaches attempted to evaluate the convergence rate of the standard discretization process of the volume rendering integral.", "rank": 1180, "start": 141437, "IsComparative": "0", "id": "st_1180"}]}, {"paragraph_info": {"end": 142530, "start": 141681, "text": "The use of a verification framework has only recently been discussed in scientific vi- sualization, despite the vast literature on verification in computer science.Globus and Uselton <55> first pointed out the need to verify not only visualization algorithms but also their implementations, and Kirby and Silva suggested a research program around verifica- tion <76>.The verification of isosurface algorithms was discussed by Etiene et al.<45, 46>, where a systematic evaluation identified and corrected problems in several implementations of isosurface extraction techniques.Zheng et al.<194> address CT reconstruction and interpolation errors in direct volume rendering algorithms using a verifiable framework based on projection errors.In contrast, our work focuses on the verification of the final image produced through direct volume rendering.", "rank": 320, "paragraph_comparative_number": 1, "entities": [], "id": "p_320"}, "sentences": [{"end": 141845, "text": "The use of a verification framework has only recently been discussed in scientific vi- sualization, despite the vast literature on verification in computer science.", "rank": 1181, "start": 141681, "IsComparative": "0", "id": "st_1181"}, {"end": 142048, "text": "Globus and Uselton <55> first pointed out the need to verify not only visualization algorithms but also their implementations, and Kirby and Silva suggested a research program around verifica- tion <76>.", "rank": 1182, "start": 141845, "IsComparative": "1", "id": "st_1182"}, {"end": 142120, "text": "The verification of isosurface algorithms was discussed by Etiene et al.", "rank": 1183, "start": 142048, "IsComparative": "0", "id": "st_1183"}, {"end": 142257, "text": "<45, 46>, where a systematic evaluation identified and corrected problems in several implementations of isosurface extraction techniques.", "rank": 1184, "start": 142120, "IsComparative": "0", "id": "st_1184"}, {"end": 142269, "text": "Zheng et al.", "rank": 1185, "start": 142257, "IsComparative": "0", "id": "st_1185"}, {"end": 142420, "text": "<194> address CT reconstruction and interpolation errors in direct volume rendering algorithms using a verifiable framework based on projection errors.", "rank": 1186, "start": 142269, "IsComparative": "0", "id": "st_1186"}, {"end": 142530, "text": "In contrast, our work focuses on the verification of the final image produced through direct volume rendering.", "rank": 1187, "start": 142420, "IsComparative": "0", "id": "st_1187"}]}, {"paragraph_info": {"end": 142546, "start": 142530, "text": "5.2 Verification", "rank": 321, "paragraph_comparative_number": 0, "entities": [], "id": "p_321"}, "sentences": [{"end": 142546, "text": "5.2 Verification", "rank": 1188, "start": 142530, "IsComparative": "0", "id": "st_1188"}]}, {"paragraph_info": {"end": 143703, "start": 142546, "text": "Before presenting our verification procedure, let us consider four of the techniques used for code verification in computational science <146>: expert judgment, a procedure in which a field expert determines if the output of an implementation is correct by evaluating the results; error quantification, which is the quantification of the discretization errors when compared to an analytical solution, a benchmark solution or some ground-truth; convergence analysis, a procedure in which one evaluates if the discretization errors converge to zero as a function of some parameter; and order of accuracy, a procedure where one evaluates if the discretization errors decrease according to the expected rate.In this list, the expert judgment is the least rigorous test, followed by error quantification and convergence analysis.Order of accuracy is widely recognized as the most rigorous code verification tool <3, 80, 143, 146>.In this chapter, we focus on the latter two methods, namely, convergence analysis and order of accuracy.Before we dive into these methods, let us first consider some of the limitation of the expert analysis and error quantification.", "rank": 322, "paragraph_comparative_number": 2, "entities": [], "id": "p_322"}, "sentences": [{"end": 143250, "text": "Before presenting our verification procedure, let us consider four of the techniques used for code verification in computational science <146>: expert judgment, a procedure in which a field expert determines if the output of an implementation is correct by evaluating the results; error quantification, which is the quantification of the discretization errors when compared to an analytical solution, a benchmark solution or some ground-truth; convergence analysis, a procedure in which one evaluates if the discretization errors converge to zero as a function of some parameter; and order of accuracy, a procedure where one evaluates if the discretization errors decrease according to the expected rate.", "rank": 1189, "start": 142546, "IsComparative": "1", "id": "st_1189"}, {"end": 143370, "text": "In this list, the expert judgment is the least rigorous test, followed by error quantification and convergence analysis.", "rank": 1190, "start": 143250, "IsComparative": "0", "id": "st_1190"}, {"end": 143471, "text": "Order of accuracy is widely recognized as the most rigorous code verification tool <3, 80, 143, 146>.", "rank": 1191, "start": 143370, "IsComparative": "0", "id": "st_1191"}, {"end": 143575, "text": "In this chapter, we focus on the latter two methods, namely, convergence analysis and order of accuracy.", "rank": 1192, "start": 143471, "IsComparative": "1", "id": "st_1192"}, {"end": 143703, "text": "Before we dive into these methods, let us first consider some of the limitation of the expert analysis and error quantification.", "rank": 1193, "start": 143575, "IsComparative": "0", "id": "st_1193"}]}, {"paragraph_info": {"end": 145886, "start": 143703, "text": "In visualization, expert analysis and error quantification are, to the best of our knowl- edge, the only two verification tools previously employed for verification of volume rendering techniques <111, 114, 161>.Whereas it is easy to envision situations where an expert may fail to predict a code mistake, it is more difficult to see when error quantification fails.We devise the following experiment to understand potential limitations of both approaches.We artificially introduced a code mistake in a volume rendering implemen- tation: the trilinear interpolation was changed from p(x, y, z) = Axyz + Bxy(1  z) + ...to p(x, y, z) = Axyz + Axy(1  z) + ....We then used this implementation to render an image whose analytical solution is known.Finally, we compute the maximum error between the rendered and the analytical solution, which in this case is 3.6103.How can one decide if this value is good enough?Does the sampling distance d or the input scalar field s(x, y, z) give us enough data to make an informed decision?In this particular case, the correct interpolant generates an image with maximum error of 3.4  103: the two images are very similar by this metric.Also, it may be challenging, even for an expert, to notice such a small deviation, as shown in Figure 5.2.On top of this, the maximum errors for another code mistake could be even smaller.(We point out that this particular case can be uncovered by playing around with the data or other ad hoc methods.The goal is to show that error quantification can also fail to predict code mistakes, even for a severe bug.)On the other hand, we will have enough information to make such a decision if one observes how errors behave when input parameters change instead of quantifying them from one image.The convergence and order of accuracy tests work in this way, and they are the focus of this chapter.We advocate the use of convergence and order of accuracy verification not as a replacement but as an extension of the current testing pipeline.Note that these are not the only approaches for assessing correctness of computer code.As mentioned before, verification is well-developed in computer science <25, 47, 56, 192>.", "rank": 323, "paragraph_comparative_number": 8, "entities": [], "id": "p_323"}, "sentences": [{"end": 143915, "text": "In visualization, expert analysis and error quantification are, to the best of our knowl- edge, the only two verification tools previously employed for verification of volume rendering techniques <111, 114, 161>.", "rank": 1194, "start": 143703, "IsComparative": "1", "id": "st_1194"}, {"end": 144069, "text": "Whereas it is easy to envision situations where an expert may fail to predict a code mistake, it is more difficult to see when error quantification fails.", "rank": 1195, "start": 143915, "IsComparative": "1", "id": "st_1195"}, {"end": 144159, "text": "We devise the following experiment to understand potential limitations of both approaches.", "rank": 1196, "start": 144069, "IsComparative": "0", "id": "st_1196"}, {"end": 144319, "text": "We artificially introduced a code mistake in a volume rendering implemen- tation: the trilinear interpolation was changed from p(x, y, z) = Axyz + Bxy(1  z) + .", "rank": 1197, "start": 144159, "IsComparative": "0", "id": "st_1197"}, {"end": 144320, "text": ".", "rank": 1198, "start": 144319, "IsComparative": "0", "id": "st_1198"}, {"end": 144321, "text": ".", "rank": 1199, "start": 144320, "IsComparative": "0", "id": "st_1199"}, {"end": 144357, "text": "to p(x, y, z) = Axyz + Axy(1  z) + .", "rank": 1200, "start": 144321, "IsComparative": "1", "id": "st_1200"}, {"end": 144358, "text": ".", "rank": 1201, "start": 144357, "IsComparative": "0", "id": "st_1201"}, {"end": 144360, "text": "..", "rank": 1202, "start": 144358, "IsComparative": "1", "id": "st_1202"}, {"end": 144447, "text": "We then used this implementation to render an image whose analytical solution is known.", "rank": 1203, "start": 144360, "IsComparative": "0", "id": "st_1203"}, {"end": 144564, "text": "Finally, we compute the maximum error between the rendered and the analytical solution, which in this case is 3.6103.", "rank": 1204, "start": 144447, "IsComparative": "0", "id": "st_1204"}, {"end": 144612, "text": "How can one decide if this value is good enough?", "rank": 1205, "start": 144564, "IsComparative": "0", "id": "st_1205"}, {"end": 144727, "text": "Does the sampling distance d or the input scalar field s(x, y, z) give us enough data to make an informed decision?", "rank": 1206, "start": 144612, "IsComparative": "1", "id": "st_1206"}, {"end": 144874, "text": "In this particular case, the correct interpolant generates an image with maximum error of 3.4  103: the two images are very similar by this metric.", "rank": 1207, "start": 144727, "IsComparative": "1", "id": "st_1207"}, {"end": 144980, "text": "Also, it may be challenging, even for an expert, to notice such a small deviation, as shown in Figure 5.2.", "rank": 1208, "start": 144874, "IsComparative": "0", "id": "st_1208"}, {"end": 145062, "text": "On top of this, the maximum errors for another code mistake could be even smaller.", "rank": 1209, "start": 144980, "IsComparative": "0", "id": "st_1209"}, {"end": 145175, "text": "(We point out that this particular case can be uncovered by playing around with the data or other ad hoc methods.", "rank": 1210, "start": 145062, "IsComparative": "0", "id": "st_1210"}, {"end": 145284, "text": "The goal is to show that error quantification can also fail to predict code mistakes, even for a severe bug.)", "rank": 1211, "start": 145175, "IsComparative": "1", "id": "st_1211"}, {"end": 145465, "text": "On the other hand, we will have enough information to make such a decision if one observes how errors behave when input parameters change instead of quantifying them from one image.", "rank": 1212, "start": 145284, "IsComparative": "1", "id": "st_1212"}, {"end": 145566, "text": "The convergence and order of accuracy tests work in this way, and they are the focus of this chapter.", "rank": 1213, "start": 145465, "IsComparative": "0", "id": "st_1213"}, {"end": 145709, "text": "We advocate the use of convergence and order of accuracy verification not as a replacement but as an extension of the current testing pipeline.", "rank": 1214, "start": 145566, "IsComparative": "0", "id": "st_1214"}, {"end": 145796, "text": "Note that these are not the only approaches for assessing correctness of computer code.", "rank": 1215, "start": 145709, "IsComparative": "0", "id": "st_1215"}, {"end": 145886, "text": "As mentioned before, verification is well-developed in computer science <25, 47, 56, 192>.", "rank": 1216, "start": 145796, "IsComparative": "0", "id": "st_1216"}]}, {"paragraph_info": {"end": 146205, "start": 145886, "text": "We apply verification in the spirit of Babuska and Odens procedure, which we summa- rize in Figure 5.3 <3>.It starts with a mathematical evaluation of the expected convergence compare the sequence of observed outputs against expected errors to evaluate if expected and observed convergence match (Sections 5.5 and 5.6).", "rank": 324, "paragraph_comparative_number": 1, "entities": [], "id": "p_324"}, "sentences": [{"end": 145993, "text": "We apply verification in the spirit of Babuska and Odens procedure, which we summa- rize in Figure 5.3 <3>.", "rank": 1217, "start": 145886, "IsComparative": "0", "id": "st_1217"}, {"end": 146205, "text": "It starts with a mathematical evaluation of the expected convergence compare the sequence of observed outputs against expected errors to evaluate if expected and observed convergence match (Sections 5.5 and 5.6).", "rank": 1218, "start": 145993, "IsComparative": "1", "id": "st_1218"}]}, {"paragraph_info": {"end": 146230, "start": 146205, "text": "5.3 Discretization Errors", "rank": 325, "paragraph_comparative_number": 0, "entities": [], "id": "p_325"}, "sentences": [{"end": 146230, "text": "5.3 Discretization Errors", "rank": 1219, "start": 146205, "IsComparative": "0", "id": "st_1219"}]}, {"paragraph_info": {"end": 146454, "start": 146230, "text": "As can be seen, the error in the pixel approximation decays linearly with the pixel size.Equation (5.35) contains all the errors we examine for verification purposes, and it will be the basis for our analysis in Section 5.4.", "rank": 326, "paragraph_comparative_number": 1, "entities": [], "id": "p_326"}, "sentences": [{"end": 146319, "text": "As can be seen, the error in the pixel approximation decays linearly with the pixel size.", "rank": 1220, "start": 146230, "IsComparative": "0", "id": "st_1220"}, {"end": 146454, "text": "Equation (5.35) contains all the errors we examine for verification purposes, and it will be the basis for our analysis in Section 5.4.", "rank": 1221, "start": 146319, "IsComparative": "1", "id": "st_1221"}]}, {"paragraph_info": {"end": 147174, "start": 146454, "text": "Two practical aspects that are worth noting.In practice, the sup(x, y) of the error over a pixel (x,y) cannot be computed.Thus, we use a finite high-resolution image as a proxy for the true solution.This allows us to evaluate the maximum error over a pixel.Note also that colors are evaluated at pixel center, as shown in Figure 5.5.Also, often the final image is not a smooth function.However, our goal is not to provide a characterization of discretization errors that can be used in any arbitrary setting, but instead one that can be used for verification purposes.Therefore, to use the analysis outlined above, one must manufacture scalar fields and transfer functions which yield a smooth function (cf.Section 5.5).", "rank": 327, "paragraph_comparative_number": 3, "entities": [], "id": "p_327"}, "sentences": [{"end": 146498, "text": "Two practical aspects that are worth noting.", "rank": 1222, "start": 146454, "IsComparative": "0", "id": "st_1222"}, {"end": 146576, "text": "In practice, the sup(x, y) of the error over a pixel (x,y) cannot be computed.", "rank": 1223, "start": 146498, "IsComparative": "1", "id": "st_1223"}, {"end": 146653, "text": "Thus, we use a finite high-resolution image as a proxy for the true solution.", "rank": 1224, "start": 146576, "IsComparative": "0", "id": "st_1224"}, {"end": 146711, "text": "This allows us to evaluate the maximum error over a pixel.", "rank": 1225, "start": 146653, "IsComparative": "1", "id": "st_1225"}, {"end": 146787, "text": "Note also that colors are evaluated at pixel center, as shown in Figure 5.5.", "rank": 1226, "start": 146711, "IsComparative": "0", "id": "st_1226"}, {"end": 146840, "text": "Also, often the final image is not a smooth function.", "rank": 1227, "start": 146787, "IsComparative": "0", "id": "st_1227"}, {"end": 147022, "text": "However, our goal is not to provide a characterization of discretization errors that can be used in any arbitrary setting, but instead one that can be used for verification purposes.", "rank": 1228, "start": 146840, "IsComparative": "1", "id": "st_1228"}, {"end": 147161, "text": "Therefore, to use the analysis outlined above, one must manufacture scalar fields and transfer functions which yield a smooth function (cf.", "rank": 1229, "start": 147022, "IsComparative": "0", "id": "st_1229"}, {"end": 147174, "text": "Section 5.5).", "rank": 1230, "start": 147161, "IsComparative": "0", "id": "st_1230"}]}, {"paragraph_info": {"end": 147201, "start": 147174, "text": "5.4 Convergence Computation", "rank": 328, "paragraph_comparative_number": 0, "entities": [], "id": "p_328"}, "sentences": [{"end": 147201, "text": "5.4 Convergence Computation", "rank": 1231, "start": 147174, "IsComparative": "0", "id": "st_1231"}]}, {"paragraph_info": {"end": 147988, "start": 147201, "text": "The heart of our method is the evaluation of the discretization errors.Once we have the discretization errors, we can evaluate the order of accuracy and convergence rate.The error computation and analysis will proceed differently depending on whether an analytical solution for the VRI is available or not.We highlight that previous frameworks for verification of visualization algorithms could benefit from the fact that analytical solutions can be easily constructed <46>.For the case of the VRI, this is no longer true, and therefore we should not rely on known solutions.We describe two ways in which to proceed with the convergence analysis.First, we will show how to calculate errors using a known solution, and then how to do so when the analytical solution is not known a priori.", "rank": 329, "paragraph_comparative_number": 5, "entities": [], "id": "p_329"}, "sentences": [{"end": 147272, "text": "The heart of our method is the evaluation of the discretization errors.", "rank": 1232, "start": 147201, "IsComparative": "1", "id": "st_1232"}, {"end": 147371, "text": "Once we have the discretization errors, we can evaluate the order of accuracy and convergence rate.", "rank": 1233, "start": 147272, "IsComparative": "1", "id": "st_1233"}, {"end": 147507, "text": "The error computation and analysis will proceed differently depending on whether an analytical solution for the VRI is available or not.", "rank": 1234, "start": 147371, "IsComparative": "0", "id": "st_1234"}, {"end": 147675, "text": "We highlight that previous frameworks for verification of visualization algorithms could benefit from the fact that analytical solutions can be easily constructed <46>.", "rank": 1235, "start": 147507, "IsComparative": "1", "id": "st_1235"}, {"end": 147776, "text": "For the case of the VRI, this is no longer true, and therefore we should not rely on known solutions.", "rank": 1236, "start": 147675, "IsComparative": "1", "id": "st_1236"}, {"end": 147847, "text": "We describe two ways in which to proceed with the convergence analysis.", "rank": 1237, "start": 147776, "IsComparative": "1", "id": "st_1237"}, {"end": 147988, "text": "First, we will show how to calculate errors using a known solution, and then how to do so when the analytical solution is not known a priori.", "rank": 1238, "start": 147847, "IsComparative": "0", "id": "st_1238"}]}, {"paragraph_info": {"end": 148033, "start": 147988, "text": "5.4.1 Numerical Errors Using a Known Solution", "rank": 330, "paragraph_comparative_number": 0, "entities": [], "id": "p_330"}, "sentences": [{"end": 148033, "text": "5.4.1 Numerical Errors Using a Known Solution", "rank": 1239, "start": 147988, "IsComparative": "0", "id": "st_1239"}]}, {"paragraph_info": {"end": 149207, "start": 148033, "text": "When a solution F (x, y) for the VRI is known, the procedure is equivalent to the Method of Manufactured Solutions <3>.In the previous section, we have shown that the solution F can be written as: where I is the approximated image, r is the discretization parameter, and   R is a constant, multiplicative factor that is not a function of the dataset.An important assumption is that the HOT, or higher order terms, are small enough that they do not affect the convergence of order k  R; i.e., high order derivatives of F must have negligible impact in the asymptotic convergence of I <146>.This formulation implies that not all solutions F are suitable for verification purposes, only those for which the HOT are negligible.In addition, integration methods whose approximation errors cannot be written as shown cannot be compared by only evaluating k, as we propose next.The expected value of k for the cases of step size and pixel size refinement is k = 1, whereas we do not expect to see error reduction when examining grid size refinement.This implies that the pixel intensity converges to the true solution at a rate determined by k, and thus the error can be written as:", "rank": 331, "paragraph_comparative_number": 3, "entities": [], "id": "p_331"}, "sentences": [{"end": 148152, "text": "When a solution F (x, y) for the VRI is known, the procedure is equivalent to the Method of Manufactured Solutions <3>.", "rank": 1240, "start": 148033, "IsComparative": "1", "id": "st_1240"}, {"end": 148383, "text": "In the previous section, we have shown that the solution F can be written as: where I is the approximated image, r is the discretization parameter, and   R is a constant, multiplicative factor that is not a function of the dataset.", "rank": 1241, "start": 148152, "IsComparative": "0", "id": "st_1241"}, {"end": 148622, "text": "An important assumption is that the HOT, or higher order terms, are small enough that they do not affect the convergence of order k  R; i.e., high order derivatives of F must have negligible impact in the asymptotic convergence of I <146>.", "rank": 1242, "start": 148383, "IsComparative": "1", "id": "st_1242"}, {"end": 148756, "text": "This formulation implies that not all solutions F are suitable for verification purposes, only those for which the HOT are negligible.", "rank": 1243, "start": 148622, "IsComparative": "0", "id": "st_1243"}, {"end": 148903, "text": "In addition, integration methods whose approximation errors cannot be written as shown cannot be compared by only evaluating k, as we propose next.", "rank": 1244, "start": 148756, "IsComparative": "0", "id": "st_1244"}, {"end": 149074, "text": "The expected value of k for the cases of step size and pixel size refinement is k = 1, whereas we do not expect to see error reduction when examining grid size refinement.", "rank": 1245, "start": 148903, "IsComparative": "1", "id": "st_1245"}, {"end": 149207, "text": "This implies that the pixel intensity converges to the true solution at a rate determined by k, and thus the error can be written as:", "rank": 1246, "start": 149074, "IsComparative": "0", "id": "st_1246"}]}, {"paragraph_info": {"end": 149511, "start": 149207, "text": "One can evaluate the convergence for all pixels in the image using L2, L, or other norms.Henceforth, we adopt the L norm because it provides a rigorous and yet intuitive way of evaluating errors: it tells us that the maximum image error should decay at the same rate k. Mathematically, the error is then:", "rank": 332, "paragraph_comparative_number": 1, "entities": [], "id": "p_332"}, "sentences": [{"end": 149296, "text": "One can evaluate the convergence for all pixels in the image using L2, L, or other norms.", "rank": 1247, "start": 149207, "IsComparative": "0", "id": "st_1247"}, {"end": 149511, "text": "Henceforth, we adopt the L norm because it provides a rigorous and yet intuitive way of evaluating errors: it tells us that the maximum image error should decay at the same rate k. Mathematically, the error is then:", "rank": 1248, "start": 149296, "IsComparative": "1", "id": "st_1248"}]}, {"paragraph_info": {"end": 149864, "start": 149511, "text": "We denote individual images (and the respective errors) by a subscript i. For each image Ii, we first calculate the supremum of the absolute difference supx,y (|F (x, y)  Ii(x, y)|).We then compute the observed convergence rate k by taking logarithms of both definitions of E and solving the resulting equations for log() and k in a least-squares sense:", "rank": 333, "paragraph_comparative_number": 1, "entities": [], "id": "p_333"}, "sentences": [{"end": 149693, "text": "We denote individual images (and the respective errors) by a subscript i. For each image Ii, we first calculate the supremum of the absolute difference supx,y (|F (x, y)  Ii(x, y)|).", "rank": 1249, "start": 149511, "IsComparative": "0", "id": "st_1249"}, {"end": 149864, "text": "We then compute the observed convergence rate k by taking logarithms of both definitions of E and solving the resulting equations for log() and k in a least-squares sense:", "rank": 1250, "start": 149693, "IsComparative": "1", "id": "st_1250"}]}, {"paragraph_info": {"end": 150113, "start": 149864, "text": "The system of equations has as many equations as the number of images and calculated errors.We note that the solution F (x, y) cannot always be computed analytically <106>.In the general case, we need an alternative method for determining the error.", "rank": 334, "paragraph_comparative_number": 0, "entities": [], "id": "p_334"}, "sentences": [{"end": 149956, "text": "The system of equations has as many equations as the number of images and calculated errors.", "rank": 1251, "start": 149864, "IsComparative": "0", "id": "st_1251"}, {"end": 150036, "text": "We note that the solution F (x, y) cannot always be computed analytically <106>.", "rank": 1252, "start": 149956, "IsComparative": "0", "id": "st_1252"}, {"end": 150113, "text": "In the general case, we need an alternative method for determining the error.", "rank": 1253, "start": 150036, "IsComparative": "0", "id": "st_1253"}]}, {"paragraph_info": {"end": 150169, "start": 150113, "text": "5.4.2 Numerical Errors when the True Solution Is Unknown", "rank": 335, "paragraph_comparative_number": 0, "entities": [], "id": "p_335"}, "sentences": [{"end": 150169, "text": "5.4.2 Numerical Errors when the True Solution Is Unknown", "rank": 1254, "start": 150113, "IsComparative": "0", "id": "st_1254"}]}, {"paragraph_info": {"end": 150908, "start": 150169, "text": "In the case where the true solution is unknown a priori, using a numerical approximation in a high-precision context (i.e., a gold standard solution) to compute a reference image is a valid approach for verification <83>.The main disadvantage of this approach is that it might mask errors which appear in the reference image itself.Our slightly different approach requires neither an analytical solution nor a numerical approximation, but still retains a high sensitivity to errors.Suppose we want to verify the convergence of a sequence of images Ii with ri+1 = cri, where c  (0,1) is a constant factor.As we have seen in the previous section, the approximation written respectively as: for the solution F at resolution i and i + 1 can be", "rank": 336, "paragraph_comparative_number": 4, "entities": [], "id": "p_336"}, "sentences": [{"end": 150390, "text": "In the case where the true solution is unknown a priori, using a numerical approximation in a high-precision context (i.e., a gold standard solution) to compute a reference image is a valid approach for verification <83>.", "rank": 1255, "start": 150169, "IsComparative": "1", "id": "st_1255"}, {"end": 150501, "text": "The main disadvantage of this approach is that it might mask errors which appear in the reference image itself.", "rank": 1256, "start": 150390, "IsComparative": "1", "id": "st_1256"}, {"end": 150651, "text": "Our slightly different approach requires neither an analytical solution nor a numerical approximation, but still retains a high sensitivity to errors.", "rank": 1257, "start": 150501, "IsComparative": "1", "id": "st_1257"}, {"end": 150773, "text": "Suppose we want to verify the convergence of a sequence of images Ii with ri+1 = cri, where c  (0,1) is a constant factor.", "rank": 1258, "start": 150651, "IsComparative": "1", "id": "st_1258"}, {"end": 150908, "text": "As we have seen in the previous section, the approximation written respectively as: for the solution F at resolution i and i + 1 can be", "rank": 1259, "start": 150773, "IsComparative": "0", "id": "st_1259"}]}, {"paragraph_info": {"end": 151097, "start": 150908, "text": "In the case of the grid size test, the linear regression measures the constant error due to sources other than the grid size, since no approximation errors with respect to N are introduced.", "rank": 337, "paragraph_comparative_number": 0, "entities": [], "id": "p_337"}, "sentences": [{"end": 151097, "text": "In the case of the grid size test, the linear regression measures the constant error due to sources other than the grid size, since no approximation errors with respect to N are introduced.", "rank": 1260, "start": 150908, "IsComparative": "0", "id": "st_1260"}]}, {"paragraph_info": {"end": 151490, "start": 151097, "text": "Equation (5.49) shows us how to compute the convergence rate using only the images ob- tained from the VRI approximation and consequently avoiding any bias and/or limitations introduced by simple manufactured solutions or numerical approximations using reference images.We have generated sequences of images based on the refinements in the following section.The steps are shown in Algorithm 8.", "rank": 338, "paragraph_comparative_number": 0, "entities": [], "id": "p_338"}, "sentences": [{"end": 151367, "text": "Equation (5.49) shows us how to compute the convergence rate using only the images ob- tained from the VRI approximation and consequently avoiding any bias and/or limitations introduced by simple manufactured solutions or numerical approximations using reference images.", "rank": 1261, "start": 151097, "IsComparative": "0", "id": "st_1261"}, {"end": 151455, "text": "We have generated sequences of images based on the refinements in the following section.", "rank": 1262, "start": 151367, "IsComparative": "0", "id": "st_1262"}, {"end": 151490, "text": "The steps are shown in Algorithm 8.", "rank": 1263, "start": 151455, "IsComparative": "0", "id": "st_1263"}]}, {"paragraph_info": {"end": 151514, "start": 151490, "text": "5.5 Application Examples", "rank": 339, "paragraph_comparative_number": 0, "entities": [], "id": "p_339"}, "sentences": [{"end": 151514, "text": "5.5 Application Examples", "rank": 1264, "start": 151490, "IsComparative": "0", "id": "st_1264"}]}, {"paragraph_info": {"end": 151940, "start": 151514, "text": "We present the results of applying our verification framework to two mature and widely- used libraries, namely, VTK and Voreen.We stress that the goal here is first to show that our verification technique is very sensitive to changes that cause the output image to deviate from the correct solution; secondly, it is very easy to apply and thus can help developers and practitioners to gain confidence in their implementations.", "rank": 340, "paragraph_comparative_number": 2, "entities": [], "id": "p_340"}, "sentences": [{"end": 151641, "text": "We present the results of applying our verification framework to two mature and widely- used libraries, namely, VTK and Voreen.", "rank": 1265, "start": 151514, "IsComparative": "1", "id": "st_1265"}, {"end": 151940, "text": "We stress that the goal here is first to show that our verification technique is very sensitive to changes that cause the output image to deviate from the correct solution; secondly, it is very easy to apply and thus can help developers and practitioners to gain confidence in their implementations.", "rank": 1266, "start": 151641, "IsComparative": "1", "id": "st_1266"}]}, {"paragraph_info": {"end": 151980, "start": 151940, "text": "5.5.1 Implementations Under Verification", "rank": 341, "paragraph_comparative_number": 1, "entities": [], "id": "p_341"}, "sentences": [{"end": 151980, "text": "5.5.1 Implementations Under Verification", "rank": 1267, "start": 151940, "IsComparative": "1", "id": "st_1267"}]}, {"paragraph_info": {"end": 152057, "start": 151980, "text": "In what follows, we show all the implementations that will be under scrutiny.", "rank": 342, "paragraph_comparative_number": 0, "entities": [], "id": "p_342"}, "sentences": [{"end": 152057, "text": "In what follows, we show all the implementations that will be under scrutiny.", "rank": 1268, "start": 151980, "IsComparative": "0", "id": "st_1268"}]}, {"paragraph_info": {"end": 152187, "start": 152057, "text": "Algorithm 8 A simple algorithm for verification via step size, dataset size, or pixel size.Verification Procedure(G,(s),d0,N0,h0,)", "rank": 343, "paragraph_comparative_number": 0, "entities": [], "id": "p_343"}, "sentences": [{"end": 152148, "text": "Algorithm 8 A simple algorithm for verification via step size, dataset size, or pixel size.", "rank": 1269, "start": 152057, "IsComparative": "0", "id": "st_1269"}, {"end": 152187, "text": "Verification Procedure(G,(s),d0,N0,h0,)", "rank": 1270, "start": 152148, "IsComparative": "0", "id": "st_1270"}]}, {"paragraph_info": {"end": 152198, "start": 152187, "text": "5.5.1.1 VTK", "rank": 344, "paragraph_comparative_number": 0, "entities": [], "id": "p_344"}, "sentences": [{"end": 152198, "text": "5.5.1.1 VTK", "rank": 1271, "start": 152187, "IsComparative": "0", "id": "st_1271"}]}, {"paragraph_info": {"end": 152811, "start": 152198, "text": "The VTK library provides several implementations of the well-known VRI techniques.In our tests, we included two modules from version 5.6.1: vtkVolumeRayCast (RCM) and vtkFixedPointVolumeRayCast (FP).The RCM module accepts as input scalar fields with 8- or 16-bit precision and internal computations are performed with single or double precision.FP accepts input datasets with up to 32 bits of precision but it uses 15-bit fixed-point arithmetic internally.Both techniques use back-to-front compositing.We have also modified the VTK source to capture 15 bit and 32 bit precision images for FP and RCM respectively.", "rank": 345, "paragraph_comparative_number": 3, "entities": [], "id": "p_345"}, "sentences": [{"end": 152280, "text": "The VTK library provides several implementations of the well-known VRI techniques.", "rank": 1272, "start": 152198, "IsComparative": "1", "id": "st_1272"}, {"end": 152397, "text": "In our tests, we included two modules from version 5.6.1: vtkVolumeRayCast (RCM) and vtkFixedPointVolumeRayCast (FP).", "rank": 1273, "start": 152280, "IsComparative": "1", "id": "st_1273"}, {"end": 152543, "text": "The RCM module accepts as input scalar fields with 8- or 16-bit precision and internal computations are performed with single or double precision.", "rank": 1274, "start": 152397, "IsComparative": "0", "id": "st_1274"}, {"end": 152654, "text": "FP accepts input datasets with up to 32 bits of precision but it uses 15-bit fixed-point arithmetic internally.", "rank": 1275, "start": 152543, "IsComparative": "1", "id": "st_1275"}, {"end": 152700, "text": "Both techniques use back-to-front compositing.", "rank": 1276, "start": 152654, "IsComparative": "0", "id": "st_1276"}, {"end": 152811, "text": "We have also modified the VTK source to capture 15 bit and 32 bit precision images for FP and RCM respectively.", "rank": 1277, "start": 152700, "IsComparative": "0", "id": "st_1277"}]}, {"paragraph_info": {"end": 152825, "start": 152811, "text": "5.5.1.2 Voreen", "rank": 346, "paragraph_comparative_number": 0, "entities": [], "id": "p_346"}, "sentences": [{"end": 152825, "text": "5.5.1.2 Voreen", "rank": 1278, "start": 152811, "IsComparative": "0", "id": "st_1278"}]}, {"paragraph_info": {"end": 153373, "start": 152825, "text": "As opposed to the tested modules in VTK, Voreen uses the graphics processing unit (GPU) and front-to-back compositing for its implementations.From the ray casting pro- cessors available within Voreen, we have chosen the SingleVolumeRaycaster, which is the standard processor in most Voreen workspaces.At the time of writing, version 2.6.1 is the latest, and the one we verified.We made minor modifications to the code so that floating point data of the format Nearly Raw Raster Data NRRD <74> could be imported and smaller step sizes could be used.", "rank": 347, "paragraph_comparative_number": 3, "entities": [], "id": "p_347"}, "sentences": [{"end": 152967, "text": "As opposed to the tested modules in VTK, Voreen uses the graphics processing unit (GPU) and front-to-back compositing for its implementations.", "rank": 1279, "start": 152825, "IsComparative": "1", "id": "st_1279"}, {"end": 153126, "text": "From the ray casting pro- cessors available within Voreen, we have chosen the SingleVolumeRaycaster, which is the standard processor in most Voreen workspaces.", "rank": 1280, "start": 152967, "IsComparative": "0", "id": "st_1280"}, {"end": 153203, "text": "At the time of writing, version 2.6.1 is the latest, and the one we verified.", "rank": 1281, "start": 153126, "IsComparative": "1", "id": "st_1281"}, {"end": 153373, "text": "We made minor modifications to the code so that floating point data of the format Nearly Raw Raster Data NRRD <74> could be imported and smaller step sizes could be used.", "rank": 1282, "start": 153203, "IsComparative": "1", "id": "st_1282"}]}, {"paragraph_info": {"end": 153391, "start": 153373, "text": "5.5.2 System Setup", "rank": 348, "paragraph_comparative_number": 0, "entities": [], "id": "p_348"}, "sentences": [{"end": 153391, "text": "5.5.2 System Setup", "rank": 1283, "start": 153373, "IsComparative": "0", "id": "st_1283"}]}, {"paragraph_info": {"end": 154704, "start": 153391, "text": "The grid lies in the domain <0,2>3 for VTK and <0,1>3 for Voreen.The scalar values at grid nodes are chosen from a uniform random distribution.The camera is centered at the xy plane and is aimed along the z axis.We did not include shading since that gives a more complex VRI.To verify shaded results, a different theoretical analysis is necessary.The images can be generated using both perspective and parallel projections.We only use postclassification, which simplifies the analysis.In addition, we assume an identity opacity transfer function (that is, the opacity is exactly equal to the sampled scalar).We do this because for every pair of scalar field and opacity transfer function, there is another scalar field (which admittedly need to be of finer resolution) that, when combined with the identity transfer function, represents the composition arbitrarily well.The function composition arising from volume classification can increase the high-frequency content of a volume <4>, and a full treatment of the impact of arbitrary transfer functions on the convergence of the integral remains a topic for future explorations.In addition, this assumption enabled much of the theoretical analysis that would not be possible otherwise, while still being stringent enough to uncover issues in the implementations.", "rank": 349, "paragraph_comparative_number": 3, "entities": [], "id": "p_349"}, "sentences": [{"end": 153456, "text": "The grid lies in the domain <0,2>3 for VTK and <0,1>3 for Voreen.", "rank": 1284, "start": 153391, "IsComparative": "1", "id": "st_1284"}, {"end": 153534, "text": "The scalar values at grid nodes are chosen from a uniform random distribution.", "rank": 1285, "start": 153456, "IsComparative": "0", "id": "st_1285"}, {"end": 153603, "text": "The camera is centered at the xy plane and is aimed along the z axis.", "rank": 1286, "start": 153534, "IsComparative": "0", "id": "st_1286"}, {"end": 153666, "text": "We did not include shading since that gives a more complex VRI.", "rank": 1287, "start": 153603, "IsComparative": "0", "id": "st_1287"}, {"end": 153738, "text": "To verify shaded results, a different theoretical analysis is necessary.", "rank": 1288, "start": 153666, "IsComparative": "0", "id": "st_1288"}, {"end": 153814, "text": "The images can be generated using both perspective and parallel projections.", "rank": 1289, "start": 153738, "IsComparative": "0", "id": "st_1289"}, {"end": 153876, "text": "We only use postclassification, which simplifies the analysis.", "rank": 1290, "start": 153814, "IsComparative": "0", "id": "st_1290"}, {"end": 153999, "text": "In addition, we assume an identity opacity transfer function (that is, the opacity is exactly equal to the sampled scalar).", "rank": 1291, "start": 153876, "IsComparative": "0", "id": "st_1291"}, {"end": 154261, "text": "We do this because for every pair of scalar field and opacity transfer function, there is another scalar field (which admittedly need to be of finer resolution) that, when combined with the identity transfer function, represents the composition arbitrarily well.", "rank": 1292, "start": 153999, "IsComparative": "1", "id": "st_1292"}, {"end": 154520, "text": "The function composition arising from volume classification can increase the high-frequency content of a volume <4>, and a full treatment of the impact of arbitrary transfer functions on the convergence of the integral remains a topic for future explorations.", "rank": 1293, "start": 154261, "IsComparative": "1", "id": "st_1293"}, {"end": 154704, "text": "In addition, this assumption enabled much of the theoretical analysis that would not be possible otherwise, while still being stringent enough to uncover issues in the implementations.", "rank": 1294, "start": 154520, "IsComparative": "0", "id": "st_1294"}]}, {"paragraph_info": {"end": 155014, "start": 154704, "text": "To apply verification via step size refinement, we start with d0 = 1 and a refinement 2 factor of half, di+1 = 1di.We use a dataset of size 23 since we have experienced that low 2 resolution grids with random scalar fields are effective at stressing the code for debugging purposes.due only to grid refinement.", "rank": 350, "paragraph_comparative_number": 1, "entities": [], "id": "p_350"}, "sentences": [{"end": 154819, "text": "To apply verification via step size refinement, we start with d0 = 1 and a refinement 2 factor of half, di+1 = 1di.", "rank": 1295, "start": 154704, "IsComparative": "1", "id": "st_1295"}, {"end": 154986, "text": "We use a dataset of size 23 since we have experienced that low 2 resolution grids with random scalar fields are effective at stressing the code for debugging purposes.", "rank": 1296, "start": 154819, "IsComparative": "0", "id": "st_1296"}, {"end": 155014, "text": "due only to grid refinement.", "rank": 1297, "start": 154986, "IsComparative": "0", "id": "st_1297"}]}, {"paragraph_info": {"end": 155656, "start": 155014, "text": "For verification via pixel size refinement, we start by generating images with 322 pixels using the implementation under verification, and then continue to refine pixel size until we reach 10242 pixels.The pixel size h is refined according to hi+1 = 1hi.The errors are computed taking the difference between the rendered image and an analytical solution.In this case, we use an analytical solution for the volume rendering integral in the domain <0, 1>2.We assume the following: s(x,y,z) = zcos(xy), (s) = sin(s), x() = (x,y,), C(s) = 1, and ray length D = 1.The analytical solution is then: I(x, y) = 1  exp cos(cos(xy))  1  .cos(xy) cos(xy)", "rank": 351, "paragraph_comparative_number": 1, "entities": [], "id": "p_351"}, "sentences": [{"end": 155216, "text": "For verification via pixel size refinement, we start by generating images with 322 pixels using the implementation under verification, and then continue to refine pixel size until we reach 10242 pixels.", "rank": 1298, "start": 155014, "IsComparative": "1", "id": "st_1298"}, {"end": 155268, "text": "The pixel size h is refined according to hi+1 = 1hi.", "rank": 1299, "start": 155216, "IsComparative": "0", "id": "st_1299"}, {"end": 155368, "text": "The errors are computed taking the difference between the rendered image and an analytical solution.", "rank": 1300, "start": 155268, "IsComparative": "0", "id": "st_1300"}, {"end": 155468, "text": "In this case, we use an analytical solution for the volume rendering integral in the domain <0, 1>2.", "rank": 1301, "start": 155368, "IsComparative": "0", "id": "st_1301"}, {"end": 155573, "text": "We assume the following: s(x,y,z) = zcos(xy), (s) = sin(s), x() = (x,y,), C(s) = 1, and ray length D = 1.", "rank": 1302, "start": 155468, "IsComparative": "0", "id": "st_1302"}, {"end": 155641, "text": "The analytical solution is then: I(x, y) = 1  exp cos(cos(xy))  1  .", "rank": 1303, "start": 155573, "IsComparative": "0", "id": "st_1303"}, {"end": 155656, "text": "cos(xy) cos(xy)", "rank": 1304, "start": 155641, "IsComparative": "0", "id": "st_1304"}]}, {"paragraph_info": {"end": 155841, "start": 155656, "text": "The dataset size used is 5133, and the step size is set at d = 105 to mitigate sampling errors.Both step and dataset size are fixed to only evaluate errors due to pixel size refinement.", "rank": 352, "paragraph_comparative_number": 1, "entities": [], "id": "p_352"}, "sentences": [{"end": 155751, "text": "The dataset size used is 5133, and the step size is set at d = 105 to mitigate sampling errors.", "rank": 1305, "start": 155656, "IsComparative": "1", "id": "st_1305"}, {"end": 155841, "text": "Both step and dataset size are fixed to only evaluate errors due to pixel size refinement.", "rank": 1306, "start": 155751, "IsComparative": "0", "id": "st_1306"}]}, {"paragraph_info": {"end": 156111, "start": 155841, "text": "For VTK, we also have the following setup: no auto adjustment of the step size d; single thread; interpolation type is set to linear.For Voreen, we enabled floating point buffers in the pipeline.The Voreen version under verification does not support parallel projection.", "rank": 353, "paragraph_comparative_number": 1, "entities": [], "id": "p_353"}, "sentences": [{"end": 155974, "text": "For VTK, we also have the following setup: no auto adjustment of the step size d; single thread; interpolation type is set to linear.", "rank": 1307, "start": 155841, "IsComparative": "0", "id": "st_1307"}, {"end": 156036, "text": "For Voreen, we enabled floating point buffers in the pipeline.", "rank": 1308, "start": 155974, "IsComparative": "1", "id": "st_1308"}, {"end": 156111, "text": "The Voreen version under verification does not support parallel projection.", "rank": 1309, "start": 156036, "IsComparative": "0", "id": "st_1309"}]}, {"paragraph_info": {"end": 156437, "start": 156111, "text": "The errors are computed using the L norm and are given by the maximum distance between two images, defined as Ei = maxx,y |Ii(x, y)  Ii+1(x, y)|, where Ii(x, y) is the pixel with center in (x,y) of the image Ii rendered with the implementation under verification.If a solution F is available, Ei = maxx,y |Ii(x, y)  F (x, y)|.", "rank": 354, "paragraph_comparative_number": 1, "entities": [], "id": "p_354"}, "sentences": [{"end": 156374, "text": "The errors are computed using the L norm and are given by the maximum distance between two images, defined as Ei = maxx,y |Ii(x, y)  Ii+1(x, y)|, where Ii(x, y) is the pixel with center in (x,y) of the image Ii rendered with the implementation under verification.", "rank": 1310, "start": 156111, "IsComparative": "1", "id": "st_1310"}, {"end": 156437, "text": "If a solution F is available, Ei = maxx,y |Ii(x, y)  F (x, y)|.", "rank": 1311, "start": 156374, "IsComparative": "0", "id": "st_1311"}]}, {"paragraph_info": {"end": 156606, "start": 156437, "text": "In the following sections, we report the results of applying the verification framework with known and unknown exact solutions to three volume rendering implementations.", "rank": 355, "paragraph_comparative_number": 0, "entities": [], "id": "p_355"}, "sentences": [{"end": 156606, "text": "In the following sections, we report the results of applying the verification framework with known and unknown exact solutions to three volume rendering implementations.", "rank": 1312, "start": 156437, "IsComparative": "0", "id": "st_1312"}]}, {"paragraph_info": {"end": 156629, "start": 156606, "text": "5.5.3 Observed Behavior", "rank": 356, "paragraph_comparative_number": 0, "entities": [], "id": "p_356"}, "sentences": [{"end": 156629, "text": "5.5.3 Observed Behavior", "rank": 1313, "start": 156606, "IsComparative": "0", "id": "st_1313"}]}, {"paragraph_info": {"end": 156882, "start": 156629, "text": "The results of our verification procedure are summarized in Figure 5.6.We tested both VTK and Voreen and found unexpected behaviors.We emphasize that this does not immediately translate into a code mistake but only that a deeper investigation is needed.", "rank": 357, "paragraph_comparative_number": 1, "entities": [], "id": "p_357"}, "sentences": [{"end": 156700, "text": "The results of our verification procedure are summarized in Figure 5.6.", "rank": 1314, "start": 156629, "IsComparative": "0", "id": "st_1314"}, {"end": 156761, "text": "We tested both VTK and Voreen and found unexpected behaviors.", "rank": 1315, "start": 156700, "IsComparative": "1", "id": "st_1315"}, {"end": 156882, "text": "We emphasize that this does not immediately translate into a code mistake but only that a deeper investigation is needed.", "rank": 1316, "start": 156761, "IsComparative": "0", "id": "st_1316"}]}, {"paragraph_info": {"end": 157108, "start": 156882, "text": "To find the reason for the unexpected behavior, we analyzed the source code of the given systems.We expect linear convergence when step size or pixel size are refined (k = 1) and constant error when dataset refinement is used.", "rank": 358, "paragraph_comparative_number": 1, "entities": [], "id": "p_358"}, "sentences": [{"end": 156979, "text": "To find the reason for the unexpected behavior, we analyzed the source code of the given systems.", "rank": 1317, "start": 156882, "IsComparative": "1", "id": "st_1317"}, {"end": 157108, "text": "We expect linear convergence when step size or pixel size are refined (k = 1) and constant error when dataset refinement is used.", "rank": 1318, "start": 156979, "IsComparative": "0", "id": "st_1318"}]}, {"paragraph_info": {"end": 157118, "start": 157108, "text": "5.5.3.1 FP", "rank": 359, "paragraph_comparative_number": 0, "entities": [], "id": "p_359"}, "sentences": [{"end": 157118, "text": "5.5.3.1 FP", "rank": 1319, "start": 157108, "IsComparative": "0", "id": "st_1319"}]}, {"paragraph_info": {"end": 158188, "start": 157118, "text": "The results obtained for the FP module (blue curves in Figures 5.6(a), (b), and (c)) were different from expected for all tests.The 15-bit fixed-point precision could, to some extent, justify this behavior.Still, we only expected this influence to have a negative effect after a certain threshold for step size.The perspective projection curve shown in Figure 5.6(a), for instance, has what appears to be a constant error when using step size refinement and perspective projection.We expect the error to decrease for large values of d; we acknowledge that when d is too small, the errors due to 15-bit fixed-point precision will dominate.After investigating the reason for this deviation, we found that depending on the pixel position, some rays might cross only half of the volume instead of the full volume.In other words, instead of sampling the ray in n locations, for some pixels, the ray was only sampled n 2 times.This is a combination of several factors which includes domain size, step size, and ray direction.Details can be found in the supplementary material.", "rank": 360, "paragraph_comparative_number": 4, "entities": [], "id": "p_360"}, "sentences": [{"end": 157246, "text": "The results obtained for the FP module (blue curves in Figures 5.6(a), (b), and (c)) were different from expected for all tests.", "rank": 1320, "start": 157118, "IsComparative": "0", "id": "st_1320"}, {"end": 157324, "text": "The 15-bit fixed-point precision could, to some extent, justify this behavior.", "rank": 1321, "start": 157246, "IsComparative": "0", "id": "st_1321"}, {"end": 157429, "text": "Still, we only expected this influence to have a negative effect after a certain threshold for step size.", "rank": 1322, "start": 157324, "IsComparative": "1", "id": "st_1322"}, {"end": 157599, "text": "The perspective projection curve shown in Figure 5.6(a), for instance, has what appears to be a constant error when using step size refinement and perspective projection.", "rank": 1323, "start": 157429, "IsComparative": "0", "id": "st_1323"}, {"end": 157756, "text": "We expect the error to decrease for large values of d; we acknowledge that when d is too small, the errors due to 15-bit fixed-point precision will dominate.", "rank": 1324, "start": 157599, "IsComparative": "0", "id": "st_1324"}, {"end": 157927, "text": "After investigating the reason for this deviation, we found that depending on the pixel position, some rays might cross only half of the volume instead of the full volume.", "rank": 1325, "start": 157756, "IsComparative": "1", "id": "st_1325"}, {"end": 158039, "text": "In other words, instead of sampling the ray in n locations, for some pixels, the ray was only sampled n 2 times.", "rank": 1326, "start": 157927, "IsComparative": "1", "id": "st_1326"}, {"end": 158137, "text": "This is a combination of several factors which includes domain size, step size, and ray direction.", "rank": 1327, "start": 158039, "IsComparative": "1", "id": "st_1327"}, {"end": 158188, "text": "Details can be found in the supplementary material.", "rank": 1328, "start": 158137, "IsComparative": "0", "id": "st_1328"}]}, {"paragraph_info": {"end": 159214, "start": 158188, "text": "Using our synthetic dataset, we observed a + pattern shown in Figure 5.7 (left).The darker regions are precisely the pixels where the ray does not cover the whole domain.Arti- facts may also be seen in standard datasets such as the Carp shown in Figure 5.8.The orange curves in Figures 5.6(a), (b), and (c) show the convergence results after modifying VTKs source.Notice that for step size refinement using perspective projection, the convergence curve changed from 0.02 to 0.92 for the first seven samples.For the eight and ninth samples, the error slightly increases.A similar phenomenon occur in the parallel convergence curve.The curve starts to diverge in the high-resolution regime (parallel and perspective projection plot).This is likely to be due to the limit of 15-bit fixed point arithmetic.Although the pixel size refinement convergence for perspective projection substantially improved (from 0.01 to 0.94), the convergence curves for parallel projection remained similar, which can be explained by the O(d) error.", "rank": 361, "paragraph_comparative_number": 3, "entities": [], "id": "p_361"}, "sentences": [{"end": 158268, "text": "Using our synthetic dataset, we observed a + pattern shown in Figure 5.7 (left).", "rank": 1329, "start": 158188, "IsComparative": "0", "id": "st_1329"}, {"end": 158358, "text": "The darker regions are precisely the pixels where the ray does not cover the whole domain.", "rank": 1330, "start": 158268, "IsComparative": "0", "id": "st_1330"}, {"end": 158445, "text": "Arti- facts may also be seen in standard datasets such as the Carp shown in Figure 5.8.", "rank": 1331, "start": 158358, "IsComparative": "0", "id": "st_1331"}, {"end": 158552, "text": "The orange curves in Figures 5.6(a), (b), and (c) show the convergence results after modifying VTKs source.", "rank": 1332, "start": 158445, "IsComparative": "1", "id": "st_1332"}, {"end": 158695, "text": "Notice that for step size refinement using perspective projection, the convergence curve changed from 0.02 to 0.92 for the first seven samples.", "rank": 1333, "start": 158552, "IsComparative": "1", "id": "st_1333"}, {"end": 158757, "text": "For the eight and ninth samples, the error slightly increases.", "rank": 1334, "start": 158695, "IsComparative": "0", "id": "st_1334"}, {"end": 158818, "text": "A similar phenomenon occur in the parallel convergence curve.", "rank": 1335, "start": 158757, "IsComparative": "0", "id": "st_1335"}, {"end": 158919, "text": "The curve starts to diverge in the high-resolution regime (parallel and perspective projection plot).", "rank": 1336, "start": 158818, "IsComparative": "0", "id": "st_1336"}, {"end": 158990, "text": "This is likely to be due to the limit of 15-bit fixed point arithmetic.", "rank": 1337, "start": 158919, "IsComparative": "1", "id": "st_1337"}, {"end": 159214, "text": "Although the pixel size refinement convergence for perspective projection substantially improved (from 0.01 to 0.94), the convergence curves for parallel projection remained similar, which can be explained by the O(d) error.", "rank": 1338, "start": 158990, "IsComparative": "0", "id": "st_1338"}]}, {"paragraph_info": {"end": 159225, "start": 159214, "text": "5.5.3.2 RCM", "rank": 362, "paragraph_comparative_number": 0, "entities": [], "id": "p_362"}, "sentences": [{"end": 159225, "text": "5.5.3.2 RCM", "rank": 1339, "start": 159214, "IsComparative": "0", "id": "st_1339"}]}, {"paragraph_info": {"end": 159892, "start": 159225, "text": "The RCM module (blue curves in Figures 5.6(d), (e), and (f)) produces nearly linearly converging sequences when refining the step size or pixel size.However, dataset refinement with either perspective or parallel projection fails to present the expected constant error.Analyzing the source code, we found the discrepancy to be due to the number of steps taken when marching inside the volume.For instance, suppose that the step size is set in such a way that 200 steps are required to traverse the volume.Instead of 200 steps, the RCM module used values between 195 and 199 steps, depending on some conditions.The consequence of this deviation is shown in Figure 5.9.", "rank": 363, "paragraph_comparative_number": 3, "entities": [], "id": "p_363"}, "sentences": [{"end": 159374, "text": "The RCM module (blue curves in Figures 5.6(d), (e), and (f)) produces nearly linearly converging sequences when refining the step size or pixel size.", "rank": 1340, "start": 159225, "IsComparative": "0", "id": "st_1340"}, {"end": 159494, "text": "However, dataset refinement with either perspective or parallel projection fails to present the expected constant error.", "rank": 1341, "start": 159374, "IsComparative": "0", "id": "st_1341"}, {"end": 159617, "text": "Analyzing the source code, we found the discrepancy to be due to the number of steps taken when marching inside the volume.", "rank": 1342, "start": 159494, "IsComparative": "1", "id": "st_1342"}, {"end": 159730, "text": "For instance, suppose that the step size is set in such a way that 200 steps are required to traverse the volume.", "rank": 1343, "start": 159617, "IsComparative": "1", "id": "st_1343"}, {"end": 159835, "text": "Instead of 200 steps, the RCM module used values between 195 and 199 steps, depending on some conditions.", "rank": 1344, "start": 159730, "IsComparative": "1", "id": "st_1344"}, {"end": 159892, "text": "The consequence of this deviation is shown in Figure 5.9.", "rank": 1345, "start": 159835, "IsComparative": "0", "id": "st_1345"}]}, {"paragraph_info": {"end": 159978, "start": 159892, "text": "The orange curves in Figures 5.6(d), (e), and (f) show the convergence results for the", "rank": 364, "paragraph_comparative_number": 0, "entities": [], "id": "p_364"}, "sentences": [{"end": 159978, "text": "The orange curves in Figures 5.6(d), (e), and (f) show the convergence results for the", "rank": 1346, "start": 159892, "IsComparative": "0", "id": "st_1346"}]}, {"paragraph_info": {"end": 160088, "start": 159978, "text": "(a) Dataset refinement.Before, a linear trend is observed.After fixing an issue, a constant error is obtained.", "rank": 365, "paragraph_comparative_number": 0, "entities": [], "id": "p_365"}, "sentences": [{"end": 160001, "text": "(a) Dataset refinement.", "rank": 1347, "start": 159978, "IsComparative": "0", "id": "st_1347"}, {"end": 160036, "text": "Before, a linear trend is observed.", "rank": 1348, "start": 160001, "IsComparative": "0", "id": "st_1348"}, {"end": 160088, "text": "After fixing an issue, a constant error is obtained.", "rank": 1349, "start": 160036, "IsComparative": "0", "id": "st_1349"}]}, {"paragraph_info": {"end": 160158, "start": 160088, "text": "(b) Pixel size refinement.Exp.: k = 1.Before: k = 0.37.After: k = 1.23", "rank": 366, "paragraph_comparative_number": 0, "entities": [], "id": "p_366"}, "sentences": [{"end": 160114, "text": "(b) Pixel size refinement.", "rank": 1350, "start": 160088, "IsComparative": "0", "id": "st_1350"}, {"end": 160118, "text": "Exp.", "rank": 1351, "start": 160114, "IsComparative": "0", "id": "st_1351"}, {"end": 160126, "text": ": k = 1.", "rank": 1352, "start": 160118, "IsComparative": "0", "id": "st_1352"}, {"end": 160143, "text": "Before: k = 0.37.", "rank": 1353, "start": 160126, "IsComparative": "0", "id": "st_1353"}, {"end": 160158, "text": "After: k = 1.23", "rank": 1354, "start": 160143, "IsComparative": "0", "id": "st_1354"}]}, {"paragraph_info": {"end": 160172, "start": 160158, "text": "5.5.3.3 Voreen", "rank": 367, "paragraph_comparative_number": 0, "entities": [], "id": "p_367"}, "sentences": [{"end": 160172, "text": "5.5.3.3 Voreen", "rank": 1355, "start": 160158, "IsComparative": "0", "id": "st_1355"}]}, {"paragraph_info": {"end": 160459, "start": 160172, "text": "Our first ray refinement tests did not result in linear convergence for Voreen (blue line in Figure 5.6(g)) due to the early ray termination (ERT).By simply adapting the ERT threshold, we were able to obtain the expected convergence for ray refinement (orange line in the Figure 5.6(g)).", "rank": 368, "paragraph_comparative_number": 2, "entities": [], "id": "p_368"}, "sentences": [{"end": 160319, "text": "Our first ray refinement tests did not result in linear convergence for Voreen (blue line in Figure 5.6(g)) due to the early ray termination (ERT).", "rank": 1356, "start": 160172, "IsComparative": "1", "id": "st_1356"}, {"end": 160459, "text": "By simply adapting the ERT threshold, we were able to obtain the expected convergence for ray refinement (orange line in the Figure 5.6(g)).", "rank": 1357, "start": 160319, "IsComparative": "1", "id": "st_1357"}]}, {"paragraph_info": {"end": 160997, "start": 160459, "text": "As can be seen in the Figure 5.6(i), the blue curve indicates that increasing the resolution of the dataset decreases the error.We remind the reader that using our upsampled data, as described in Section 5.3.2, rendering the same scalar field represented by a different number of voxels should not affect the result.For Voreen, the unexpected behavior was caused by sampling at incorrect texture locations.More specifically, internally, Voreen assumed that the texture data are node centered when, in fact, OpenGL uses grid centered data.", "rank": 369, "paragraph_comparative_number": 1, "entities": [], "id": "p_369"}, "sentences": [{"end": 160587, "text": "As can be seen in the Figure 5.6(i), the blue curve indicates that increasing the resolution of the dataset decreases the error.", "rank": 1358, "start": 160459, "IsComparative": "0", "id": "st_1358"}, {"end": 160775, "text": "We remind the reader that using our upsampled data, as described in Section 5.3.2, rendering the same scalar field represented by a different number of voxels should not affect the result.", "rank": 1359, "start": 160587, "IsComparative": "0", "id": "st_1359"}, {"end": 160865, "text": "For Voreen, the unexpected behavior was caused by sampling at incorrect texture locations.", "rank": 1360, "start": 160775, "IsComparative": "1", "id": "st_1360"}, {"end": 160997, "text": "More specifically, internally, Voreen assumed that the texture data are node centered when, in fact, OpenGL uses grid centered data.", "rank": 1361, "start": 160865, "IsComparative": "0", "id": "st_1361"}]}, {"paragraph_info": {"end": 162042, "start": 160997, "text": "In this case, both the volume and transfer function values were affected.In OpenGL, the texture coordinates of a texture of resolution Rm lie in the domain <0,1>m, where m is the texture dimension.Since the data values are grid centered, this means that the outermost data values are located at < 1 , 1  1 > with the settings used in Voreen.We will refer to 2R 2R the domain in which the data values lie as the data domain.For volume rendering, the integration of a ray should be done over the data domain, but for Voreen, the entry and exit points of the rays went outside of that domain which caused the unexpected behavior.To obtain the expected constant convergence, we apply the following transformation to the input texture coordinate p (see orange line in Figure 5.6(i)): does not require special treatment at the border of the domain; and due to its simplicity, it is easy to implement.We have contacted Voreen developers and the issue found was indeed identified as a bug.The proposed solution will be adopted into Voreens next release.", "rank": 370, "paragraph_comparative_number": 3, "entities": [], "id": "p_370"}, "sentences": [{"end": 161070, "text": "In this case, both the volume and transfer function values were affected.", "rank": 1362, "start": 160997, "IsComparative": "1", "id": "st_1362"}, {"end": 161194, "text": "In OpenGL, the texture coordinates of a texture of resolution Rm lie in the domain <0,1>m, where m is the texture dimension.", "rank": 1363, "start": 161070, "IsComparative": "0", "id": "st_1363"}, {"end": 161338, "text": "Since the data values are grid centered, this means that the outermost data values are located at < 1 , 1  1 > with the settings used in Voreen.", "rank": 1364, "start": 161194, "IsComparative": "0", "id": "st_1364"}, {"end": 161420, "text": "We will refer to 2R 2R the domain in which the data values lie as the data domain.", "rank": 1365, "start": 161338, "IsComparative": "1", "id": "st_1365"}, {"end": 161623, "text": "For volume rendering, the integration of a ray should be done over the data domain, but for Voreen, the entry and exit points of the rays went outside of that domain which caused the unexpected behavior.", "rank": 1366, "start": 161420, "IsComparative": "0", "id": "st_1366"}, {"end": 161891, "text": "To obtain the expected constant convergence, we apply the following transformation to the input texture coordinate p (see orange line in Figure 5.6(i)): does not require special treatment at the border of the domain; and due to its simplicity, it is easy to implement.", "rank": 1367, "start": 161623, "IsComparative": "1", "id": "st_1367"}, {"end": 161978, "text": "We have contacted Voreen developers and the issue found was indeed identified as a bug.", "rank": 1368, "start": 161891, "IsComparative": "0", "id": "st_1368"}, {"end": 162042, "text": "The proposed solution will be adopted into Voreens next release.", "rank": 1369, "start": 161978, "IsComparative": "0", "id": "st_1369"}]}, {"paragraph_info": {"end": 162263, "start": 162042, "text": "No unexpected behavior could be detected for pixel size convergence, as shown in Figure 5.6(h), neither before nor after changing the texture coordinate sampling.Both curves lie near the expected behavior (0.93 and 0.94).", "rank": 371, "paragraph_comparative_number": 0, "entities": [], "id": "p_371"}, "sentences": [{"end": 162204, "text": "No unexpected behavior could be detected for pixel size convergence, as shown in Figure 5.6(h), neither before nor after changing the texture coordinate sampling.", "rank": 1370, "start": 162042, "IsComparative": "0", "id": "st_1370"}, {"end": 162263, "text": "Both curves lie near the expected behavior (0.93 and 0.94).", "rank": 1371, "start": 162204, "IsComparative": "0", "id": "st_1371"}]}, {"paragraph_info": {"end": 162277, "start": 162263, "text": "5.6 Discussion", "rank": 372, "paragraph_comparative_number": 0, "entities": [], "id": "p_372"}, "sentences": [{"end": 162277, "text": "5.6 Discussion", "rank": 1372, "start": 162263, "IsComparative": "0", "id": "st_1372"}]}, {"paragraph_info": {"end": 164137, "start": 162277, "text": "The convergence analysis presented in the previous section helped us to identify un- expected behavior in two stable and widely-used frameworks.Unexpected behavior is not indicative of an implementation bug but rather a warning about potential problems.For instance, some valid design decisions might affect the convergence results.Consider the widely used ERT acceleration technique.Depending on the thresholds involved, the convergence results might deviate from the ideal, and the expected curve is recovered once this feature is turned off.In this sense, the verification tool can help the developer to identify portions of the code that introduce numerical errors and quantify their effect on the final image.The issue with the RCM module is another example.The dataset size convergence curve was unexpectedly linear because of a small variation in the number of steps.While this particular issue might not be harmful, we were able to learn and reason about its consequences after the verification process was done.Furthermore, minor bugs and even design decisions cannot be ignored as they can mask more complex mistakes.Therefore, one will be more confident after the design decisions that affect convergence are turned off and the expected convergence is recovered.The FP module, on the other hand, significantly deviates from the ideal number of steps required to march inside the volume.Although we could force VTK to march the expected number of steps, we are still investigating possible solutions to and consequences of this issue.To promote an unexpected behavior to a bug, we need interaction with the developers of the code to confirm the code mistake, which was the case with Voreen.One should be aware of the discussed issues when implementing a volume rendering algorithm as their consequences are often not discussed in the literature <41>.", "rank": 373, "paragraph_comparative_number": 7, "entities": [], "id": "p_373"}, "sentences": [{"end": 162421, "text": "The convergence analysis presented in the previous section helped us to identify un- expected behavior in two stable and widely-used frameworks.", "rank": 1373, "start": 162277, "IsComparative": "0", "id": "st_1373"}, {"end": 162530, "text": "Unexpected behavior is not indicative of an implementation bug but rather a warning about potential problems.", "rank": 1374, "start": 162421, "IsComparative": "1", "id": "st_1374"}, {"end": 162609, "text": "For instance, some valid design decisions might affect the convergence results.", "rank": 1375, "start": 162530, "IsComparative": "1", "id": "st_1375"}, {"end": 162661, "text": "Consider the widely used ERT acceleration technique.", "rank": 1376, "start": 162609, "IsComparative": "0", "id": "st_1376"}, {"end": 162821, "text": "Depending on the thresholds involved, the convergence results might deviate from the ideal, and the expected curve is recovered once this feature is turned off.", "rank": 1377, "start": 162661, "IsComparative": "0", "id": "st_1377"}, {"end": 162991, "text": "In this sense, the verification tool can help the developer to identify portions of the code that introduce numerical errors and quantify their effect on the final image.", "rank": 1378, "start": 162821, "IsComparative": "1", "id": "st_1378"}, {"end": 163040, "text": "The issue with the RCM module is another example.", "rank": 1379, "start": 162991, "IsComparative": "0", "id": "st_1379"}, {"end": 163151, "text": "The dataset size convergence curve was unexpectedly linear because of a small variation in the number of steps.", "rank": 1380, "start": 163040, "IsComparative": "1", "id": "st_1380"}, {"end": 163297, "text": "While this particular issue might not be harmful, we were able to learn and reason about its consequences after the verification process was done.", "rank": 1381, "start": 163151, "IsComparative": "1", "id": "st_1381"}, {"end": 163404, "text": "Furthermore, minor bugs and even design decisions cannot be ignored as they can mask more complex mistakes.", "rank": 1382, "start": 163297, "IsComparative": "0", "id": "st_1382"}, {"end": 163550, "text": "Therefore, one will be more confident after the design decisions that affect convergence are turned off and the expected convergence is recovered.", "rank": 1383, "start": 163404, "IsComparative": "1", "id": "st_1383"}, {"end": 163674, "text": "The FP module, on the other hand, significantly deviates from the ideal number of steps required to march inside the volume.", "rank": 1384, "start": 163550, "IsComparative": "0", "id": "st_1384"}, {"end": 163821, "text": "Although we could force VTK to march the expected number of steps, we are still investigating possible solutions to and consequences of this issue.", "rank": 1385, "start": 163674, "IsComparative": "0", "id": "st_1385"}, {"end": 163977, "text": "To promote an unexpected behavior to a bug, we need interaction with the developers of the code to confirm the code mistake, which was the case with Voreen.", "rank": 1386, "start": 163821, "IsComparative": "1", "id": "st_1386"}, {"end": 164137, "text": "One should be aware of the discussed issues when implementing a volume rendering algorithm as their consequences are often not discussed in the literature <41>.", "rank": 1387, "start": 163977, "IsComparative": "0", "id": "st_1387"}]}, {"paragraph_info": {"end": 164159, "start": 164137, "text": "5.6.1 Test Sensitivity", "rank": 374, "paragraph_comparative_number": 0, "entities": [], "id": "p_374"}, "sentences": [{"end": 164159, "text": "5.6.1 Test Sensitivity", "rank": 1388, "start": 164137, "IsComparative": "0", "id": "st_1388"}]}, {"paragraph_info": {"end": 164982, "start": 164159, "text": "A verification technique ideally should be sensitive to any deviation from the correct implementation.Unfortunately, in practice, verification has limited scope, and we gain confidence if it helps us understand the code behavior, test sensitivity, and reveal bugs.There are several ways to attain this goal: Yang et al.applied model checking to filesystem verification and reported unknown bugs <192>; Howden <65> evaluated the efficacy of dynamic and static testing for the detection of known real bugs of a mathematical library; Knupp and Salari <80>, on the other hand, used the order of accuracy verification procedure to uncover known manufactured bugs in a proof-of-concept code.In software engineering, the process of evaluating a testing suite by injecting defects into a program is known as mutation testing <142>.", "rank": 375, "paragraph_comparative_number": 0, "entities": [], "id": "p_375"}, "sentences": [{"end": 164261, "text": "A verification technique ideally should be sensitive to any deviation from the correct implementation.", "rank": 1389, "start": 164159, "IsComparative": "0", "id": "st_1389"}, {"end": 164423, "text": "Unfortunately, in practice, verification has limited scope, and we gain confidence if it helps us understand the code behavior, test sensitivity, and reveal bugs.", "rank": 1390, "start": 164261, "IsComparative": "0", "id": "st_1390"}, {"end": 164478, "text": "There are several ways to attain this goal: Yang et al.", "rank": 1391, "start": 164423, "IsComparative": "0", "id": "st_1391"}, {"end": 164844, "text": "applied model checking to filesystem verification and reported unknown bugs <192>; Howden <65> evaluated the efficacy of dynamic and static testing for the detection of known real bugs of a mathematical library; Knupp and Salari <80>, on the other hand, used the order of accuracy verification procedure to uncover known manufactured bugs in a proof-of-concept code.", "rank": 1392, "start": 164478, "IsComparative": "0", "id": "st_1392"}, {"end": 164982, "text": "In software engineering, the process of evaluating a testing suite by injecting defects into a program is known as mutation testing <142>.", "rank": 1393, "start": 164844, "IsComparative": "0", "id": "st_1393"}]}, {"paragraph_info": {"end": 166464, "start": 164982, "text": "We already presented the results of applying our verification framework to two libraries and with our experiments we confirm the previously reported sensitivity of convergence analysis <146>.We went further to explore other scenarios in volume rendering that may affect the convergence curve.Thus, in the spirit of mutation testing, we created new versions of VTK which contain known issues.Table 5.2 shows the results of some of the performed tests.In our experiments, we observed that some issues did not affect the observed behavior.The reason for this is that an incomplete set of tests <80> was performed, as shown with test #10 in Table 5.2.In that case, a bug in the G and B color lookups went unnoticed because our framework only used the R channel.Once the verification framework includes all three channels, the convergence behavior does not match the expectations, hence revealing an aberrant behavior that should be investigated.For bug #9, we swapped two of the polynomial coefficients, but they were equal for the scalar field used and thus the bug was not detected.After changing the scalar field to s(x, y, z) = 1xyz + 2xy + 3xz +    , the convergence curve no longer matches the expected one, and thus the bug is detected.Bug #11 was introduced in a matrix-vector multiplication routine which turned out to be dead code.However, for bug #12, the loop range was slightly incorrect and it was not detected, even after additional changes to the verification framework.", "rank": 376, "paragraph_comparative_number": 7, "entities": [], "id": "p_376"}, "sentences": [{"end": 165173, "text": "We already presented the results of applying our verification framework to two libraries and with our experiments we confirm the previously reported sensitivity of convergence analysis <146>.", "rank": 1394, "start": 164982, "IsComparative": "1", "id": "st_1394"}, {"end": 165274, "text": "We went further to explore other scenarios in volume rendering that may affect the convergence curve.", "rank": 1395, "start": 165173, "IsComparative": "0", "id": "st_1395"}, {"end": 165373, "text": "Thus, in the spirit of mutation testing, we created new versions of VTK which contain known issues.", "rank": 1396, "start": 165274, "IsComparative": "1", "id": "st_1396"}, {"end": 165432, "text": "Table 5.2 shows the results of some of the performed tests.", "rank": 1397, "start": 165373, "IsComparative": "0", "id": "st_1397"}, {"end": 165518, "text": "In our experiments, we observed that some issues did not affect the observed behavior.", "rank": 1398, "start": 165432, "IsComparative": "1", "id": "st_1398"}, {"end": 165629, "text": "The reason for this is that an incomplete set of tests <80> was performed, as shown with test #10 in Table 5.2.", "rank": 1399, "start": 165518, "IsComparative": "0", "id": "st_1399"}, {"end": 165739, "text": "In that case, a bug in the G and B color lookups went unnoticed because our framework only used the R channel.", "rank": 1400, "start": 165629, "IsComparative": "1", "id": "st_1400"}, {"end": 165923, "text": "Once the verification framework includes all three channels, the convergence behavior does not match the expectations, hence revealing an aberrant behavior that should be investigated.", "rank": 1401, "start": 165739, "IsComparative": "1", "id": "st_1401"}, {"end": 166062, "text": "For bug #9, we swapped two of the polynomial coefficients, but they were equal for the scalar field used and thus the bug was not detected.", "rank": 1402, "start": 165923, "IsComparative": "0", "id": "st_1402"}, {"end": 166221, "text": "After changing the scalar field to s(x, y, z) = 1xyz + 2xy + 3xz +    , the convergence curve no longer matches the expected one, and thus the bug is detected.", "rank": 1403, "start": 166062, "IsComparative": "1", "id": "st_1403"}, {"end": 166319, "text": "Bug #11 was introduced in a matrix-vector multiplication routine which turned out to be dead code.", "rank": 1404, "start": 166221, "IsComparative": "0", "id": "st_1404"}, {"end": 166464, "text": "However, for bug #12, the loop range was slightly incorrect and it was not detected, even after additional changes to the verification framework.", "rank": 1405, "start": 166319, "IsComparative": "1", "id": "st_1405"}]}, {"paragraph_info": {"end": 166902, "start": 166464, "text": "Aside from the defects injected into VTK, the following is a list of details known to affect the convergence curve: ERT, as explained before; opacity correction, when using the analytical solution of the volume rendering integral; hardcoded tolerance constants, the famous epsilons; off-by-one indexing problems (sometimes VTK does not render pixels in the first or last column of an image); improper volume sampling (cell centered versus", "rank": 377, "paragraph_comparative_number": 0, "entities": [], "id": "p_377"}, "sentences": [{"end": 166902, "text": "Aside from the defects injected into VTK, the following is a list of details known to affect the convergence curve: ERT, as explained before; opacity correction, when using the analytical solution of the volume rendering integral; hardcoded tolerance constants, the famous epsilons; off-by-one indexing problems (sometimes VTK does not render pixels in the first or last column of an image); improper volume sampling (cell centered versus", "rank": 1406, "start": 166464, "IsComparative": "0", "id": "st_1406"}]}, {"paragraph_info": {"end": 167364, "start": 166902, "text": "Manufactured Solutions <3> and can be a more rigorous procedure than convergence analysis alone <146>.In this way, we can verify that the results generated by an implementation is converging at the expected rate to the correct solution.The disadvantage lies in the difficulty of designing solutions which are simultaneously simple (so that we can write the theoretical convergence analysis down) and yet expressive (so that the experiment analysis catches bugs).", "rank": 378, "paragraph_comparative_number": 2, "entities": [], "id": "p_378"}, "sentences": [{"end": 167004, "text": "Manufactured Solutions <3> and can be a more rigorous procedure than convergence analysis alone <146>.", "rank": 1407, "start": 166902, "IsComparative": "1", "id": "st_1407"}, {"end": 167138, "text": "In this way, we can verify that the results generated by an implementation is converging at the expected rate to the correct solution.", "rank": 1408, "start": 167004, "IsComparative": "0", "id": "st_1408"}, {"end": 167364, "text": "The disadvantage lies in the difficulty of designing solutions which are simultaneously simple (so that we can write the theoretical convergence analysis down) and yet expressive (so that the experiment analysis catches bugs).", "rank": 1409, "start": 167138, "IsComparative": "1", "id": "st_1409"}]}, {"paragraph_info": {"end": 167379, "start": 167364, "text": "5.7 Limitations", "rank": 379, "paragraph_comparative_number": 0, "entities": [], "id": "p_379"}, "sentences": [{"end": 167379, "text": "5.7 Limitations", "rank": 1410, "start": 167364, "IsComparative": "0", "id": "st_1410"}]}, {"paragraph_info": {"end": 168140, "start": 167379, "text": "Both the discretization and verification procedures have limitations.In the discretization of the VRI equation, we assume that the solution I(x,y) is smooth.Moreover, we assume that high order terms are negligible.This assumption implies that we can safely discard all high order terms when deriving the errors.In addition, the verification is done in a controlled fashion to avoid other error sources, as shown in Figure 5.6(a).Additional asymptotic analysis is necessary for each new error source.Also, I must be defined everywhere in the image plane.For instance, this condition is violated if we change the camera position and orientation.One needs to account for these transformation in x(), an extra complication in the generation of analytical solutions.", "rank": 380, "paragraph_comparative_number": 3, "entities": [], "id": "p_380"}, "sentences": [{"end": 167448, "text": "Both the discretization and verification procedures have limitations.", "rank": 1411, "start": 167379, "IsComparative": "0", "id": "st_1411"}, {"end": 167536, "text": "In the discretization of the VRI equation, we assume that the solution I(x,y) is smooth.", "rank": 1412, "start": 167448, "IsComparative": "0", "id": "st_1412"}, {"end": 167593, "text": "Moreover, we assume that high order terms are negligible.", "rank": 1413, "start": 167536, "IsComparative": "1", "id": "st_1413"}, {"end": 167690, "text": "This assumption implies that we can safely discard all high order terms when deriving the errors.", "rank": 1414, "start": 167593, "IsComparative": "1", "id": "st_1414"}, {"end": 167808, "text": "In addition, the verification is done in a controlled fashion to avoid other error sources, as shown in Figure 5.6(a).", "rank": 1415, "start": 167690, "IsComparative": "0", "id": "st_1415"}, {"end": 167878, "text": "Additional asymptotic analysis is necessary for each new error source.", "rank": 1416, "start": 167808, "IsComparative": "0", "id": "st_1416"}, {"end": 167932, "text": "Also, I must be defined everywhere in the image plane.", "rank": 1417, "start": 167878, "IsComparative": "0", "id": "st_1417"}, {"end": 168022, "text": "For instance, this condition is violated if we change the camera position and orientation.", "rank": 1418, "start": 167932, "IsComparative": "0", "id": "st_1418"}, {"end": 168140, "text": "One needs to account for these transformation in x(), an extra complication in the generation of analytical solutions.", "rank": 1419, "start": 168022, "IsComparative": "1", "id": "st_1419"}]}, {"paragraph_info": {"end": 169108, "start": 168140, "text": "The verification process has the same limitations previously described but it also has practical limitations.For instance, one may be able to observe that the convergence rate may not be the expected one for low sampling rates.However, this is not due to the random scalar field generated (which is a trilinear function and thus can be represented exactly with the trilinear interpolant) but high-frequency details in  or C.This may lead to a violation of the Nyquist rate.Because the process is iterative, the expected convergence must be recovered once the resolution is fine enough, assuming that the implementation under verification is correct.Another limitation is related to the number of rays used per pixel.Many implementations can shoot several rays per pixel, although this work assumes that only one ray is used.Also, because the verification procedure considers the code as a blackbox, it does not provide clues on the reasons for the unexpected behavior.", "rank": 381, "paragraph_comparative_number": 2, "entities": [], "id": "p_381"}, "sentences": [{"end": 168249, "text": "The verification process has the same limitations previously described but it also has practical limitations.", "rank": 1420, "start": 168140, "IsComparative": "0", "id": "st_1420"}, {"end": 168367, "text": "For instance, one may be able to observe that the convergence rate may not be the expected one for low sampling rates.", "rank": 1421, "start": 168249, "IsComparative": "1", "id": "st_1421"}, {"end": 168564, "text": "However, this is not due to the random scalar field generated (which is a trilinear function and thus can be represented exactly with the trilinear interpolant) but high-frequency details in  or C.", "rank": 1422, "start": 168367, "IsComparative": "1", "id": "st_1422"}, {"end": 168613, "text": "This may lead to a violation of the Nyquist rate.", "rank": 1423, "start": 168564, "IsComparative": "0", "id": "st_1423"}, {"end": 168789, "text": "Because the process is iterative, the expected convergence must be recovered once the resolution is fine enough, assuming that the implementation under verification is correct.", "rank": 1424, "start": 168613, "IsComparative": "0", "id": "st_1424"}, {"end": 168856, "text": "Another limitation is related to the number of rays used per pixel.", "rank": 1425, "start": 168789, "IsComparative": "0", "id": "st_1425"}, {"end": 168964, "text": "Many implementations can shoot several rays per pixel, although this work assumes that only one ray is used.", "rank": 1426, "start": 168856, "IsComparative": "0", "id": "st_1426"}, {"end": 169108, "text": "Also, because the verification procedure considers the code as a blackbox, it does not provide clues on the reasons for the unexpected behavior.", "rank": 1427, "start": 168964, "IsComparative": "0", "id": "st_1427"}]}, {"paragraph_info": {"end": 169634, "start": 169108, "text": "The scope of the mistakes that can be found by the verification procedure is not clearly defined.All we can say is that it can find bugs that actively affects the convergence of the method <80>.A common example of bugs that cannot be found by this type of procedure are bugs that affect the performance: the code is slower due to the mistake but the convergence rate is still the same <143>.The results shown in Table 5.2 are a first attempt to understand the scope of problems that can be fixed by the verification procedure.", "rank": 382, "paragraph_comparative_number": 2, "entities": [], "id": "p_382"}, "sentences": [{"end": 169205, "text": "The scope of the mistakes that can be found by the verification procedure is not clearly defined.", "rank": 1428, "start": 169108, "IsComparative": "0", "id": "st_1428"}, {"end": 169302, "text": "All we can say is that it can find bugs that actively affects the convergence of the method <80>.", "rank": 1429, "start": 169205, "IsComparative": "1", "id": "st_1429"}, {"end": 169499, "text": "A common example of bugs that cannot be found by this type of procedure are bugs that affect the performance: the code is slower due to the mistake but the convergence rate is still the same <143>.", "rank": 1430, "start": 169302, "IsComparative": "1", "id": "st_1430"}, {"end": 169634, "text": "The results shown in Table 5.2 are a first attempt to understand the scope of problems that can be fixed by the verification procedure.", "rank": 1431, "start": 169499, "IsComparative": "0", "id": "st_1431"}]}, {"paragraph_info": {"end": 170062, "start": 169634, "text": "Currently, our verification procedure is focused on the solution for the VRI without shading and other improvements on the final image quality.Hence, if one wants to use our verification procedure in an implementation that supports, for instance, shading, the feature will need to be deactivated.Lastly, for the case of dataset refinement, we assume that the underlying scalar field is defined by a piecewise-trilinear function.", "rank": 383, "paragraph_comparative_number": 2, "entities": [], "id": "p_383"}, "sentences": [{"end": 169777, "text": "Currently, our verification procedure is focused on the solution for the VRI without shading and other improvements on the final image quality.", "rank": 1432, "start": 169634, "IsComparative": "1", "id": "st_1432"}, {"end": 169930, "text": "Hence, if one wants to use our verification procedure in an implementation that supports, for instance, shading, the feature will need to be deactivated.", "rank": 1433, "start": 169777, "IsComparative": "1", "id": "st_1433"}, {"end": 170062, "text": "Lastly, for the case of dataset refinement, we assume that the underlying scalar field is defined by a piecewise-trilinear function.", "rank": 1434, "start": 169930, "IsComparative": "0", "id": "st_1434"}]}, {"paragraph_info": {"end": 170076, "start": 170062, "text": "5.8 Conclusion", "rank": 384, "paragraph_comparative_number": 0, "entities": [], "id": "p_384"}, "sentences": [{"end": 170076, "text": "5.8 Conclusion", "rank": 1435, "start": 170062, "IsComparative": "0", "id": "st_1435"}]}, {"paragraph_info": {"end": 171042, "start": 170076, "text": "In this chapter, we presented verification techniques for volume rendering based on the use of convergence analysis.Using these techniques, we successfully found discrepan- cies in the behavior of the volume rendering algorithms of two widely-used visualization packages.We note that we do not see our techniques as a replacement for the currently used direct visual inspection or expert evaluations, but instead as a way to complement those approaches, and lead to a more comprehensive way to evaluate visualization software.By providing attractive quantitative alternatives, we hope to help make evaluation of visualization software both easier and more effective, and also contribute to a higher level of user trust in visual data analysis.We believe the use of verification techniques will be of increasing importance as the field of visualization matures and visualization methods are used in a wide range of commercial and societal areas of highest importance.", "rank": 385, "paragraph_comparative_number": 3, "entities": [], "id": "p_385"}, "sentences": [{"end": 170192, "text": "In this chapter, we presented verification techniques for volume rendering based on the use of convergence analysis.", "rank": 1436, "start": 170076, "IsComparative": "0", "id": "st_1436"}, {"end": 170347, "text": "Using these techniques, we successfully found discrepan- cies in the behavior of the volume rendering algorithms of two widely-used visualization packages.", "rank": 1437, "start": 170192, "IsComparative": "1", "id": "st_1437"}, {"end": 170602, "text": "We note that we do not see our techniques as a replacement for the currently used direct visual inspection or expert evaluations, but instead as a way to complement those approaches, and lead to a more comprehensive way to evaluate visualization software.", "rank": 1438, "start": 170347, "IsComparative": "1", "id": "st_1438"}, {"end": 170819, "text": "By providing attractive quantitative alternatives, we hope to help make evaluation of visualization software both easier and more effective, and also contribute to a higher level of user trust in visual data analysis.", "rank": 1439, "start": 170602, "IsComparative": "1", "id": "st_1439"}, {"end": 171042, "text": "We believe the use of verification techniques will be of increasing importance as the field of visualization matures and visualization methods are used in a wide range of commercial and societal areas of highest importance.", "rank": 1440, "start": 170819, "IsComparative": "0", "id": "st_1440"}]}, {"paragraph_info": {"end": 171627, "start": 171042, "text": "There is ample opportunity for future work.Extending our approach to deal with volume shading and level-of-detail techniques would be interesting and relevant research as these are widely used in practice.Another important problem would be to explore the verification of unstructured volume rendering techniques.Lastly, there is room for improving the approximation error for the three presented refinements.In addition, a new way for comparing the convergence curves that allows one to gain insight on the correctness of the implementation under verification is another welcomed step.", "rank": 386, "paragraph_comparative_number": 2, "entities": [], "id": "p_386"}, "sentences": [{"end": 171085, "text": "There is ample opportunity for future work.", "rank": 1441, "start": 171042, "IsComparative": "0", "id": "st_1441"}, {"end": 171247, "text": "Extending our approach to deal with volume shading and level-of-detail techniques would be interesting and relevant research as these are widely used in practice.", "rank": 1442, "start": 171085, "IsComparative": "1", "id": "st_1442"}, {"end": 171354, "text": "Another important problem would be to explore the verification of unstructured volume rendering techniques.", "rank": 1443, "start": 171247, "IsComparative": "0", "id": "st_1443"}, {"end": 171450, "text": "Lastly, there is room for improving the approximation error for the three presented refinements.", "rank": 1444, "start": 171354, "IsComparative": "0", "id": "st_1444"}, {"end": 171627, "text": "In addition, a new way for comparing the convergence curves that allows one to gain insight on the correctness of the implementation under verification is another welcomed step.", "rank": 1445, "start": 171450, "IsComparative": "1", "id": "st_1445"}]}, {"paragraph_info": {"end": 171655, "start": 171627, "text": "CHAPTER 6 FLOW VISUALIZATION", "rank": 387, "paragraph_comparative_number": 0, "entities": [], "id": "p_387"}, "sentences": [{"end": 171655, "text": "CHAPTER 6 FLOW VISUALIZATION", "rank": 1446, "start": 171627, "IsComparative": "0", "id": "st_1446"}]}, {"paragraph_info": {"end": 172753, "start": 171655, "text": "Flow visualization has been around in some form for as long as people have studied flows.In some cases, visualization was done explicitly  that is, with the expressed purpose of the viewer to highlight some feature of the flow.In other cases, it was done tacitly, as when a child looks out the window of an airplane to see the slip-stream over the wing generated upon take-off.Visualization has many roles, spanning from art to science.In this chapter, we focused on visualization techniques used for the scientific exploration and explanation of flow phenomena.In particular, we are interested in how two communities  the AIAA community and the Visualization community  consider flow visualization.To accomplish this task, we have used the AIAA Journal and the IEEE Transactions on Visualization and Computer Graphics (TVCG) as representative publication venues of the two communities, and have explored the papers published therein to try to glean how each community approaches visualization of flow, how they might differ from each other, and how the two communities might complement each other.", "rank": 388, "paragraph_comparative_number": 3, "entities": [], "id": "p_388"}, "sentences": [{"end": 171744, "text": "Flow visualization has been around in some form for as long as people have studied flows.", "rank": 1447, "start": 171655, "IsComparative": "0", "id": "st_1447"}, {"end": 171882, "text": "In some cases, visualization was done explicitly  that is, with the expressed purpose of the viewer to highlight some feature of the flow.", "rank": 1448, "start": 171744, "IsComparative": "0", "id": "st_1448"}, {"end": 172032, "text": "In other cases, it was done tacitly, as when a child looks out the window of an airplane to see the slip-stream over the wing generated upon take-off.", "rank": 1449, "start": 171882, "IsComparative": "1", "id": "st_1449"}, {"end": 172091, "text": "Visualization has many roles, spanning from art to science.", "rank": 1450, "start": 172032, "IsComparative": "1", "id": "st_1450"}, {"end": 172217, "text": "In this chapter, we focused on visualization techniques used for the scientific exploration and explanation of flow phenomena.", "rank": 1451, "start": 172091, "IsComparative": "0", "id": "st_1451"}, {"end": 172354, "text": "In particular, we are interested in how two communities  the AIAA community and the Visualization community  consider flow visualization.", "rank": 1452, "start": 172217, "IsComparative": "0", "id": "st_1452"}, {"end": 172753, "text": "To accomplish this task, we have used the AIAA Journal and the IEEE Transactions on Visualization and Computer Graphics (TVCG) as representative publication venues of the two communities, and have explored the papers published therein to try to glean how each community approaches visualization of flow, how they might differ from each other, and how the two communities might complement each other.", "rank": 1453, "start": 172354, "IsComparative": "1", "id": "st_1453"}]}, {"paragraph_info": {"end": 174119, "start": 172753, "text": "This chapter is organized as follows.In Section 6.1, we provide a review of the state-of- the-art in flow visualization, both from the perspective of the Visualization and well as the AIAA communities.Tools such as Tecplot <2> and Paraview <163> have implemented many standard flow visualization techniques such as LIC (line integral convolution), streamlines, stream ribbons, and more.As we will show, our review encompasses much of the current practices in flow visualization and also provide pointers to new developments.In the next two sections, we focus our attention on research advances made within the Visualization community that we think will, in time, have impact on flow visualization and on other application domains that use visualization as a means of both scientific exploration and explanation.In Section 6.2, we show how perception and user studies may impact flow visualization, and in particular, we focus on issues related to color maps.In Section 6.3, we then provide discussions on the current Visualization community research trends in Visualization Verification and Uncertainty Quantification.We have chosen these topics because they are all related to flow visualization.In Section 6.4, we speculate on some of the opportunities for collaboration and more effective communication between the two communities, and we conclude in Section 6.5.", "rank": 389, "paragraph_comparative_number": 5, "entities": [], "id": "p_389"}, "sentences": [{"end": 172790, "text": "This chapter is organized as follows.", "rank": 1454, "start": 172753, "IsComparative": "0", "id": "st_1454"}, {"end": 172954, "text": "In Section 6.1, we provide a review of the state-of- the-art in flow visualization, both from the perspective of the Visualization and well as the AIAA communities.", "rank": 1455, "start": 172790, "IsComparative": "1", "id": "st_1455"}, {"end": 173139, "text": "Tools such as Tecplot <2> and Paraview <163> have implemented many standard flow visualization techniques such as LIC (line integral convolution), streamlines, stream ribbons, and more.", "rank": 1456, "start": 172954, "IsComparative": "1", "id": "st_1456"}, {"end": 173277, "text": "As we will show, our review encompasses much of the current practices in flow visualization and also provide pointers to new developments.", "rank": 1457, "start": 173139, "IsComparative": "1", "id": "st_1457"}, {"end": 173564, "text": "In the next two sections, we focus our attention on research advances made within the Visualization community that we think will, in time, have impact on flow visualization and on other application domains that use visualization as a means of both scientific exploration and explanation.", "rank": 1458, "start": 173277, "IsComparative": "1", "id": "st_1458"}, {"end": 173711, "text": "In Section 6.2, we show how perception and user studies may impact flow visualization, and in particular, we focus on issues related to color maps.", "rank": 1459, "start": 173564, "IsComparative": "0", "id": "st_1459"}, {"end": 173871, "text": "In Section 6.3, we then provide discussions on the current Visualization community research trends in Visualization Verification and Uncertainty Quantification.", "rank": 1460, "start": 173711, "IsComparative": "0", "id": "st_1460"}, {"end": 173950, "text": "We have chosen these topics because they are all related to flow visualization.", "rank": 1461, "start": 173871, "IsComparative": "0", "id": "st_1461"}, {"end": 174119, "text": "In Section 6.4, we speculate on some of the opportunities for collaboration and more effective communication between the two communities, and we conclude in Section 6.5.", "rank": 1462, "start": 173950, "IsComparative": "1", "id": "st_1462"}]}, {"paragraph_info": {"end": 174162, "start": 174119, "text": "6.1 Review of Flow Visualization Techniques", "rank": 390, "paragraph_comparative_number": 1, "entities": [], "id": "p_390"}, "sentences": [{"end": 174162, "text": "6.1 Review of Flow Visualization Techniques", "rank": 1463, "start": 174119, "IsComparative": "1", "id": "st_1463"}]}, {"paragraph_info": {"end": 175035, "start": 174162, "text": "Vector field visualization is an important and vibrant subfield of both the Visualization and AIAA communities.The techniques developed for vector field visualization extend beyond these communities to fields such as medical imaging, meteorology, the automotive industry, and others.In the past two decades, visualization experts and practitioners have seen the development and improvement of many vector field visualization techniques.The contributions are numerous: the ability of handling different grid types (structured, unstructured, curvilinear, etc), high dimension data (2D, 2.5D, and 3D), time-dependent flow, seeding and placement of geometric primitives, improved performance, perception, rendering, among others.In this section, we review some of the developments inside the Visualization community and compare with current practices inside the AIAA community.", "rank": 391, "paragraph_comparative_number": 2, "entities": [], "id": "p_391"}, "sentences": [{"end": 174273, "text": "Vector field visualization is an important and vibrant subfield of both the Visualization and AIAA communities.", "rank": 1464, "start": 174162, "IsComparative": "0", "id": "st_1464"}, {"end": 174445, "text": "The techniques developed for vector field visualization extend beyond these communities to fields such as medical imaging, meteorology, the automotive industry, and others.", "rank": 1465, "start": 174273, "IsComparative": "0", "id": "st_1465"}, {"end": 174598, "text": "In the past two decades, visualization experts and practitioners have seen the development and improvement of many vector field visualization techniques.", "rank": 1466, "start": 174445, "IsComparative": "1", "id": "st_1466"}, {"end": 174887, "text": "The contributions are numerous: the ability of handling different grid types (structured, unstructured, curvilinear, etc), high dimension data (2D, 2.5D, and 3D), time-dependent flow, seeding and placement of geometric primitives, improved performance, perception, rendering, among others.", "rank": 1467, "start": 174598, "IsComparative": "1", "id": "st_1467"}, {"end": 175035, "text": "In this section, we review some of the developments inside the Visualization community and compare with current practices inside the AIAA community.", "rank": 1468, "start": 174887, "IsComparative": "0", "id": "st_1468"}]}, {"paragraph_info": {"end": 175054, "start": 175035, "text": "6.1.1 Preliminaries", "rank": 392, "paragraph_comparative_number": 0, "entities": [], "id": "p_392"}, "sentences": [{"end": 175054, "text": "6.1.1 Preliminaries", "rank": 1469, "start": 175035, "IsComparative": "0", "id": "st_1469"}]}, {"paragraph_info": {"end": 175730, "start": 175054, "text": "Although the concept of flow visualization is well defined in both communities, we start by clarifying what is meant by flow visualization in this section.The difference between computational flow visualization and flow visualization is that the latter focus on visualization of flow behavior using experimental data (e.g., flow in a wind tunnel), whereas the former visualizes flow from simulated or computed data.Some computational visualization techniques are inspired by techniques used in flow visualization, such as dye advection.Since the subject of this section only addresses computational flow visualization, we will refer to that topic simply as flow visualization.", "rank": 393, "paragraph_comparative_number": 2, "entities": [], "id": "p_393"}, "sentences": [{"end": 175209, "text": "Although the concept of flow visualization is well defined in both communities, we start by clarifying what is meant by flow visualization in this section.", "rank": 1470, "start": 175054, "IsComparative": "1", "id": "st_1470"}, {"end": 175469, "text": "The difference between computational flow visualization and flow visualization is that the latter focus on visualization of flow behavior using experimental data (e.g., flow in a wind tunnel), whereas the former visualizes flow from simulated or computed data.", "rank": 1471, "start": 175209, "IsComparative": "0", "id": "st_1471"}, {"end": 175590, "text": "Some computational visualization techniques are inspired by techniques used in flow visualization, such as dye advection.", "rank": 1472, "start": 175469, "IsComparative": "0", "id": "st_1472"}, {"end": 175730, "text": "Since the subject of this section only addresses computational flow visualization, we will refer to that topic simply as flow visualization.", "rank": 1473, "start": 175590, "IsComparative": "1", "id": "st_1473"}]}, {"paragraph_info": {"end": 176273, "start": 175730, "text": "For thoroughness, we also define some commonly used mathematical/physical terms used within the flow visualization literature.A streamline is the path traced by a massless particle in a steady flow.Streamlines are sometimes referred to as instantaneous particle trace.A streakline is the path traced by massless particles seeded at the same position but at different times in a unsteady flow.Stream surfaces and streak surfaces are the 2-manifold analog of streamlines and streakline, where the seeding primitive is a curve instead of a point.", "rank": 394, "paragraph_comparative_number": 1, "entities": [], "id": "p_394"}, "sentences": [{"end": 175856, "text": "For thoroughness, we also define some commonly used mathematical/physical terms used within the flow visualization literature.", "rank": 1474, "start": 175730, "IsComparative": "0", "id": "st_1474"}, {"end": 175928, "text": "A streamline is the path traced by a massless particle in a steady flow.", "rank": 1475, "start": 175856, "IsComparative": "0", "id": "st_1475"}, {"end": 175998, "text": "Streamlines are sometimes referred to as instantaneous particle trace.", "rank": 1476, "start": 175928, "IsComparative": "0", "id": "st_1476"}, {"end": 176122, "text": "A streakline is the path traced by massless particles seeded at the same position but at different times in a unsteady flow.", "rank": 1477, "start": 175998, "IsComparative": "0", "id": "st_1477"}, {"end": 176273, "text": "Stream surfaces and streak surfaces are the 2-manifold analog of streamlines and streakline, where the seeding primitive is a curve instead of a point.", "rank": 1478, "start": 176122, "IsComparative": "1", "id": "st_1478"}]}, {"paragraph_info": {"end": 176300, "start": 176273, "text": "6.1.2 Classes of Techniques", "rank": 395, "paragraph_comparative_number": 1, "entities": [], "id": "p_395"}, "sentences": [{"end": 176300, "text": "6.1.2 Classes of Techniques", "rank": 1479, "start": 176273, "IsComparative": "1", "id": "st_1479"}]}, {"paragraph_info": {"end": 177268, "start": 176300, "text": "Flow visualization techniques can be classified as direct, geometric, texture-, and feature- based (see Figure 6.1).Table 6.1 provides an overview of the classification and a subset of the available techniques within each class.The table provides a hierarchy of the flow visualization tools available.The Subclass column provides the main component of a given visualization techniques that can be found within the Technique column.One can find reference to extra material within the Reference column.For more details about the articles shown in Table 6.1 and others, we refer the interested reader to the excellent surveys by Hauser et al.<60> and Peng and Laramee <134> for an overview of the flow visualization field, Edmunds et al.<38> and McLoughlin et al.<108> for geometric flow visualization, Laramee et al.<88, 87> for texture-based flow visualization, and Pobitzer et al.<136> for feature-based flow visualization.Next, we briefly go over each of the classes.", "rank": 396, "paragraph_comparative_number": 7, "entities": [], "id": "p_396"}, "sentences": [{"end": 176416, "text": "Flow visualization techniques can be classified as direct, geometric, texture-, and feature- based (see Figure 6.1).", "rank": 1480, "start": 176300, "IsComparative": "1", "id": "st_1480"}, {"end": 176528, "text": "Table 6.1 provides an overview of the classification and a subset of the available techniques within each class.", "rank": 1481, "start": 176416, "IsComparative": "0", "id": "st_1481"}, {"end": 176601, "text": "The table provides a hierarchy of the flow visualization tools available.", "rank": 1482, "start": 176528, "IsComparative": "1", "id": "st_1482"}, {"end": 176731, "text": "The Subclass column provides the main component of a given visualization techniques that can be found within the Technique column.", "rank": 1483, "start": 176601, "IsComparative": "1", "id": "st_1483"}, {"end": 176800, "text": "One can find reference to extra material within the Reference column.", "rank": 1484, "start": 176731, "IsComparative": "0", "id": "st_1484"}, {"end": 176939, "text": "For more details about the articles shown in Table 6.1 and others, we refer the interested reader to the excellent surveys by Hauser et al.", "rank": 1485, "start": 176800, "IsComparative": "0", "id": "st_1485"}, {"end": 177034, "text": "<60> and Peng and Laramee <134> for an overview of the flow visualization field, Edmunds et al.", "rank": 1486, "start": 176939, "IsComparative": "1", "id": "st_1486"}, {"end": 177060, "text": "<38> and McLoughlin et al.", "rank": 1487, "start": 177034, "IsComparative": "1", "id": "st_1487"}, {"end": 177114, "text": "<108> for geometric flow visualization, Laramee et al.", "rank": 1488, "start": 177060, "IsComparative": "1", "id": "st_1488"}, {"end": 177180, "text": "<88, 87> for texture-based flow visualization, and Pobitzer et al.", "rank": 1489, "start": 177114, "IsComparative": "0", "id": "st_1489"}, {"end": 177223, "text": "<136> for feature-based flow visualization.", "rank": 1490, "start": 177180, "IsComparative": "1", "id": "st_1490"}, {"end": 177268, "text": "Next, we briefly go over each of the classes.", "rank": 1491, "start": 177223, "IsComparative": "0", "id": "st_1491"}]}, {"paragraph_info": {"end": 177296, "start": 177268, "text": "6.1.2.1 Direct visualization", "rank": 397, "paragraph_comparative_number": 0, "entities": [], "id": "p_397"}, "sentences": [{"end": 177296, "text": "6.1.2.1 Direct visualization", "rank": 1492, "start": 177268, "IsComparative": "0", "id": "st_1492"}]}, {"paragraph_info": {"end": 178074, "start": 177296, "text": "Direct visualization techniques provide an intuitive and straightforward way of visual- izing vector fields.In this approach, primitives of interest  such as arrows, glyphs, or lines  are placed at (often regularly-spaced) seed points.The primitives are then oriented according to the vector field.Optionally, the vector magnitude can be mapped to the primitives via scaling.Other flow properties, such as pressure and vorticity, can also be mapped using color maps.In the 3D case, volume rendering <40> is the natural choice for mapping flow properties into color and transparency.Although direct visualization provides an easy first approximation of the vector field, the visual complexity and occlusion may impair the interpretation of the results, especially in 3D datasets.", "rank": 398, "paragraph_comparative_number": 4, "entities": [], "id": "p_398"}, "sentences": [{"end": 177404, "text": "Direct visualization techniques provide an intuitive and straightforward way of visual- izing vector fields.", "rank": 1493, "start": 177296, "IsComparative": "1", "id": "st_1493"}, {"end": 177531, "text": "In this approach, primitives of interest  such as arrows, glyphs, or lines  are placed at (often regularly-spaced) seed points.", "rank": 1494, "start": 177404, "IsComparative": "0", "id": "st_1494"}, {"end": 177594, "text": "The primitives are then oriented according to the vector field.", "rank": 1495, "start": 177531, "IsComparative": "0", "id": "st_1495"}, {"end": 177671, "text": "Optionally, the vector magnitude can be mapped to the primitives via scaling.", "rank": 1496, "start": 177594, "IsComparative": "0", "id": "st_1496"}, {"end": 177762, "text": "Other flow properties, such as pressure and vorticity, can also be mapped using color maps.", "rank": 1497, "start": 177671, "IsComparative": "1", "id": "st_1497"}, {"end": 177878, "text": "In the 3D case, volume rendering <40> is the natural choice for mapping flow properties into color and transparency.", "rank": 1498, "start": 177762, "IsComparative": "1", "id": "st_1498"}, {"end": 178074, "text": "Although direct visualization provides an easy first approximation of the vector field, the visual complexity and occlusion may impair the interpretation of the results, especially in 3D datasets.", "rank": 1499, "start": 177878, "IsComparative": "1", "id": "st_1499"}]}, {"paragraph_info": {"end": 178105, "start": 178074, "text": "6.1.2.2 Geometric visualization", "rank": 399, "paragraph_comparative_number": 0, "entities": [], "id": "p_399"}, "sentences": [{"end": 178105, "text": "6.1.2.2 Geometric visualization", "rank": 1500, "start": 178074, "IsComparative": "0", "id": "st_1500"}]}, {"paragraph_info": {"end": 180025, "start": 178105, "text": "In geometric visualization, curves and surfaces are used for summarizing flow behavior at particular seed points.Geometry-based approaches requires a more intensive processing of the data before the visualization than direct approaches.The main idea behind integration- based geometric flow visualization is to trace particles or curves through the vector field.By tracing particles (or respectively curves) one builds a 1-manifold (or respectively a 2-manifold) that can later be visualized.Geometric visualization techniques have a two steps: first, geometry computation; and secondly, rendering.Often, the rendering step is straightforward  e.g., rendering a polyline  in which case the algorithm collapses into one step.Streamlines are one of the most well-known representative visualization tools within this class.Although flow visualization using both curves and surface dates back over two decades, in recent years, there has been constant research on the topic <38>.For curves, the main contributions of the past decade are related to rendering, seeding, and placement of curves.Edmunds et al.<38> classify the surface-based flow visualization into surface construction and rendering.Methods for surface construction are based on integral surface, implicit, and topological construction.This is an area of intense research in the past few years.The authors present a variety of algorithm for both steady and time-dependent surfaces.Surface rendering methods involve the use of several techniques for improving the quality of the visualization of the flow over a surface of interest.Surface-based techniques can take advantages of direct or texture-based methods by including static/animated arrows over stream surfaces, shading for the evaluation of the shape of surfaces, placing streamlines over 3D surfaces, employing line-integral convolution (LIC) techniques, and/or nonphotorealistic rendering techniques.", "rank": 400, "paragraph_comparative_number": 8, "entities": [], "id": "p_400"}, "sentences": [{"end": 178218, "text": "In geometric visualization, curves and surfaces are used for summarizing flow behavior at particular seed points.", "rank": 1501, "start": 178105, "IsComparative": "1", "id": "st_1501"}, {"end": 178341, "text": "Geometry-based approaches requires a more intensive processing of the data before the visualization than direct approaches.", "rank": 1502, "start": 178218, "IsComparative": "1", "id": "st_1502"}, {"end": 178467, "text": "The main idea behind integration- based geometric flow visualization is to trace particles or curves through the vector field.", "rank": 1503, "start": 178341, "IsComparative": "1", "id": "st_1503"}, {"end": 178597, "text": "By tracing particles (or respectively curves) one builds a 1-manifold (or respectively a 2-manifold) that can later be visualized.", "rank": 1504, "start": 178467, "IsComparative": "0", "id": "st_1504"}, {"end": 178703, "text": "Geometric visualization techniques have a two steps: first, geometry computation; and secondly, rendering.", "rank": 1505, "start": 178597, "IsComparative": "1", "id": "st_1505"}, {"end": 178829, "text": "Often, the rendering step is straightforward  e.g., rendering a polyline  in which case the algorithm collapses into one step.", "rank": 1506, "start": 178703, "IsComparative": "1", "id": "st_1506"}, {"end": 178925, "text": "Streamlines are one of the most well-known representative visualization tools within this class.", "rank": 1507, "start": 178829, "IsComparative": "0", "id": "st_1507"}, {"end": 179080, "text": "Although flow visualization using both curves and surface dates back over two decades, in recent years, there has been constant research on the topic <38>.", "rank": 1508, "start": 178925, "IsComparative": "1", "id": "st_1508"}, {"end": 179193, "text": "For curves, the main contributions of the past decade are related to rendering, seeding, and placement of curves.", "rank": 1509, "start": 179080, "IsComparative": "0", "id": "st_1509"}, {"end": 179207, "text": "Edmunds et al.", "rank": 1510, "start": 179193, "IsComparative": "0", "id": "st_1510"}, {"end": 179298, "text": "<38> classify the surface-based flow visualization into surface construction and rendering.", "rank": 1511, "start": 179207, "IsComparative": "0", "id": "st_1511"}, {"end": 179401, "text": "Methods for surface construction are based on integral surface, implicit, and topological construction.", "rank": 1512, "start": 179298, "IsComparative": "0", "id": "st_1512"}, {"end": 179459, "text": "This is an area of intense research in the past few years.", "rank": 1513, "start": 179401, "IsComparative": "1", "id": "st_1513"}, {"end": 179546, "text": "The authors present a variety of algorithm for both steady and time-dependent surfaces.", "rank": 1514, "start": 179459, "IsComparative": "0", "id": "st_1514"}, {"end": 179696, "text": "Surface rendering methods involve the use of several techniques for improving the quality of the visualization of the flow over a surface of interest.", "rank": 1515, "start": 179546, "IsComparative": "0", "id": "st_1515"}, {"end": 180025, "text": "Surface-based techniques can take advantages of direct or texture-based methods by including static/animated arrows over stream surfaces, shading for the evaluation of the shape of surfaces, placing streamlines over 3D surfaces, employing line-integral convolution (LIC) techniques, and/or nonphotorealistic rendering techniques.", "rank": 1516, "start": 179696, "IsComparative": "1", "id": "st_1516"}]}, {"paragraph_info": {"end": 180060, "start": 180025, "text": "6.1.2.3 Feature-based visualization", "rank": 401, "paragraph_comparative_number": 0, "entities": [], "id": "p_401"}, "sentences": [{"end": 180060, "text": "6.1.2.3 Feature-based visualization", "rank": 1517, "start": 180025, "IsComparative": "0", "id": "st_1517"}]}, {"paragraph_info": {"end": 182079, "start": 180060, "text": "In feature-based flow visualization, the input vector field is segmented according to features of interest.As an example, consider a segmentation using classical vector field topology in 2D <61> (see also the right image in Figure 6.1).Let us assume that the features of interest are first order critical points, namely, focus source, focus sink, node source, node sink, and saddles.A segmentation is performed by building a topological skeleton through the computation of the vector fields separatrices.The final result provides a cleaner representation of the flow behavior in terms of the aforementioned features.The intensive processing of extracting features before visualization brings many advantages to the practitioner.First, feature-based techniques are valuable for visualization purposes: feature extraction provides an excellent level of abstraction of the data by removing unde- sired features and focusing the viewer on the important regions of the dataset.In addition, it can be used for vector field compressing, topological simplification, and even for building custom vector fields <170>.Topology-based approaches for feature-based visualization is not the only methodology available.In Lagrangian methods, the trajectories of particles are used to describe and segment the fluid flow.In particular, FLTE <58> methods have gained prominence as a research area within the last decade.One advantage of Lagrangian methods over traditional vector field topology is that they can naturally deal with unsteady flow <136>.Space-time domain techniques are another example of feature-based visualization.In this approach, in order to deal with the problems involved in unsteady flows, the problem of 2D and 3D flow visualization is moved to higher dimensions.As an example, time-dependent domains are merged into a single dataset where traditional techniques used for steady vector fields can be employed.A comprehensive survey on the topic can be found in the state-of-the-art report by Pobitzer et al.<136>.", "rank": 402, "paragraph_comparative_number": 6, "entities": [], "id": "p_402"}, "sentences": [{"end": 180167, "text": "In feature-based flow visualization, the input vector field is segmented according to features of interest.", "rank": 1518, "start": 180060, "IsComparative": "0", "id": "st_1518"}, {"end": 180296, "text": "As an example, consider a segmentation using classical vector field topology in 2D <61> (see also the right image in Figure 6.1).", "rank": 1519, "start": 180167, "IsComparative": "0", "id": "st_1519"}, {"end": 180443, "text": "Let us assume that the features of interest are first order critical points, namely, focus source, focus sink, node source, node sink, and saddles.", "rank": 1520, "start": 180296, "IsComparative": "0", "id": "st_1520"}, {"end": 180564, "text": "A segmentation is performed by building a topological skeleton through the computation of the vector fields separatrices.", "rank": 1521, "start": 180443, "IsComparative": "1", "id": "st_1521"}, {"end": 180676, "text": "The final result provides a cleaner representation of the flow behavior in terms of the aforementioned features.", "rank": 1522, "start": 180564, "IsComparative": "0", "id": "st_1522"}, {"end": 180788, "text": "The intensive processing of extracting features before visualization brings many advantages to the practitioner.", "rank": 1523, "start": 180676, "IsComparative": "1", "id": "st_1523"}, {"end": 181032, "text": "First, feature-based techniques are valuable for visualization purposes: feature extraction provides an excellent level of abstraction of the data by removing unde- sired features and focusing the viewer on the important regions of the dataset.", "rank": 1524, "start": 180788, "IsComparative": "0", "id": "st_1524"}, {"end": 181167, "text": "In addition, it can be used for vector field compressing, topological simplification, and even for building custom vector fields <170>.", "rank": 1525, "start": 181032, "IsComparative": "1", "id": "st_1525"}, {"end": 181263, "text": "Topology-based approaches for feature-based visualization is not the only methodology available.", "rank": 1526, "start": 181167, "IsComparative": "0", "id": "st_1526"}, {"end": 181364, "text": "In Lagrangian methods, the trajectories of particles are used to describe and segment the fluid flow.", "rank": 1527, "start": 181263, "IsComparative": "0", "id": "st_1527"}, {"end": 181462, "text": "In particular, FLTE <58> methods have gained prominence as a research area within the last decade.", "rank": 1528, "start": 181364, "IsComparative": "1", "id": "st_1528"}, {"end": 181594, "text": "One advantage of Lagrangian methods over traditional vector field topology is that they can naturally deal with unsteady flow <136>.", "rank": 1529, "start": 181462, "IsComparative": "0", "id": "st_1529"}, {"end": 181674, "text": "Space-time domain techniques are another example of feature-based visualization.", "rank": 1530, "start": 181594, "IsComparative": "1", "id": "st_1530"}, {"end": 181829, "text": "In this approach, in order to deal with the problems involved in unsteady flows, the problem of 2D and 3D flow visualization is moved to higher dimensions.", "rank": 1531, "start": 181674, "IsComparative": "0", "id": "st_1531"}, {"end": 181975, "text": "As an example, time-dependent domains are merged into a single dataset where traditional techniques used for steady vector fields can be employed.", "rank": 1532, "start": 181829, "IsComparative": "0", "id": "st_1532"}, {"end": 182073, "text": "A comprehensive survey on the topic can be found in the state-of-the-art report by Pobitzer et al.", "rank": 1533, "start": 181975, "IsComparative": "0", "id": "st_1533"}, {"end": 182079, "text": "<136>.", "rank": 1534, "start": 182073, "IsComparative": "1", "id": "st_1534"}]}, {"paragraph_info": {"end": 182114, "start": 182079, "text": "6.1.2.4 Texture-based visualization", "rank": 403, "paragraph_comparative_number": 0, "entities": [], "id": "p_403"}, "sentences": [{"end": 182114, "text": "6.1.2.4 Texture-based visualization", "rank": 1535, "start": 182079, "IsComparative": "0", "id": "st_1535"}]}, {"paragraph_info": {"end": 183108, "start": 182114, "text": "In texture-based flow visualization, the user replaces geometrical information with 2D texture mapped over surfaces.Line integral convolution (LIC) is a well-known (within the visualization community, at least) representative of the class.Texture-based techniques generate what is considered a dense visualization, i.e., it covers the entire domain of interest, and it does not have to deal with the problem of finding appropriate seeding spots for streamlines.Texture-based techniques can be applied along with geometric or feature-based visualization; for instance, it can be used to render flow on 2-manifolds embedded in 3D spaces, or providing an overview of the flow behavior along with topological skeletons.The main issue with texture-based visualizations is the high computational cost associated with it.Nevertheless, the advances in both computer hardware and algorithms have granted to users the ability to handle large data sets and unstructured grid at interactive rates <38, 87>.", "rank": 404, "paragraph_comparative_number": 5, "entities": [], "id": "p_404"}, "sentences": [{"end": 182230, "text": "In texture-based flow visualization, the user replaces geometrical information with 2D texture mapped over surfaces.", "rank": 1536, "start": 182114, "IsComparative": "1", "id": "st_1536"}, {"end": 182353, "text": "Line integral convolution (LIC) is a well-known (within the visualization community, at least) representative of the class.", "rank": 1537, "start": 182230, "IsComparative": "0", "id": "st_1537"}, {"end": 182575, "text": "Texture-based techniques generate what is considered a dense visualization, i.e., it covers the entire domain of interest, and it does not have to deal with the problem of finding appropriate seeding spots for streamlines.", "rank": 1538, "start": 182353, "IsComparative": "1", "id": "st_1538"}, {"end": 182829, "text": "Texture-based techniques can be applied along with geometric or feature-based visualization; for instance, it can be used to render flow on 2-manifolds embedded in 3D spaces, or providing an overview of the flow behavior along with topological skeletons.", "rank": 1539, "start": 182575, "IsComparative": "1", "id": "st_1539"}, {"end": 182928, "text": "The main issue with texture-based visualizations is the high computational cost associated with it.", "rank": 1540, "start": 182829, "IsComparative": "1", "id": "st_1540"}, {"end": 183108, "text": "Nevertheless, the advances in both computer hardware and algorithms have granted to users the ability to handle large data sets and unstructured grid at interactive rates <38, 87>.", "rank": 1541, "start": 182928, "IsComparative": "1", "id": "st_1541"}]}, {"paragraph_info": {"end": 183129, "start": 183108, "text": "6.1.3 Means to an End", "rank": 405, "paragraph_comparative_number": 1, "entities": [], "id": "p_405"}, "sentences": [{"end": 183129, "text": "6.1.3 Means to an End", "rank": 1542, "start": 183108, "IsComparative": "1", "id": "st_1542"}]}, {"paragraph_info": {"end": 183394, "start": 183129, "text": "In his position paper On the death of visualization <99>, Lorensen argues for the need to bring visualization researchers closer to experts and practitioners.We have run a simple experiment in order to attempt to ascertain the distance between the Visualization and", "rank": 406, "paragraph_comparative_number": 1, "entities": [], "id": "p_406"}, "sentences": [{"end": 183287, "text": "In his position paper On the death of visualization <99>, Lorensen argues for the need to bring visualization researchers closer to experts and practitioners.", "rank": 1543, "start": 183129, "IsComparative": "1", "id": "st_1543"}, {"end": 183394, "text": "We have run a simple experiment in order to attempt to ascertain the distance between the Visualization and", "rank": 1544, "start": 183287, "IsComparative": "0", "id": "st_1544"}]}, {"paragraph_info": {"end": 184685, "start": 183394, "text": "AIAA communities.We evaluated 78 articles published within the AIAA Journal over the period of Jan/2010-Oct/2012 containing at least one flow visualization image.Then, we simply counted the number of papers that contained at least one occurrences of the techniques shown in Table 6.1.We did not include the 2D color mapping and 2D isocontour visualizations as they appear quite often.Since multiple visualization techniques can be used in a single article, the percentages shown below are just the fraction of publications containing at least one particular type of visualization.Particle tracing using integration- based geometric visualization techniques for 2D vector fields is the most commonly used technique (42%), followed by 3D isocontouring (35%), 2D and 3D arrows and glyphs (33%), and 3D particle tracing (19%).Excluding isocontouring (which is mainly used for depicting scalar, instead of vector, data), 61% of the articles used at least one geometric approach to flow visualization, whereas 33% used a direct approach.Finally, 73% of the papers contained at least one visualization for 2D domains, whereas this number is 56% for 3D domains.The latter number drops to 22% if one considers only techniques for visualization of vector field data (i.e., excluding 3D isocontouring).", "rank": 407, "paragraph_comparative_number": 6, "entities": [], "id": "p_407"}, "sentences": [{"end": 183411, "text": "AIAA communities.", "rank": 1545, "start": 183394, "IsComparative": "0", "id": "st_1545"}, {"end": 183556, "text": "We evaluated 78 articles published within the AIAA Journal over the period of Jan/2010-Oct/2012 containing at least one flow visualization image.", "rank": 1546, "start": 183411, "IsComparative": "1", "id": "st_1546"}, {"end": 183678, "text": "Then, we simply counted the number of papers that contained at least one occurrences of the techniques shown in Table 6.1.", "rank": 1547, "start": 183556, "IsComparative": "1", "id": "st_1547"}, {"end": 183778, "text": "We did not include the 2D color mapping and 2D isocontour visualizations as they appear quite often.", "rank": 1548, "start": 183678, "IsComparative": "0", "id": "st_1548"}, {"end": 183974, "text": "Since multiple visualization techniques can be used in a single article, the percentages shown below are just the fraction of publications containing at least one particular type of visualization.", "rank": 1549, "start": 183778, "IsComparative": "1", "id": "st_1549"}, {"end": 184216, "text": "Particle tracing using integration- based geometric visualization techniques for 2D vector fields is the most commonly used technique (42%), followed by 3D isocontouring (35%), 2D and 3D arrows and glyphs (33%), and 3D particle tracing (19%).", "rank": 1550, "start": 183974, "IsComparative": "1", "id": "st_1550"}, {"end": 184425, "text": "Excluding isocontouring (which is mainly used for depicting scalar, instead of vector, data), 61% of the articles used at least one geometric approach to flow visualization, whereas 33% used a direct approach.", "rank": 1551, "start": 184216, "IsComparative": "0", "id": "st_1551"}, {"end": 184547, "text": "Finally, 73% of the papers contained at least one visualization for 2D domains, whereas this number is 56% for 3D domains.", "rank": 1552, "start": 184425, "IsComparative": "1", "id": "st_1552"}, {"end": 184685, "text": "The latter number drops to 22% if one considers only techniques for visualization of vector field data (i.e., excluding 3D isocontouring).", "rank": 1553, "start": 184547, "IsComparative": "1", "id": "st_1553"}]}, {"paragraph_info": {"end": 187560, "start": 184685, "text": "Although the data are limited to a short window of time, they raised a few interesting points.With the exception of a handful of papers, most of the flow visualization appears to be using the standard form of the traditional visualization technique.As an example, consider some the papers that use streamlines for visualizing 3D flow.It may be the case that a subset of these paper can benefit from using stream ribbons <177>, which simultaneously encode the streamlines path and local flow vorticity, or from stream tubes <177>, which simultaneously encode the streamlines path and local cross flow divergence.Both stream ribbons and stream tubes are well-known, and commonly used visualization packages such as Paraview or Tecplot have them available within their tool options.Secondly, the preference for the two visualization techniques (direct and curve-based geometric visualization) shown in past three years is perhaps due to their simplicity and availability.The underrepre- sented methods in the same period of time are texture-, feature-, and surface-based flow visualization.Third, one could argue that the visualized datasets were simple, and thus standard techniques worked well.Even though this may be the case for some datasets, some vector fields, especially in 3D, suffered from traditional problem of curves and arrows: cluttering, irregularly spaced streamlines, poor seeding, lack of depth cues, etc.These problems can make the detection of some flow features such as vortex more difficult.Direct visualization for 2D vector fields using glyphs can be improved by using, for instance, a resampling technique, such as shown in Laramee <89>, where the author introduce a user-driven approach for reducing visual clutter via resampling.Another way is to segment the flow using features of interest, e.g., critical points.Possible reasons for not using alternative techniques include that the technique might not be easily available, the technique might not improve the quality of the visualization, users are not aware of their existence or find them difficult to use, or the AIAA community requires a different class of techniques, among other.Both communities would benefit from knowing the reasons for using one technique over another.The visualization community has, throughout the years, defined a set of priorities based on an interaction with researchers from different fields and their own experience.Some recurrent themes that are the focus of research are: a more comprehensive theory and techniques for dealing with unsteady 3D flows; improved rendering (for instance, by using techniques inspired in handcrafted illustrations <13>); handling of large data sets; and others.Together, the AIAA and Visualization communities should be able to define a set of priorities for their research agendas in order to address the concerns and issues raised.", "rank": 408, "paragraph_comparative_number": 12, "entities": [], "id": "p_408"}, "sentences": [{"end": 184779, "text": "Although the data are limited to a short window of time, they raised a few interesting points.", "rank": 1554, "start": 184685, "IsComparative": "1", "id": "st_1554"}, {"end": 184934, "text": "With the exception of a handful of papers, most of the flow visualization appears to be using the standard form of the traditional visualization technique.", "rank": 1555, "start": 184779, "IsComparative": "1", "id": "st_1555"}, {"end": 185019, "text": "As an example, consider some the papers that use streamlines for visualizing 3D flow.", "rank": 1556, "start": 184934, "IsComparative": "0", "id": "st_1556"}, {"end": 185296, "text": "It may be the case that a subset of these paper can benefit from using stream ribbons <177>, which simultaneously encode the streamlines path and local flow vorticity, or from stream tubes <177>, which simultaneously encode the streamlines path and local cross flow divergence.", "rank": 1557, "start": 185019, "IsComparative": "1", "id": "st_1557"}, {"end": 185464, "text": "Both stream ribbons and stream tubes are well-known, and commonly used visualization packages such as Paraview or Tecplot have them available within their tool options.", "rank": 1558, "start": 185296, "IsComparative": "1", "id": "st_1558"}, {"end": 185653, "text": "Secondly, the preference for the two visualization techniques (direct and curve-based geometric visualization) shown in past three years is perhaps due to their simplicity and availability.", "rank": 1559, "start": 185464, "IsComparative": "1", "id": "st_1559"}, {"end": 185772, "text": "The underrepre- sented methods in the same period of time are texture-, feature-, and surface-based flow visualization.", "rank": 1560, "start": 185653, "IsComparative": "0", "id": "st_1560"}, {"end": 185878, "text": "Third, one could argue that the visualized datasets were simple, and thus standard techniques worked well.", "rank": 1561, "start": 185772, "IsComparative": "0", "id": "st_1561"}, {"end": 186106, "text": "Even though this may be the case for some datasets, some vector fields, especially in 3D, suffered from traditional problem of curves and arrows: cluttering, irregularly spaced streamlines, poor seeding, lack of depth cues, etc.", "rank": 1562, "start": 185878, "IsComparative": "1", "id": "st_1562"}, {"end": 186196, "text": "These problems can make the detection of some flow features such as vortex more difficult.", "rank": 1563, "start": 186106, "IsComparative": "0", "id": "st_1563"}, {"end": 186439, "text": "Direct visualization for 2D vector fields using glyphs can be improved by using, for instance, a resampling technique, such as shown in Laramee <89>, where the author introduce a user-driven approach for reducing visual clutter via resampling.", "rank": 1564, "start": 186196, "IsComparative": "1", "id": "st_1564"}, {"end": 186524, "text": "Another way is to segment the flow using features of interest, e.g., critical points.", "rank": 1565, "start": 186439, "IsComparative": "0", "id": "st_1565"}, {"end": 186848, "text": "Possible reasons for not using alternative techniques include that the technique might not be easily available, the technique might not improve the quality of the visualization, users are not aware of their existence or find them difficult to use, or the AIAA community requires a different class of techniques, among other.", "rank": 1566, "start": 186524, "IsComparative": "1", "id": "st_1566"}, {"end": 186941, "text": "Both communities would benefit from knowing the reasons for using one technique over another.", "rank": 1567, "start": 186848, "IsComparative": "1", "id": "st_1567"}, {"end": 187112, "text": "The visualization community has, throughout the years, defined a set of priorities based on an interaction with researchers from different fields and their own experience.", "rank": 1568, "start": 186941, "IsComparative": "1", "id": "st_1568"}, {"end": 187388, "text": "Some recurrent themes that are the focus of research are: a more comprehensive theory and techniques for dealing with unsteady 3D flows; improved rendering (for instance, by using techniques inspired in handcrafted illustrations <13>); handling of large data sets; and others.", "rank": 1569, "start": 187112, "IsComparative": "1", "id": "st_1569"}, {"end": 187560, "text": "Together, the AIAA and Visualization communities should be able to define a set of priorities for their research agendas in order to address the concerns and issues raised.", "rank": 1570, "start": 187388, "IsComparative": "1", "id": "st_1570"}]}, {"paragraph_info": {"end": 187589, "start": 187560, "text": "6.2 Perception and Evaluation", "rank": 409, "paragraph_comparative_number": 0, "entities": [], "id": "p_409"}, "sentences": [{"end": 187589, "text": "6.2 Perception and Evaluation", "rank": 1571, "start": 187560, "IsComparative": "0", "id": "st_1571"}]}, {"paragraph_info": {"end": 188943, "start": 187589, "text": "An important aspect of the visualization research consists of the building of new vi- sualization techniques and tools.Ideally, new techniques should be able improve the user cognitive process <174>, for instance, by allowing the visualization of data that have never been visualized before, or increasing ones ability to interact with, understand, and explore data.As visualization techniques are developed and improved, a question is raised: how can we compare and understand the differences between visualization techniques?The answer to this question leads us to a second important research topic: the need for rigorous evaluation of the strengths and weaknesses of visualization techniques.By strength and weakness we mean not only the evaluation of techniques according to traditional (computer science) metrics such as performance, memory footprint, ability to handle large datasets, etc., but also in terms of the errors introduced through visualization, property of these errors, user perception, among others.In particular, questions involving perception and cognition are related to the user.In this section, we review two topics of interest for flow visualization from the point of view of perception and evaluation: the use of color maps for visualization of scalar properties and the representation of steady 2D vector fields, respectively.", "rank": 410, "paragraph_comparative_number": 4, "entities": [], "id": "p_410"}, "sentences": [{"end": 187708, "text": "An important aspect of the visualization research consists of the building of new vi- sualization techniques and tools.", "rank": 1572, "start": 187589, "IsComparative": "1", "id": "st_1572"}, {"end": 187955, "text": "Ideally, new techniques should be able improve the user cognitive process <174>, for instance, by allowing the visualization of data that have never been visualized before, or increasing ones ability to interact with, understand, and explore data.", "rank": 1573, "start": 187708, "IsComparative": "1", "id": "st_1573"}, {"end": 188116, "text": "As visualization techniques are developed and improved, a question is raised: how can we compare and understand the differences between visualization techniques?", "rank": 1574, "start": 187955, "IsComparative": "0", "id": "st_1574"}, {"end": 188284, "text": "The answer to this question leads us to a second important research topic: the need for rigorous evaluation of the strengths and weaknesses of visualization techniques.", "rank": 1575, "start": 188116, "IsComparative": "1", "id": "st_1575"}, {"end": 188608, "text": "By strength and weakness we mean not only the evaluation of techniques according to traditional (computer science) metrics such as performance, memory footprint, ability to handle large datasets, etc., but also in terms of the errors introduced through visualization, property of these errors, user perception, among others.", "rank": 1576, "start": 188284, "IsComparative": "0", "id": "st_1576"}, {"end": 188692, "text": "In particular, questions involving perception and cognition are related to the user.", "rank": 1577, "start": 188608, "IsComparative": "0", "id": "st_1577"}, {"end": 188943, "text": "In this section, we review two topics of interest for flow visualization from the point of view of perception and evaluation: the use of color maps for visualization of scalar properties and the representation of steady 2D vector fields, respectively.", "rank": 1578, "start": 188692, "IsComparative": "1", "id": "st_1578"}]}, {"paragraph_info": {"end": 188974, "start": 188943, "text": "6.2.1 Perception and Color Maps", "rank": 411, "paragraph_comparative_number": 1, "entities": [], "id": "p_411"}, "sentences": [{"end": 188974, "text": "6.2.1 Perception and Color Maps", "rank": 1579, "start": 188943, "IsComparative": "1", "id": "st_1579"}]}, {"paragraph_info": {"end": 189617, "start": 188974, "text": "The mapping between data and colors is ubiquitous and essential across the sciences.In the scientific pipeline, color maps are often used to study, explain, explore, and ultimately help experts to gain insight about a phenomenon of interest.Alas, color maps are not all equal, and depending on the choices made, one can accelerate or impair scientific inquiry.Since they are just means-to-an-end, their impact on the underlying data should be as minimal as possible.In a myriad of choices, one color map has been shown to be a bad choice for virtually any type of visualization: the well-known and widely-used rainbow color map <10, 101, 160>.", "rank": 412, "paragraph_comparative_number": 3, "entities": [], "id": "p_412"}, "sentences": [{"end": 189058, "text": "The mapping between data and colors is ubiquitous and essential across the sciences.", "rank": 1580, "start": 188974, "IsComparative": "0", "id": "st_1580"}, {"end": 189215, "text": "In the scientific pipeline, color maps are often used to study, explain, explore, and ultimately help experts to gain insight about a phenomenon of interest.", "rank": 1581, "start": 189058, "IsComparative": "1", "id": "st_1581"}, {"end": 189334, "text": "Alas, color maps are not all equal, and depending on the choices made, one can accelerate or impair scientific inquiry.", "rank": 1582, "start": 189215, "IsComparative": "0", "id": "st_1582"}, {"end": 189440, "text": "Since they are just means-to-an-end, their impact on the underlying data should be as minimal as possible.", "rank": 1583, "start": 189334, "IsComparative": "1", "id": "st_1583"}, {"end": 189617, "text": "In a myriad of choices, one color map has been shown to be a bad choice for virtually any type of visualization: the well-known and widely-used rainbow color map <10, 101, 160>.", "rank": 1584, "start": 189440, "IsComparative": "1", "id": "st_1584"}]}, {"paragraph_info": {"end": 193396, "start": 189617, "text": "The rainbow color map is built by varying hue in order to cover the whole spectrum of visible light, from red to purple or vice versa.In practice, many visualization tools use colors varying from red to blue because red and purple are very similar.It is the default map in several visualization / simulation software packages, such as MatlabR .Here we review three issues known to hinder visualizations, namely, lack of ordering, iso-luminance, and introduction of artifacts.Figure 6.2 shows examples for each of these issues.The first issue is due to the lack of a natural sorting order.Even though the rainbow color map is ordered from shorter to longer wavelength of light, users do not easily perceive it as such, which makes quantitative analysis more difficult <10>.In addition, the rainbow color map can obscure data.The problem arises for data containing high spatial frequency.Isoluminant maps can obfuscate these frequencies because our visual system perceives them through changes in luminance.This is illustrated in the left images in Figure 6.2.Note how details on the top half and left portions of the rainbow color mapped image were removed by the choice of the color map.Lastly, the rainbow color map can also add artifacts to the visualization <175>.The problem is that the gradient in color map creates the illusion of patterns where none exist.This is illustrated in the right image in Figure 6.2.In association with the lack of a natural sorting order, it becomes difficult to identify that patterns are not due to the underlying data but due to the color map.Although Figure 6.2 shows simple synthetic examples, there have also been user studies and analysis showing that these problems are also present in the visualization of real-world scenarios <175>.Despite its disadvantages, the rainbow color map is widely used in the sciences.In the study by Borkin et al.<9>, participants reported that they liked it because they are used to seeing, that the saturated colors are easier to see, and it is the most aesthetically pleasing.Another possible reason for its widespread use is that it is default in many popular simulation and visualization tools.Paraview is one of the tools that no longer uses the rainbow color map as the default option since the publication of Rainbow Color Map (Still) Considered Harmful <118> by Borland et al.The author even suggest that a better name for it would be misleading color map.In light of the many pitfalls of the rainbow color map, the visualization community has, in the past few years, been moving away from it.In 2005, 52% of the scientific publication using a color map at the IEEE Visualization Conference had at least one occurrence of the rainbow color map <10>.This number has dropped to a single paper published at the IEEE Transactions on Visualization and Computer Graphics in 2011.Motivated by this experiment, we reviewed all publications from the AIAA Journal for the years of 2010, 2011, and 2012 that contained a color map and counted the number of papers that used the rainbow color map.Table 6.2 shows the obtained results.Note that we do not evaluate the potential problems caused by the rainbow color map.Nevertheless, we tried the methodology explained above for a flow simulation dataset.The left image in Figure 6.3 shows the results of a flow simulation.Note how some regions are over-emphasized (shown in red) while details are blurred (shown in green).The problems with the rainbow color map can be avoided by simply switching to another color map, such as the gray scale color map shown in the middle image in Figure 6.3.The image to the right shows the decolorized rainbow color map: although some details are easier to see, the result is still very different from the gray scale color map.", "rank": 413, "paragraph_comparative_number": 11, "entities": [], "id": "p_413"}, "sentences": [{"end": 189751, "text": "The rainbow color map is built by varying hue in order to cover the whole spectrum of visible light, from red to purple or vice versa.", "rank": 1585, "start": 189617, "IsComparative": "0", "id": "st_1585"}, {"end": 189865, "text": "In practice, many visualization tools use colors varying from red to blue because red and purple are very similar.", "rank": 1586, "start": 189751, "IsComparative": "1", "id": "st_1586"}, {"end": 189961, "text": "It is the default map in several visualization / simulation software packages, such as MatlabR .", "rank": 1587, "start": 189865, "IsComparative": "1", "id": "st_1587"}, {"end": 190092, "text": "Here we review three issues known to hinder visualizations, namely, lack of ordering, iso-luminance, and introduction of artifacts.", "rank": 1588, "start": 189961, "IsComparative": "1", "id": "st_1588"}, {"end": 190143, "text": "Figure 6.2 shows examples for each of these issues.", "rank": 1589, "start": 190092, "IsComparative": "1", "id": "st_1589"}, {"end": 190205, "text": "The first issue is due to the lack of a natural sorting order.", "rank": 1590, "start": 190143, "IsComparative": "0", "id": "st_1590"}, {"end": 190389, "text": "Even though the rainbow color map is ordered from shorter to longer wavelength of light, users do not easily perceive it as such, which makes quantitative analysis more difficult <10>.", "rank": 1591, "start": 190205, "IsComparative": "0", "id": "st_1591"}, {"end": 190441, "text": "In addition, the rainbow color map can obscure data.", "rank": 1592, "start": 190389, "IsComparative": "0", "id": "st_1592"}, {"end": 190503, "text": "The problem arises for data containing high spatial frequency.", "rank": 1593, "start": 190441, "IsComparative": "0", "id": "st_1593"}, {"end": 190622, "text": "Isoluminant maps can obfuscate these frequencies because our visual system perceives them through changes in luminance.", "rank": 1594, "start": 190503, "IsComparative": "1", "id": "st_1594"}, {"end": 190675, "text": "This is illustrated in the left images in Figure 6.2.", "rank": 1595, "start": 190622, "IsComparative": "0", "id": "st_1595"}, {"end": 190804, "text": "Note how details on the top half and left portions of the rainbow color mapped image were removed by the choice of the color map.", "rank": 1596, "start": 190675, "IsComparative": "0", "id": "st_1596"}, {"end": 190884, "text": "Lastly, the rainbow color map can also add artifacts to the visualization <175>.", "rank": 1597, "start": 190804, "IsComparative": "0", "id": "st_1597"}, {"end": 190980, "text": "The problem is that the gradient in color map creates the illusion of patterns where none exist.", "rank": 1598, "start": 190884, "IsComparative": "0", "id": "st_1598"}, {"end": 191033, "text": "This is illustrated in the right image in Figure 6.2.", "rank": 1599, "start": 190980, "IsComparative": "0", "id": "st_1599"}, {"end": 191197, "text": "In association with the lack of a natural sorting order, it becomes difficult to identify that patterns are not due to the underlying data but due to the color map.", "rank": 1600, "start": 191033, "IsComparative": "1", "id": "st_1600"}, {"end": 191393, "text": "Although Figure 6.2 shows simple synthetic examples, there have also been user studies and analysis showing that these problems are also present in the visualization of real-world scenarios <175>.", "rank": 1601, "start": 191197, "IsComparative": "0", "id": "st_1601"}, {"end": 191473, "text": "Despite its disadvantages, the rainbow color map is widely used in the sciences.", "rank": 1602, "start": 191393, "IsComparative": "0", "id": "st_1602"}, {"end": 191502, "text": "In the study by Borkin et al.", "rank": 1603, "start": 191473, "IsComparative": "1", "id": "st_1603"}, {"end": 191668, "text": "<9>, participants reported that they liked it because they are used to seeing, that the saturated colors are easier to see, and it is the most aesthetically pleasing.", "rank": 1604, "start": 191502, "IsComparative": "1", "id": "st_1604"}, {"end": 191788, "text": "Another possible reason for its widespread use is that it is default in many popular simulation and visualization tools.", "rank": 1605, "start": 191668, "IsComparative": "1", "id": "st_1605"}, {"end": 191974, "text": "Paraview is one of the tools that no longer uses the rainbow color map as the default option since the publication of Rainbow Color Map (Still) Considered Harmful <118> by Borland et al.", "rank": 1606, "start": 191788, "IsComparative": "1", "id": "st_1606"}, {"end": 192054, "text": "The author even suggest that a better name for it would be misleading color map.", "rank": 1607, "start": 191974, "IsComparative": "0", "id": "st_1607"}, {"end": 192191, "text": "In light of the many pitfalls of the rainbow color map, the visualization community has, in the past few years, been moving away from it.", "rank": 1608, "start": 192054, "IsComparative": "0", "id": "st_1608"}, {"end": 192347, "text": "In 2005, 52% of the scientific publication using a color map at the IEEE Visualization Conference had at least one occurrence of the rainbow color map <10>.", "rank": 1609, "start": 192191, "IsComparative": "0", "id": "st_1609"}, {"end": 192471, "text": "This number has dropped to a single paper published at the IEEE Transactions on Visualization and Computer Graphics in 2011.", "rank": 1610, "start": 192347, "IsComparative": "0", "id": "st_1610"}, {"end": 192682, "text": "Motivated by this experiment, we reviewed all publications from the AIAA Journal for the years of 2010, 2011, and 2012 that contained a color map and counted the number of papers that used the rainbow color map.", "rank": 1611, "start": 192471, "IsComparative": "1", "id": "st_1611"}, {"end": 192719, "text": "Table 6.2 shows the obtained results.", "rank": 1612, "start": 192682, "IsComparative": "0", "id": "st_1612"}, {"end": 192803, "text": "Note that we do not evaluate the potential problems caused by the rainbow color map.", "rank": 1613, "start": 192719, "IsComparative": "0", "id": "st_1613"}, {"end": 192888, "text": "Nevertheless, we tried the methodology explained above for a flow simulation dataset.", "rank": 1614, "start": 192803, "IsComparative": "0", "id": "st_1614"}, {"end": 192956, "text": "The left image in Figure 6.3 shows the results of a flow simulation.", "rank": 1615, "start": 192888, "IsComparative": "0", "id": "st_1615"}, {"end": 193056, "text": "Note how some regions are over-emphasized (shown in red) while details are blurred (shown in green).", "rank": 1616, "start": 192956, "IsComparative": "0", "id": "st_1616"}, {"end": 193226, "text": "The problems with the rainbow color map can be avoided by simply switching to another color map, such as the gray scale color map shown in the middle image in Figure 6.3.", "rank": 1617, "start": 193056, "IsComparative": "0", "id": "st_1617"}, {"end": 193396, "text": "The image to the right shows the decolorized rainbow color map: although some details are easier to see, the result is still very different from the gray scale color map.", "rank": 1618, "start": 193226, "IsComparative": "0", "id": "st_1618"}]}, {"paragraph_info": {"end": 193799, "start": 193396, "text": "The visualization community has also investigated what should constitute a good color map.Research on the topic of color selection can be found in the work by Treinish et al.<175>, Moreland <118>, Kindlmann et al.<75>, and others <101, 173>.The AIAA community can benefit from a set of standard color maps suitable for visualization of typical simulation data such as pressure fields, angle fields, etc.", "rank": 414, "paragraph_comparative_number": 2, "entities": [], "id": "p_414"}, "sentences": [{"end": 193486, "text": "The visualization community has also investigated what should constitute a good color map.", "rank": 1619, "start": 193396, "IsComparative": "0", "id": "st_1619"}, {"end": 193570, "text": "Research on the topic of color selection can be found in the work by Treinish et al.", "rank": 1620, "start": 193486, "IsComparative": "0", "id": "st_1620"}, {"end": 193609, "text": "<175>, Moreland <118>, Kindlmann et al.", "rank": 1621, "start": 193570, "IsComparative": "1", "id": "st_1621"}, {"end": 193637, "text": "<75>, and others <101, 173>.", "rank": 1622, "start": 193609, "IsComparative": "0", "id": "st_1622"}, {"end": 193799, "text": "The AIAA community can benefit from a set of standard color maps suitable for visualization of typical simulation data such as pressure fields, angle fields, etc.", "rank": 1623, "start": 193637, "IsComparative": "1", "id": "st_1623"}]}, {"paragraph_info": {"end": 193832, "start": 193799, "text": "6.2.2 Evaluation and User Studies", "rank": 415, "paragraph_comparative_number": 1, "entities": [], "id": "p_415"}, "sentences": [{"end": 193832, "text": "6.2.2 Evaluation and User Studies", "rank": 1624, "start": 193799, "IsComparative": "1", "id": "st_1624"}]}, {"paragraph_info": {"end": 194428, "start": 193832, "text": "In recent years, the Visualization community has seen a substantial increase in the number of papers dealing with evaluation of visualization techniques published within IEEE TVCG.Figure 6.4 shows the number of such papers published per year within the IEEE TVCG journal.The data were obtained by searching the TVCG website for the keywords evaluation, user study, design study, and case study in articles published in the period between 2002 and 2012.We then read the abstracts to make sure the papers were indeed relevant.From this corpora, 96% of the aforementioned articles were user studies.", "rank": 416, "paragraph_comparative_number": 3, "entities": [], "id": "p_416"}, "sentences": [{"end": 194012, "text": "In recent years, the Visualization community has seen a substantial increase in the number of papers dealing with evaluation of visualization techniques published within IEEE TVCG.", "rank": 1625, "start": 193832, "IsComparative": "1", "id": "st_1625"}, {"end": 194103, "text": "Figure 6.4 shows the number of such papers published per year within the IEEE TVCG journal.", "rank": 1626, "start": 194012, "IsComparative": "0", "id": "st_1626"}, {"end": 194284, "text": "The data were obtained by searching the TVCG website for the keywords evaluation, user study, design study, and case study in articles published in the period between 2002 and 2012.", "rank": 1627, "start": 194103, "IsComparative": "0", "id": "st_1627"}, {"end": 194356, "text": "We then read the abstracts to make sure the papers were indeed relevant.", "rank": 1628, "start": 194284, "IsComparative": "1", "id": "st_1628"}, {"end": 194428, "text": "From this corpora, 96% of the aforementioned articles were user studies.", "rank": 1629, "start": 194356, "IsComparative": "1", "id": "st_1629"}]}, {"paragraph_info": {"end": 196153, "start": 194428, "text": "As a representative example, we focus on a user study by Laidlaw et al.<86> comparing techniques for the visualization of steady 2D vector fields.The authors recruited five experts and 12 nonexperts users to evaluate the efficacy of each of the six techniques displayed in Figure 6.5.The evaluation was measured by the user performance during the execution of several tasks of three types: critical point detection; critical points classification; and simulation of particle advection.The first two tasks are standard whereas the third task is motivated by the fact that often experts were interested in the global flow direction.The three tasks were chosen based on the authors interaction with fluid mechanics researchers.The authors built a collection of 500 vector fields for evaluation of the tasks.Among the results, they cite no significant difference between experts and nonexperts regarding accuracy in the tasks or the response times.More interestingly, performance when using the standard method of arrows on a regular grid (GRID in Figure 6.5) falls below average for multiples tasks involving critical points location, classification, and advection (which means that users required more time to complete the task and committed more errors).On the other end of the spectrum, user performance when using GSTR consistently scored above average.Another similar study compare the user performance when using line and tube integral curves (with monoscopic and stereoscopic viewing) for 3D vector field data <48>.User study can be a powerful tool for helping users choose the best tool for their needs and the visualization community has been working on evaluating and testing techniques as they become more widespread.", "rank": 417, "paragraph_comparative_number": 8, "entities": [], "id": "p_417"}, "sentences": [{"end": 194499, "text": "As a representative example, we focus on a user study by Laidlaw et al.", "rank": 1630, "start": 194428, "IsComparative": "0", "id": "st_1630"}, {"end": 194574, "text": "<86> comparing techniques for the visualization of steady 2D vector fields.", "rank": 1631, "start": 194499, "IsComparative": "1", "id": "st_1631"}, {"end": 194712, "text": "The authors recruited five experts and 12 nonexperts users to evaluate the efficacy of each of the six techniques displayed in Figure 6.5.", "rank": 1632, "start": 194574, "IsComparative": "1", "id": "st_1632"}, {"end": 194913, "text": "The evaluation was measured by the user performance during the execution of several tasks of three types: critical point detection; critical points classification; and simulation of particle advection.", "rank": 1633, "start": 194712, "IsComparative": "1", "id": "st_1633"}, {"end": 195058, "text": "The first two tasks are standard whereas the third task is motivated by the fact that often experts were interested in the global flow direction.", "rank": 1634, "start": 194913, "IsComparative": "0", "id": "st_1634"}, {"end": 195152, "text": "The three tasks were chosen based on the authors interaction with fluid mechanics researchers.", "rank": 1635, "start": 195058, "IsComparative": "1", "id": "st_1635"}, {"end": 195232, "text": "The authors built a collection of 500 vector fields for evaluation of the tasks.", "rank": 1636, "start": 195152, "IsComparative": "1", "id": "st_1636"}, {"end": 195372, "text": "Among the results, they cite no significant difference between experts and nonexperts regarding accuracy in the tasks or the response times.", "rank": 1637, "start": 195232, "IsComparative": "1", "id": "st_1637"}, {"end": 195681, "text": "More interestingly, performance when using the standard method of arrows on a regular grid (GRID in Figure 6.5) falls below average for multiples tasks involving critical points location, classification, and advection (which means that users required more time to complete the task and committed more errors).", "rank": 1638, "start": 195372, "IsComparative": "1", "id": "st_1638"}, {"end": 195782, "text": "On the other end of the spectrum, user performance when using GSTR consistently scored above average.", "rank": 1639, "start": 195681, "IsComparative": "0", "id": "st_1639"}, {"end": 195947, "text": "Another similar study compare the user performance when using line and tube integral curves (with monoscopic and stereoscopic viewing) for 3D vector field data <48>.", "rank": 1640, "start": 195782, "IsComparative": "1", "id": "st_1640"}, {"end": 196153, "text": "User study can be a powerful tool for helping users choose the best tool for their needs and the visualization community has been working on evaluating and testing techniques as they become more widespread.", "rank": 1641, "start": 195947, "IsComparative": "0", "id": "st_1641"}]}, {"paragraph_info": {"end": 196185, "start": 196153, "text": "6.3 Uncertainty and Verification", "rank": 418, "paragraph_comparative_number": 0, "entities": [], "id": "p_418"}, "sentences": [{"end": 196185, "text": "6.3 Uncertainty and Verification", "rank": 1642, "start": 196153, "IsComparative": "0", "id": "st_1642"}]}, {"paragraph_info": {"end": 196950, "start": 196185, "text": "Uncertainty visualization and visualization verification are two important topics in the pursuit for reliable visualizations.The AIAA community is familiar with both topics.In this chapter, however, we present some of the recent advancements in this area from the point of view of the Visualization community.The goal is to increase the user confidence in the results of the visualization by answering questions such as: how can one visualize the inherent error sources in the visualization?or, how can one increase her/his confidence that an implementation of a visualization algorithm does what was intended?In the following sections we present some of the recent developments in uncertainty visualization and the verification of isosurface extraction techniques.", "rank": 419, "paragraph_comparative_number": 2, "entities": [], "id": "p_419"}, "sentences": [{"end": 196310, "text": "Uncertainty visualization and visualization verification are two important topics in the pursuit for reliable visualizations.", "rank": 1643, "start": 196185, "IsComparative": "1", "id": "st_1643"}, {"end": 196358, "text": "The AIAA community is familiar with both topics.", "rank": 1644, "start": 196310, "IsComparative": "0", "id": "st_1644"}, {"end": 196494, "text": "In this chapter, however, we present some of the recent advancements in this area from the point of view of the Visualization community.", "rank": 1645, "start": 196358, "IsComparative": "0", "id": "st_1645"}, {"end": 196676, "text": "The goal is to increase the user confidence in the results of the visualization by answering questions such as: how can one visualize the inherent error sources in the visualization?", "rank": 1646, "start": 196494, "IsComparative": "1", "id": "st_1646"}, {"end": 196795, "text": "or, how can one increase her/his confidence that an implementation of a visualization algorithm does what was intended?", "rank": 1647, "start": 196676, "IsComparative": "0", "id": "st_1647"}, {"end": 196950, "text": "In the following sections we present some of the recent developments in uncertainty visualization and the verification of isosurface extraction techniques.", "rank": 1648, "start": 196795, "IsComparative": "0", "id": "st_1648"}]}, {"paragraph_info": {"end": 196981, "start": 196950, "text": "6.3.1 Uncertainty Visualization", "rank": 420, "paragraph_comparative_number": 0, "entities": [], "id": "p_420"}, "sentences": [{"end": 196981, "text": "6.3.1 Uncertainty Visualization", "rank": 1649, "start": 196950, "IsComparative": "0", "id": "st_1649"}]}, {"paragraph_info": {"end": 197797, "start": 196981, "text": "In the course of scientific inquiry, uncertainty is the norm.The visualization community has recently turned its attention to uncertain data, and is trying to solve problems on how to best compute and convey uncertainty information.Since 2010, around 30 papers were published at TVCG on the topic, with application on information visualization and scientific visualization.So far, the community has seen several different representation for uncertainty, varying from traditional method such as bars, glyphs, and colors, to texture, multilayering, animations, and volume rendering.At the AIAA community, we analyzed ten papers since 2010 dealing with material uncertainty, uncertainty in flows, and fluid simulation.The visualization step, on the other hand, is restricted almost exclusively to error bars and charts.", "rank": 421, "paragraph_comparative_number": 3, "entities": [], "id": "p_421"}, "sentences": [{"end": 197042, "text": "In the course of scientific inquiry, uncertainty is the norm.", "rank": 1650, "start": 196981, "IsComparative": "1", "id": "st_1650"}, {"end": 197213, "text": "The visualization community has recently turned its attention to uncertain data, and is trying to solve problems on how to best compute and convey uncertainty information.", "rank": 1651, "start": 197042, "IsComparative": "1", "id": "st_1651"}, {"end": 197354, "text": "Since 2010, around 30 papers were published at TVCG on the topic, with application on information visualization and scientific visualization.", "rank": 1652, "start": 197213, "IsComparative": "1", "id": "st_1652"}, {"end": 197561, "text": "So far, the community has seen several different representation for uncertainty, varying from traditional method such as bars, glyphs, and colors, to texture, multilayering, animations, and volume rendering.", "rank": 1653, "start": 197354, "IsComparative": "0", "id": "st_1653"}, {"end": 197696, "text": "At the AIAA community, we analyzed ten papers since 2010 dealing with material uncertainty, uncertainty in flows, and fluid simulation.", "rank": 1654, "start": 197561, "IsComparative": "0", "id": "st_1654"}, {"end": 197797, "text": "The visualization step, on the other hand, is restricted almost exclusively to error bars and charts.", "rank": 1655, "start": 197696, "IsComparative": "0", "id": "st_1655"}]}, {"paragraph_info": {"end": 198635, "start": 197797, "text": "In the user study conducted by Sanyal et al.<148>, the authors evaluate the effectiveness of four commonly used uncertainty visualization techniques: namely, glyphs size, glyphs color mapping, surface color mapping, and error bars (see Figure 6.6 for examples).The users performed two search tasks by identifying regions that are least and most uncertain, and two counting tasks where users counted the number of data and uncertainty features.The authors reported that, in general, users required more time and committed more mistakes when using error bars.The authors conjecture that a possible reasons for the poor performance displayed by error bars is due to the high density of the dataset used in their study.Nevertheless, a similar pattern can be found in the AIAA community (e.g., see Figures 4 and 6 in Chassaing and Lucor <19>).", "rank": 422, "paragraph_comparative_number": 3, "entities": [], "id": "p_422"}, "sentences": [{"end": 197841, "text": "In the user study conducted by Sanyal et al.", "rank": 1656, "start": 197797, "IsComparative": "0", "id": "st_1656"}, {"end": 198058, "text": "<148>, the authors evaluate the effectiveness of four commonly used uncertainty visualization techniques: namely, glyphs size, glyphs color mapping, surface color mapping, and error bars (see Figure 6.6 for examples).", "rank": 1657, "start": 197841, "IsComparative": "0", "id": "st_1657"}, {"end": 198240, "text": "The users performed two search tasks by identifying regions that are least and most uncertain, and two counting tasks where users counted the number of data and uncertainty features.", "rank": 1658, "start": 198058, "IsComparative": "1", "id": "st_1658"}, {"end": 198354, "text": "The authors reported that, in general, users required more time and committed more mistakes when using error bars.", "rank": 1659, "start": 198240, "IsComparative": "1", "id": "st_1659"}, {"end": 198512, "text": "The authors conjecture that a possible reasons for the poor performance displayed by error bars is due to the high density of the dataset used in their study.", "rank": 1660, "start": 198354, "IsComparative": "1", "id": "st_1660"}, {"end": 198635, "text": "Nevertheless, a similar pattern can be found in the AIAA community (e.g., see Figures 4 and 6 in Chassaing and Lucor <19>).", "rank": 1661, "start": 198512, "IsComparative": "0", "id": "st_1661"}]}, {"paragraph_info": {"end": 199490, "start": 198635, "text": "Several techniques for uncertainty visualization of vector fields are available.Botchen et al.<11> introduce a texture-mapping approach for uncertainty visualization of 2D vector fields.Hlawatsch et al.<63> introduce a new static visualization of unsteady vector fields with uncertainty based on a new type of glyph.Osorio and Brodlie <1> introduce a LIC- based method for uncertainty visualization.The work by Petz et al.<135> uses Gaussian random fields and takes into account spatial correlation of the data, which affects vector field features.Fout and Ma <123> presents a framework based on possibility theory for uncertainty visualization and as a case study, the authors use streamlines in 3D steady vector fields.Because many researchers have recently turned their attention to uncertainty visualization, this area of research is rapidly evolving.", "rank": 423, "paragraph_comparative_number": 4, "entities": [], "id": "p_423"}, "sentences": [{"end": 198715, "text": "Several techniques for uncertainty visualization of vector fields are available.", "rank": 1662, "start": 198635, "IsComparative": "0", "id": "st_1662"}, {"end": 198729, "text": "Botchen et al.", "rank": 1663, "start": 198715, "IsComparative": "0", "id": "st_1663"}, {"end": 198821, "text": "<11> introduce a texture-mapping approach for uncertainty visualization of 2D vector fields.", "rank": 1664, "start": 198729, "IsComparative": "1", "id": "st_1664"}, {"end": 198837, "text": "Hlawatsch et al.", "rank": 1665, "start": 198821, "IsComparative": "0", "id": "st_1665"}, {"end": 198951, "text": "<63> introduce a new static visualization of unsteady vector fields with uncertainty based on a new type of glyph.", "rank": 1666, "start": 198837, "IsComparative": "0", "id": "st_1666"}, {"end": 199034, "text": "Osorio and Brodlie <1> introduce a LIC- based method for uncertainty visualization.", "rank": 1667, "start": 198951, "IsComparative": "0", "id": "st_1667"}, {"end": 199057, "text": "The work by Petz et al.", "rank": 1668, "start": 199034, "IsComparative": "0", "id": "st_1668"}, {"end": 199183, "text": "<135> uses Gaussian random fields and takes into account spatial correlation of the data, which affects vector field features.", "rank": 1669, "start": 199057, "IsComparative": "1", "id": "st_1669"}, {"end": 199356, "text": "Fout and Ma <123> presents a framework based on possibility theory for uncertainty visualization and as a case study, the authors use streamlines in 3D steady vector fields.", "rank": 1670, "start": 199183, "IsComparative": "1", "id": "st_1670"}, {"end": 199490, "text": "Because many researchers have recently turned their attention to uncertainty visualization, this area of research is rapidly evolving.", "rank": 1671, "start": 199356, "IsComparative": "1", "id": "st_1671"}]}, {"paragraph_info": {"end": 199520, "start": 199490, "text": "6.3.2 Verifiable Visualization", "rank": 424, "paragraph_comparative_number": 0, "entities": [], "id": "p_424"}, "sentences": [{"end": 199520, "text": "6.3.2 Verifiable Visualization", "rank": 1672, "start": 199490, "IsComparative": "0", "id": "st_1672"}]}, {"paragraph_info": {"end": 199651, "start": 199520, "text": "As Chapter 2 and 3 have shown, there has been work on the verification of the imple- mentation of isosurface extraction algorithms.", "rank": 425, "paragraph_comparative_number": 0, "entities": [], "id": "p_425"}, "sentences": [{"end": 199651, "text": "As Chapter 2 and 3 have shown, there has been work on the verification of the imple- mentation of isosurface extraction algorithms.", "rank": 1673, "start": 199520, "IsComparative": "0", "id": "st_1673"}]}, {"paragraph_info": {"end": 199668, "start": 199651, "text": "6.4 Opportunities", "rank": 426, "paragraph_comparative_number": 0, "entities": [], "id": "p_426"}, "sentences": [{"end": 199668, "text": "6.4 Opportunities", "rank": 1674, "start": 199651, "IsComparative": "0", "id": "st_1674"}]}, {"paragraph_info": {"end": 201212, "start": 199668, "text": "Much of the early motivation for flow visualization in the visualization community came from the AIAA community, but over the last two decades, it appears that a major gap has developed, and developments in the visualization community have been done much more independently of applications and new developments in the aeronautics area.This is in part due to the different needs of the many users of visualization techniques, including the automotive industry, meteorology, medical imaging, geosciences, to cite a few.Summarizing decades of developments in the field of flow visualization and related areas is a nontrivial process.As an alternative, every year, a summary of recent relevant advances of visualization techniques could be published at the AIAA community; and conversely, the AIAA community could help the visualization community not only by providing expertise, but also research directions <121>.Yearly panels are held at the IEEE Vis conference, many of them with an applications focus.Consistent participation by the AIAA in these communities would help raise the level of awareness of current pressing issues.This gap between communities seems to be particular true in the need for validation and verification of visualizations techniques and codes, which over time seem to have lost track with the new rigor expected of computational codes.A related topic is the need for increasing the level of reproducibility of computational results, which cannot be simply accomplish by making codes available to other researchers <158>.", "rank": 427, "paragraph_comparative_number": 4, "entities": [], "id": "p_427"}, "sentences": [{"end": 200003, "text": "Much of the early motivation for flow visualization in the visualization community came from the AIAA community, but over the last two decades, it appears that a major gap has developed, and developments in the visualization community have been done much more independently of applications and new developments in the aeronautics area.", "rank": 1675, "start": 199668, "IsComparative": "1", "id": "st_1675"}, {"end": 200185, "text": "This is in part due to the different needs of the many users of visualization techniques, including the automotive industry, meteorology, medical imaging, geosciences, to cite a few.", "rank": 1676, "start": 200003, "IsComparative": "0", "id": "st_1676"}, {"end": 200298, "text": "Summarizing decades of developments in the field of flow visualization and related areas is a nontrivial process.", "rank": 1677, "start": 200185, "IsComparative": "0", "id": "st_1677"}, {"end": 200579, "text": "As an alternative, every year, a summary of recent relevant advances of visualization techniques could be published at the AIAA community; and conversely, the AIAA community could help the visualization community not only by providing expertise, but also research directions <121>.", "rank": 1678, "start": 200298, "IsComparative": "0", "id": "st_1678"}, {"end": 200670, "text": "Yearly panels are held at the IEEE Vis conference, many of them with an applications focus.", "rank": 1679, "start": 200579, "IsComparative": "0", "id": "st_1679"}, {"end": 200795, "text": "Consistent participation by the AIAA in these communities would help raise the level of awareness of current pressing issues.", "rank": 1680, "start": 200670, "IsComparative": "1", "id": "st_1680"}, {"end": 201027, "text": "This gap between communities seems to be particular true in the need for validation and verification of visualizations techniques and codes, which over time seem to have lost track with the new rigor expected of computational codes.", "rank": 1681, "start": 200795, "IsComparative": "1", "id": "st_1681"}, {"end": 201212, "text": "A related topic is the need for increasing the level of reproducibility of computational results, which cannot be simply accomplish by making codes available to other researchers <158>.", "rank": 1682, "start": 201027, "IsComparative": "1", "id": "st_1682"}]}, {"paragraph_info": {"end": 202613, "start": 201212, "text": "There is a natural progression from research idea within the visualization community to prototype tool, and from prototype tool to hardened user-available software.The challenge put forward to the visualization community to continue to seek out how to be relevant to collaborators such as our colleagues in the AIAA community, and the challenge of disseminating the advances made by the visualization community to application domains.Over the last 20 years, visualization techniques have merged as a key enabling technology for computation science by helping people explore and explain data through the creation of both static and interactive visual representations.Visualizations libraries such as Kitwares VTK contain a very large number of highly-complex visualization algorithms with thousand of lines of code implementing them.The most powerful of these algorithms are often based on complex mathematical concepts, e.g., Morse-Smale complex, spectral analysis, and partial differential equations (PDEs).Robust implementations of these techniques require the use of nontrivial techniques.The overall complexity and size of these datasets leave no room for inefficient code, thus making their implementation even more complex.The complexity of the codes coupled with the new visualization techniques make it highly nontrivial for nonexperts to use them, although, in principle, it should be easier.", "rank": 428, "paragraph_comparative_number": 4, "entities": [], "id": "p_428"}, "sentences": [{"end": 201376, "text": "There is a natural progression from research idea within the visualization community to prototype tool, and from prototype tool to hardened user-available software.", "rank": 1683, "start": 201212, "IsComparative": "0", "id": "st_1683"}, {"end": 201646, "text": "The challenge put forward to the visualization community to continue to seek out how to be relevant to collaborators such as our colleagues in the AIAA community, and the challenge of disseminating the advances made by the visualization community to application domains.", "rank": 1684, "start": 201376, "IsComparative": "1", "id": "st_1684"}, {"end": 201878, "text": "Over the last 20 years, visualization techniques have merged as a key enabling technology for computation science by helping people explore and explain data through the creation of both static and interactive visual representations.", "rank": 1685, "start": 201646, "IsComparative": "1", "id": "st_1685"}, {"end": 202044, "text": "Visualizations libraries such as Kitwares VTK contain a very large number of highly-complex visualization algorithms with thousand of lines of code implementing them.", "rank": 1686, "start": 201878, "IsComparative": "0", "id": "st_1686"}, {"end": 202220, "text": "The most powerful of these algorithms are often based on complex mathematical concepts, e.g., Morse-Smale complex, spectral analysis, and partial differential equations (PDEs).", "rank": 1687, "start": 202044, "IsComparative": "0", "id": "st_1687"}, {"end": 202304, "text": "Robust implementations of these techniques require the use of nontrivial techniques.", "rank": 1688, "start": 202220, "IsComparative": "0", "id": "st_1688"}, {"end": 202441, "text": "The overall complexity and size of these datasets leave no room for inefficient code, thus making their implementation even more complex.", "rank": 1689, "start": 202304, "IsComparative": "1", "id": "st_1689"}, {"end": 202613, "text": "The complexity of the codes coupled with the new visualization techniques make it highly nontrivial for nonexperts to use them, although, in principle, it should be easier.", "rank": 1690, "start": 202441, "IsComparative": "1", "id": "st_1690"}]}, {"paragraph_info": {"end": 203102, "start": 202613, "text": "We believe better connections between the two communities have the chance to improve the adoption of new techniques.Furthermore, by working together, AIAA researchers can also help the Visualization community not only by providing new problems and datasets and being a major driver of problems to the community (such as they were when the visualization field was coming of age), but also by making sure the needs of the AIAA community are reflected in new research topics in Visualization.", "rank": 429, "paragraph_comparative_number": 2, "entities": [], "id": "p_429"}, "sentences": [{"end": 202729, "text": "We believe better connections between the two communities have the chance to improve the adoption of new techniques.", "rank": 1691, "start": 202613, "IsComparative": "1", "id": "st_1691"}, {"end": 203102, "text": "Furthermore, by working together, AIAA researchers can also help the Visualization community not only by providing new problems and datasets and being a major driver of problems to the community (such as they were when the visualization field was coming of age), but also by making sure the needs of the AIAA community are reflected in new research topics in Visualization.", "rank": 1692, "start": 202729, "IsComparative": "1", "id": "st_1692"}]}, {"paragraph_info": {"end": 203116, "start": 203102, "text": "6.5 Conclusion", "rank": 430, "paragraph_comparative_number": 0, "entities": [], "id": "p_430"}, "sentences": [{"end": 203116, "text": "6.5 Conclusion", "rank": 1693, "start": 203102, "IsComparative": "0", "id": "st_1693"}]}, {"paragraph_info": {"end": 204734, "start": 203116, "text": "In this chapter, we have briefly visited two decades worth of flow visualization.In particular, we first focused on vector field visualization.In this regard, we presented a classification of flow visualization seen from the perspective of the Visualization community and contrasted it with AIAA publications containing flow visualization over the last 3 years.By exposing the current advances in visualization, we have a starting point for building a common research agenda that can benefit both communities.In addition, we have also visited some topics related to flow visualization that have been attracting attention in the Visualization community, namely, evaluation of visualization techniques, perception, uncertainty visualization, and verifiable visualization.The common thread in all these topics is the need for improving visualization techniques in general via error mitigation, and understanding how visualization can improve the user cognitive process.We showed some of the recent work on each of these topics in the context of flow visualization.As we mentioned at the start, (computational) flow visualization is a research area that was birthed simultaneously in two communities, and early in its development benefited from strong interaction between the communities.It is our hope that a more tight coupling between the research needs/interests of the AIAA community and the research agendas of the Visualization community can be developed.This can only happen through cooperation, collaboration, and communication.In part, we hope that this work is the start of a dialog between the two communities.", "rank": 431, "paragraph_comparative_number": 8, "entities": [], "id": "p_431"}, "sentences": [{"end": 203197, "text": "In this chapter, we have briefly visited two decades worth of flow visualization.", "rank": 1694, "start": 203116, "IsComparative": "1", "id": "st_1694"}, {"end": 203259, "text": "In particular, we first focused on vector field visualization.", "rank": 1695, "start": 203197, "IsComparative": "0", "id": "st_1695"}, {"end": 203477, "text": "In this regard, we presented a classification of flow visualization seen from the perspective of the Visualization community and contrasted it with AIAA publications containing flow visualization over the last 3 years.", "rank": 1696, "start": 203259, "IsComparative": "1", "id": "st_1696"}, {"end": 203625, "text": "By exposing the current advances in visualization, we have a starting point for building a common research agenda that can benefit both communities.", "rank": 1697, "start": 203477, "IsComparative": "0", "id": "st_1697"}, {"end": 203885, "text": "In addition, we have also visited some topics related to flow visualization that have been attracting attention in the Visualization community, namely, evaluation of visualization techniques, perception, uncertainty visualization, and verifiable visualization.", "rank": 1698, "start": 203625, "IsComparative": "1", "id": "st_1698"}, {"end": 204082, "text": "The common thread in all these topics is the need for improving visualization techniques in general via error mitigation, and understanding how visualization can improve the user cognitive process.", "rank": 1699, "start": 203885, "IsComparative": "1", "id": "st_1699"}, {"end": 204177, "text": "We showed some of the recent work on each of these topics in the context of flow visualization.", "rank": 1700, "start": 204082, "IsComparative": "1", "id": "st_1700"}, {"end": 204400, "text": "As we mentioned at the start, (computational) flow visualization is a research area that was birthed simultaneously in two communities, and early in its development benefited from strong interaction between the communities.", "rank": 1701, "start": 204177, "IsComparative": "1", "id": "st_1701"}, {"end": 204574, "text": "It is our hope that a more tight coupling between the research needs/interests of the AIAA community and the research agendas of the Visualization community can be developed.", "rank": 1702, "start": 204400, "IsComparative": "1", "id": "st_1702"}, {"end": 204649, "text": "This can only happen through cooperation, collaboration, and communication.", "rank": 1703, "start": 204574, "IsComparative": "0", "id": "st_1703"}, {"end": 204734, "text": "In part, we hope that this work is the start of a dialog between the two communities.", "rank": 1704, "start": 204649, "IsComparative": "1", "id": "st_1704"}]}, {"paragraph_info": {"end": 204754, "start": 204734, "text": "CHAPTER 7 CONCLUSION", "rank": 432, "paragraph_comparative_number": 0, "entities": [], "id": "p_432"}, "sentences": [{"end": 204754, "text": "CHAPTER 7 CONCLUSION", "rank": 1705, "start": 204734, "IsComparative": "0", "id": "st_1705"}]}, {"paragraph_info": {"end": 205119, "start": 204754, "text": "In this dissertation, we have introduced a framework for the verification of two of the most popular visualization techniques available in scientific visualization, namely, isosurface extraction and volume rendering.The framework is based on the Method of Manufactured Solutions (MMS), a well-established idea inside the Computation Science & Engineering community.", "rank": 433, "paragraph_comparative_number": 2, "entities": [], "id": "p_433"}, "sentences": [{"end": 204970, "text": "In this dissertation, we have introduced a framework for the verification of two of the most popular visualization techniques available in scientific visualization, namely, isosurface extraction and volume rendering.", "rank": 1706, "start": 204754, "IsComparative": "1", "id": "st_1706"}, {"end": 205119, "text": "The framework is based on the Method of Manufactured Solutions (MMS), a well-established idea inside the Computation Science & Engineering community.", "rank": 1707, "start": 204970, "IsComparative": "1", "id": "st_1707"}]}, {"paragraph_info": {"end": 205159, "start": 205119, "text": "7.1 The Method of Manufactured Solutions", "rank": 434, "paragraph_comparative_number": 1, "entities": [], "id": "p_434"}, "sentences": [{"end": 205159, "text": "7.1 The Method of Manufactured Solutions", "rank": 1708, "start": 205119, "IsComparative": "1", "id": "st_1708"}]}, {"paragraph_info": {"end": 206711, "start": 205159, "text": "As previously mentioned, the two main steps involved in the practice of the MMS are the theoretical analysis of important mathematical properties and the black-box testing.The analysis was the most time-consuming part because required intense research.The convergence of geometrical properties of isosurfaces, such as function value and normals, were mostly available in the literature.Hence, the research was fairly straightforward in this case.On the other hand, the verification of topological properties were available only by using relatively complex algorithms, such as contour trees.The complexity was one of our motivations to devise new algorithms for computing the Euler characteristics of isosurfaces directly from scalar fields.In addition to that, our work on topological verification played a crucial role in correcting an almost 20-year-old bug with Marching Cubes 33.The case of verification of volume rendering algorithms also required a convergence analysis not available in the literature.Thus, the analysis of the theoretical behavior of visualization algorithms presented in this work constitute an important contribution of this dissertation.Another important consideration is that often simplifications must be made so that an algorithm can be verified, such as illustrated by the volume rendering case.Many of the commonly used improvements to the standard volume rendering, such as opacity correction or advanced shading, must be turned off because the theoretical analysis does not include the influence of these improvements.", "rank": 435, "paragraph_comparative_number": 3, "entities": [], "id": "p_435"}, "sentences": [{"end": 205331, "text": "As previously mentioned, the two main steps involved in the practice of the MMS are the theoretical analysis of important mathematical properties and the black-box testing.", "rank": 1709, "start": 205159, "IsComparative": "0", "id": "st_1709"}, {"end": 205411, "text": "The analysis was the most time-consuming part because required intense research.", "rank": 1710, "start": 205331, "IsComparative": "0", "id": "st_1710"}, {"end": 205545, "text": "The convergence of geometrical properties of isosurfaces, such as function value and normals, were mostly available in the literature.", "rank": 1711, "start": 205411, "IsComparative": "0", "id": "st_1711"}, {"end": 205605, "text": "Hence, the research was fairly straightforward in this case.", "rank": 1712, "start": 205545, "IsComparative": "0", "id": "st_1712"}, {"end": 205749, "text": "On the other hand, the verification of topological properties were available only by using relatively complex algorithms, such as contour trees.", "rank": 1713, "start": 205605, "IsComparative": "1", "id": "st_1713"}, {"end": 205899, "text": "The complexity was one of our motivations to devise new algorithms for computing the Euler characteristics of isosurfaces directly from scalar fields.", "rank": 1714, "start": 205749, "IsComparative": "1", "id": "st_1714"}, {"end": 206042, "text": "In addition to that, our work on topological verification played a crucial role in correcting an almost 20-year-old bug with Marching Cubes 33.", "rank": 1715, "start": 205899, "IsComparative": "1", "id": "st_1715"}, {"end": 206167, "text": "The case of verification of volume rendering algorithms also required a convergence analysis not available in the literature.", "rank": 1716, "start": 206042, "IsComparative": "0", "id": "st_1716"}, {"end": 206323, "text": "Thus, the analysis of the theoretical behavior of visualization algorithms presented in this work constitute an important contribution of this dissertation.", "rank": 1717, "start": 206167, "IsComparative": "0", "id": "st_1717"}, {"end": 206485, "text": "Another important consideration is that often simplifications must be made so that an algorithm can be verified, such as illustrated by the volume rendering case.", "rank": 1718, "start": 206323, "IsComparative": "0", "id": "st_1718"}, {"end": 206711, "text": "Many of the commonly used improvements to the standard volume rendering, such as opacity correction or advanced shading, must be turned off because the theoretical analysis does not include the influence of these improvements.", "rank": 1719, "start": 206485, "IsComparative": "0", "id": "st_1719"}]}, {"paragraph_info": {"end": 206953, "start": 206711, "text": "Because of its simplicity, we believe MMS could become a standard tool for the verification of scientific visualization software in the same way that it has been adopted by the CS&E community as a trustworthy tool for assess code correctness.", "rank": 436, "paragraph_comparative_number": 1, "entities": [], "id": "p_436"}, "sentences": [{"end": 206953, "text": "Because of its simplicity, we believe MMS could become a standard tool for the verification of scientific visualization software in the same way that it has been adopted by the CS&E community as a trustworthy tool for assess code correctness.", "rank": 1720, "start": 206711, "IsComparative": "1", "id": "st_1720"}]}, {"paragraph_info": {"end": 207689, "start": 206953, "text": "We observed that the MMS contrasts with a common practice within the visualization community, namely, the evaluation of new techniques through the use of real-world data.By using real-world data during development, one can evaluate a new technique using the data it is supposed to represent.When the data do not look right in the eyes of an expert, or the error quantification exceeds some predetermined threshold, it is assumed that there is a problem that must be fixed.This approach is certainly valuable and we do not advocate the MMS as a replacement for using real-world data, or any other method that users are accustomed with for that matter.Instead, we advocate its use in addition to the methods already adopted by developers.", "rank": 437, "paragraph_comparative_number": 1, "entities": [], "id": "p_437"}, "sentences": [{"end": 207123, "text": "We observed that the MMS contrasts with a common practice within the visualization community, namely, the evaluation of new techniques through the use of real-world data.", "rank": 1721, "start": 206953, "IsComparative": "1", "id": "st_1721"}, {"end": 207244, "text": "By using real-world data during development, one can evaluate a new technique using the data it is supposed to represent.", "rank": 1722, "start": 207123, "IsComparative": "0", "id": "st_1722"}, {"end": 207425, "text": "When the data do not look right in the eyes of an expert, or the error quantification exceeds some predetermined threshold, it is assumed that there is a problem that must be fixed.", "rank": 1723, "start": 207244, "IsComparative": "0", "id": "st_1723"}, {"end": 207603, "text": "This approach is certainly valuable and we do not advocate the MMS as a replacement for using real-world data, or any other method that users are accustomed with for that matter.", "rank": 1724, "start": 207425, "IsComparative": "0", "id": "st_1724"}, {"end": 207689, "text": "Instead, we advocate its use in addition to the methods already adopted by developers.", "rank": 1725, "start": 207603, "IsComparative": "0", "id": "st_1725"}]}, {"paragraph_info": {"end": 207710, "start": 207689, "text": "7.2 Order of Accuracy", "rank": 438, "paragraph_comparative_number": 0, "entities": [], "id": "p_438"}, "sentences": [{"end": 207710, "text": "7.2 Order of Accuracy", "rank": 1726, "start": 207689, "IsComparative": "0", "id": "st_1726"}]}, {"paragraph_info": {"end": 208477, "start": 207710, "text": "As our work have shown, it is not always possible to use order of accuracy as a standard method for the verification of visualization algorithms.While geometrical properties can be continuously evaluated, topological properties have a binary nature.We then conclude that the implementation of the MMS is problem-dependent and the necessary mathematical tools must be tailored accordingly.Nevertheless, the idea of verification through manufactured solutions can be used across many visualizations techniques.We expect MMS to enjoy a similar effectiveness in many areas of scientific visualization.This is the most direct direction of future work: the application of the MMS to other visualization techniques such as vector field visualization and mesh simplification.", "rank": 439, "paragraph_comparative_number": 2, "entities": [], "id": "p_439"}, "sentences": [{"end": 207855, "text": "As our work have shown, it is not always possible to use order of accuracy as a standard method for the verification of visualization algorithms.", "rank": 1727, "start": 207710, "IsComparative": "1", "id": "st_1727"}, {"end": 207959, "text": "While geometrical properties can be continuously evaluated, topological properties have a binary nature.", "rank": 1728, "start": 207855, "IsComparative": "0", "id": "st_1728"}, {"end": 208098, "text": "We then conclude that the implementation of the MMS is problem-dependent and the necessary mathematical tools must be tailored accordingly.", "rank": 1729, "start": 207959, "IsComparative": "0", "id": "st_1729"}, {"end": 208218, "text": "Nevertheless, the idea of verification through manufactured solutions can be used across many visualizations techniques.", "rank": 1730, "start": 208098, "IsComparative": "0", "id": "st_1730"}, {"end": 208307, "text": "We expect MMS to enjoy a similar effectiveness in many areas of scientific visualization.", "rank": 1731, "start": 208218, "IsComparative": "0", "id": "st_1731"}, {"end": 208477, "text": "This is the most direct direction of future work: the application of the MMS to other visualization techniques such as vector field visualization and mesh simplification.", "rank": 1732, "start": 208307, "IsComparative": "1", "id": "st_1732"}]}, {"paragraph_info": {"end": 208491, "start": 208477, "text": "7.3 Evaluation", "rank": 440, "paragraph_comparative_number": 0, "entities": [], "id": "p_440"}, "sentences": [{"end": 208491, "text": "7.3 Evaluation", "rank": 1733, "start": 208477, "IsComparative": "0", "id": "st_1733"}]}, {"paragraph_info": {"end": 209162, "start": 208491, "text": "The economic impact due to the lack of appropriate infrastructure for software testing is well studied.A NIST report estimates that the total loss due to lack of software testing is about $22.2 to $59.5 billion <166>.To the best of our knowledge, the economic impact and consequences of the lack of software testing for the subfield of scientific visualization has not yet been evaluated.Nevertheless, there is anecdotal evidence of the need for this evaluation.As an example, we cite a medical report extracted from the Manufacturer and User Facility Device Experience (MAUDE), a data repository of adverse events involving medical devices under the umbrella of the FDA:", "rank": 441, "paragraph_comparative_number": 3, "entities": [], "id": "p_441"}, "sentences": [{"end": 208594, "text": "The economic impact due to the lack of appropriate infrastructure for software testing is well studied.", "rank": 1734, "start": 208491, "IsComparative": "0", "id": "st_1734"}, {"end": 208708, "text": "A NIST report estimates that the total loss due to lack of software testing is about $22.2 to $59.5 billion <166>.", "rank": 1735, "start": 208594, "IsComparative": "1", "id": "st_1735"}, {"end": 208879, "text": "To the best of our knowledge, the economic impact and consequences of the lack of software testing for the subfield of scientific visualization has not yet been evaluated.", "rank": 1736, "start": 208708, "IsComparative": "1", "id": "st_1736"}, {"end": 208953, "text": "Nevertheless, there is anecdotal evidence of the need for this evaluation.", "rank": 1737, "start": 208879, "IsComparative": "1", "id": "st_1737"}, {"end": 209162, "text": "As an example, we cite a medical report extracted from the Manufacturer and User Facility Device Experience (MAUDE), a data repository of adverse events involving medical devices under the umbrella of the FDA:", "rank": 1738, "start": 208953, "IsComparative": "0", "id": "st_1738"}]}, {"paragraph_info": {"end": 209420, "start": 209162, "text": "The patient was undergoing a kidney operation and the kidney image as displayed on the systems image monitor allegedly flipped in orientation without any operator intervention and as a result it is alleged that the patient had the wrong kidney operated upon.", "rank": 442, "paragraph_comparative_number": 0, "entities": [], "id": "p_442"}, "sentences": [{"end": 209420, "text": "The patient was undergoing a kidney operation and the kidney image as displayed on the systems image monitor allegedly flipped in orientation without any operator intervention and as a result it is alleged that the patient had the wrong kidney operated upon.", "rank": 1739, "start": 209162, "IsComparative": "0", "id": "st_1739"}]}, {"paragraph_info": {"end": 210111, "start": 209420, "text": "The bug described previously is not severe in the sense that the final image is a perfectly valid one.Nevertheless, the outcome is quite alarming.There are several similar reports involving images flips and artifacts in medical devices dating from early 90s  when the information started to be collected  until now.Many of these reports highlight that the problem did not cause any injury; however, they also emphasize the risk of misdiagnosis.It may be interesting to perform a user study using visualization results that contains known bugs and bug-free images to evaluate the class of problems that developer/expert can detect.This is out of scope of this work and is left as future work.", "rank": 443, "paragraph_comparative_number": 1, "entities": [], "id": "p_443"}, "sentences": [{"end": 209522, "text": "The bug described previously is not severe in the sense that the final image is a perfectly valid one.", "rank": 1740, "start": 209420, "IsComparative": "0", "id": "st_1740"}, {"end": 209566, "text": "Nevertheless, the outcome is quite alarming.", "rank": 1741, "start": 209522, "IsComparative": "0", "id": "st_1741"}, {"end": 209735, "text": "There are several similar reports involving images flips and artifacts in medical devices dating from early 90s  when the information started to be collected  until now.", "rank": 1742, "start": 209566, "IsComparative": "0", "id": "st_1742"}, {"end": 209864, "text": "Many of these reports highlight that the problem did not cause any injury; however, they also emphasize the risk of misdiagnosis.", "rank": 1743, "start": 209735, "IsComparative": "0", "id": "st_1743"}, {"end": 210050, "text": "It may be interesting to perform a user study using visualization results that contains known bugs and bug-free images to evaluate the class of problems that developer/expert can detect.", "rank": 1744, "start": 209864, "IsComparative": "1", "id": "st_1744"}, {"end": 210111, "text": "This is out of scope of this work and is left as future work.", "rank": 1745, "start": 210050, "IsComparative": "0", "id": "st_1745"}]}, {"paragraph_info": {"end": 210127, "start": 210111, "text": "7.4 Broad Impact", "rank": 444, "paragraph_comparative_number": 0, "entities": [], "id": "p_444"}, "sentences": [{"end": 210127, "text": "7.4 Broad Impact", "rank": 1746, "start": 210111, "IsComparative": "0", "id": "st_1746"}]}, {"paragraph_info": {"end": 211041, "start": 210127, "text": "Verification has gained some traction inside the field of visualization in recent years.We have seen several initiatives that support this: two workshops on reproducibility, verifica- tion, and validation in visualization (EuroRV3 2012-2013) at Eurovis; a discussion panel Verification in Visualization: Building a Common Culture at IEEE VisWeek 2011; and verification as part of the call for participation for IEEE VisWeek 2010-2013.We hope the examples presented here will further encourage the adoption of MMS by the visualization community at large, increasing the impact of its contributions to a wider audience.We believe that researchers and developers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.We hope that the results of this work further motivate the visualization community to develop a culture of verification.", "rank": 445, "paragraph_comparative_number": 4, "entities": [], "id": "p_445"}, "sentences": [{"end": 210215, "text": "Verification has gained some traction inside the field of visualization in recent years.", "rank": 1747, "start": 210127, "IsComparative": "1", "id": "st_1747"}, {"end": 210561, "text": "We have seen several initiatives that support this: two workshops on reproducibility, verifica- tion, and validation in visualization (EuroRV3 2012-2013) at Eurovis; a discussion panel Verification in Visualization: Building a Common Culture at IEEE VisWeek 2011; and verification as part of the call for participation for IEEE VisWeek 2010-2013.", "rank": 1748, "start": 210215, "IsComparative": "1", "id": "st_1748"}, {"end": 210744, "text": "We hope the examples presented here will further encourage the adoption of MMS by the visualization community at large, increasing the impact of its contributions to a wider audience.", "rank": 1749, "start": 210561, "IsComparative": "1", "id": "st_1749"}, {"end": 210921, "text": "We believe that researchers and developers should consider adopting verification as an integral part of the investigation and development of scientific visualization techniques.", "rank": 1750, "start": 210744, "IsComparative": "1", "id": "st_1750"}, {"end": 211041, "text": "We hope that the results of this work further motivate the visualization community to develop a culture of verification.", "rank": 1751, "start": 210921, "IsComparative": "0", "id": "st_1751"}]}]}